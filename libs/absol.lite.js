!(function(global) {
const moduleFactories = {};
const modules = {};
const moduleLinks = {};
moduleFactories["node_modules/absol-acomp/css/default.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/autocompleteinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/bscroller.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/boardtable.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/hanger.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/buttonarray.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/buttonrange.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/calendarinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/scroller.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/chromecalendar.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/checkbox.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/checkboxinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/checkboxbutton.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/chrometimepicker.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/circlesectionlabel.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/contextmenu.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/follower.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/menu.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/countdownclock.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/dvexptree.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/exptree.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/dateinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/datetimeinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/draggablestack.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/droppanel.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/dropzone.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/editabletext.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/emojicounter.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/emojipicker.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/tooltip.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/pageindicator.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/emojipickertooltip.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/emojiuserlisttooltip.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/flexiconbutton.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/flexiconinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/frame.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/frameview.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/hruler.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/hexasectionlabel.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/linearcolorbar.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/mediainput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/messageinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/modal.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/multiselectmenu.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/selectmenu.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/selectlistbox.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/selectlist.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/selectbox.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/numberinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/onscreenwidget.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/onscreenwindow.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/pageselector.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/preinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/progressbar.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/quicklistbutton.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/quickpath.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/radio.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/radiobutton.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/radioinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/resizebox.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/ribbonbutton.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/ribbonsplitbutton.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/rotatedtext.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/searcher.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/selecttable.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/selecttreemenu.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/singlepage.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/snackbar.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/spaninput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/statictabbar.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/switch.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/tabview.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/tablescroller.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/tablevscroller.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/textarea2.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/textclipboard.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/timeinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/timepicker.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/timeselectinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/toast.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/variantcolors.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/tokenfield.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/trackbar.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/trackbarinput.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/treelist.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/vruler.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/verticaltreediagram.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

moduleFactories["node_modules/absol-acomp/css/widthheightresizer.css"] = function(module, exports, require, __dir__, __file_name__){
module.exports = {};
return module.exports;
};

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function module_require(cr, rq) {
    var id;
    if (cr){
        if (rq.startsWith(".")) {
                id = path.join(cr, "..", rq) || ".";
            }
            else {
                id = "node_modules/" + rq;
            }
    }
    else {
        id = rq;
    }


    var dir = path.join(id, '..');
    id = moduleLinks[id] || id;
    var factory;
    if (moduleFactories[id]) {
        factory = moduleFactories[id];
    }
    else if (moduleFactories[id + '.js']) {
        factory = moduleFactories[id + '.js'];
        id += '.js';
    }
    var module = modules[id];
    if (module) {
        return module && module.exports;
    }
    else {
        module = { exports: {} };
        modules[id] = module;
        if (factory){
            module.exports = factory(module, module.exports, module_require.bind(null, id), dir, id);
        }
        else {
            console.error("Could not file module "+ id + '. ', "Please update indexed module!" );
        }
        
        return  module.exports;
    }
}

const process = {};
process.cwd = function () {
    return "JSPureWriter";
}
process.env = {};
process.browser = true;


const path = (function () {
    'use strict';

    function assertPath(path) {
        if (typeof path !== 'string') {
            throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
        }
    }

    // Resolves . and .. elements in a path with directory names
    function normalizeStringPosix(path, allowAboveRoot) {
        var res = '';
        var lastSegmentLength = 0;
        var lastSlash = -1;
        var dots = 0;
        var code;
        for (var i = 0; i <= path.length; ++i) {
            if (i < path.length)
                code = path.charCodeAt(i);
            else if (code === 47 /*/*/)
                break;
            else
                code = 47 /*/*/;
            if (code === 47 /*/*/) {
                if (lastSlash === i - 1 || dots === 1) {
                    // NOOP
                }
                else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
                        if (res.length > 2) {
                            var lastSlashIndex = res.lastIndexOf('/');
                            if (lastSlashIndex !== res.length - 1) {
                                if (lastSlashIndex === -1) {
                                    res = '';
                                    lastSegmentLength = 0;
                                }
                                else {
                                    res = res.slice(0, lastSlashIndex);
                                    lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                                }
                                lastSlash = i;
                                dots = 0;
                                continue;
                            }
                        }
                        else if (res.length === 2 || res.length === 1) {
                            res = '';
                            lastSegmentLength = 0;
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    }
                    if (allowAboveRoot) {
                        if (res.length > 0)
                            res += '/..';
                        else
                            res = '..';
                        lastSegmentLength = 2;
                    }
                }
                else {
                    if (res.length > 0)
                        res += '/' + path.slice(lastSlash + 1, i);
                    else
                        res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
            }
            else if (code === 46 /*.*/ && dots !== -1) {
                ++dots;
            }
            else {
                dots = -1;
            }
        }
        return res;
    }

    function _format(sep, pathObject) {
        var dir = pathObject.dir || pathObject.root;
        var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
        if (!dir) {
            return base;
        }
        if (dir === pathObject.root) {
            return dir + base;
        }
        return dir + sep + base;
    }

    var posix = {
        // path.resolve([from ...], to)
        resolve: function resolve() {
            var resolvedPath = '';
            var resolvedAbsolute = false;
            var cwd;

            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path;
                if (i >= 0)
                    path = arguments[i];
                else {
                    if (cwd === undefined)
                        cwd = process.cwd();
                    path = cwd;
                }

                assertPath(path);

                // Skip empty entries
                if (path.length === 0) {
                    continue;
                }

                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
            }

            // At this point the path should be resolved to a full absolute path, but
            // handle relative paths to be safe (might happen when process.cwd() fails)

            // Normalize the path
            resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

            if (resolvedAbsolute) {
                if (resolvedPath.length > 0)
                    return '/' + resolvedPath;
                else
                    return '/';
            }
            else if (resolvedPath.length > 0) {
                return resolvedPath;
            }
            else {
                return '.';
            }
        },

        normalize: function normalize(path) {
            assertPath(path);

            if (path.length === 0) return '.';

            var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
            var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

            // Normalize the path
            path = normalizeStringPosix(path, !isAbsolute);

            if (path.length === 0 && !isAbsolute) path = '.';
            if (path.length > 0 && trailingSeparator) path += '/';

            if (isAbsolute) return '/' + path;
            return path;
        },

        isAbsolute: function isAbsolute(path) {
            assertPath(path);
            return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
        },

        join: function join() {
            if (arguments.length === 0)
                return '.';
            var joined;
            for (var i = 0; i < arguments.length; ++i) {
                var arg = arguments[i];
                assertPath(arg);
                if (arg.length > 0) {
                    if (joined === undefined)
                        joined = arg;
                    else
                        joined += '/' + arg;
                }
            }
            if (joined === undefined)
                return '.';
            return posix.normalize(joined);
        },

        relative: function relative(from, to) {
            assertPath(from);
            assertPath(to);

            if (from === to) return '';

            from = posix.resolve(from);
            to = posix.resolve(to);

            if (from === to) return '';

            // Trim any leading backslashes
            var fromStart = 1;
            for (; fromStart < from.length; ++fromStart) {
                if (from.charCodeAt(fromStart) !== 47 /*/*/)
                    break;
            }
            var fromEnd = from.length;
            var fromLen = fromEnd - fromStart;

            // Trim any leading backslashes
            var toStart = 1;
            for (; toStart < to.length; ++toStart) {
                if (to.charCodeAt(toStart) !== 47 /*/*/)
                    break;
            }
            var toEnd = to.length;
            var toLen = toEnd - toStart;

            // Compare paths to find the longest common path from root
            var length = fromLen < toLen ? fromLen : toLen;
            var lastCommonSep = -1;
            var i = 0;
            for (; i <= length; ++i) {
                if (i === length) {
                    if (toLen > length) {
                        if (to.charCodeAt(toStart + i) === 47 /*/*/) {
                            // We get here if `from` is the exact base path for `to`.
                            // For example: from='/foo/bar'; to='/foo/bar/baz'
                            return to.slice(toStart + i + 1);
                        }
                        else if (i === 0) {
                            // We get here if `from` is the root
                            // For example: from='/'; to='/foo'
                            return to.slice(toStart + i);
                        }
                    }
                    else if (fromLen > length) {
                        if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
                            // We get here if `to` is the exact base path for `from`.
                            // For example: from='/foo/bar/baz'; to='/foo/bar'
                            lastCommonSep = i;
                        }
                        else if (i === 0) {
                            // We get here if `to` is the root.
                            // For example: from='/foo'; to='/'
                            lastCommonSep = 0;
                        }
                    }
                    break;
                }
                var fromCode = from.charCodeAt(fromStart + i);
                var toCode = to.charCodeAt(toStart + i);
                if (fromCode !== toCode)
                    break;
                else if (fromCode === 47 /*/*/)
                    lastCommonSep = i;
            }

            var out = '';
            // Generate the relative path based on the path difference between `to`
            // and `from`
            for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
                if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
                    if (out.length === 0)
                        out += '..';
                    else
                        out += '/..';
                }
            }

            // Lastly, append the rest of the destination (`to`) path that comes after
            // the common path parts
            if (out.length > 0)
                return out + to.slice(toStart + lastCommonSep);
            else {
                toStart += lastCommonSep;
                if (to.charCodeAt(toStart) === 47 /*/*/)
                    ++toStart;
                return to.slice(toStart);
            }
        },

        _makeLong: function _makeLong(path) {
            return path;
        },

        dirname: function dirname(path) {
            assertPath(path);
            if (path.length === 0) return '.';
            var code = path.charCodeAt(0);
            var hasRoot = code === 47 /*/*/;
            var end = -1;
            var matchedSlash = true;
            for (var i = path.length - 1; i >= 1; --i) {
                code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                    if (!matchedSlash) {
                        end = i;
                        break;
                    }
                }
                else {
                    // We saw the first non-path separator
                    matchedSlash = false;
                }
            }

            if (end === -1) return hasRoot ? '/' : '.';
            if (hasRoot && end === 1) return '//';
            return path.slice(0, end);
        },

        basename: function basename(path, ext) {
            if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
            assertPath(path);

            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;

            if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
                if (ext.length === path.length && ext === path) return '';
                var extIdx = ext.length - 1;
                var firstNonSlashEnd = -1;
                for (i = path.length - 1; i >= 0; --i) {
                    var code = path.charCodeAt(i);
                    if (code === 47 /*/*/) {
                        // If we reached a path separator that was not part of a set of path
                        // separators at the end of the string, stop now
                        if (!matchedSlash) {
                            start = i + 1;
                            break;
                        }
                    }
                    else {
                        if (firstNonSlashEnd === -1) {
                            // We saw the first non-path separator, remember this index in case
                            // we need it if the extension ends up not matching
                            matchedSlash = false;
                            firstNonSlashEnd = i + 1;
                        }
                        if (extIdx >= 0) {
                            // Try to match the explicit extension
                            if (code === ext.charCodeAt(extIdx)) {
                                if (--extIdx === -1) {
                                    // We matched the extension, so mark this as the end of our path
                                    // component
                                    end = i;
                                }
                            }
                            else {
                                // Extension does not match, so our result is the entire path
                                // component
                                extIdx = -1;
                                end = firstNonSlashEnd;
                            }
                        }
                    }
                }

                if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;
                return path.slice(start, end);
            }
            else {
                for (i = path.length - 1; i >= 0; --i) {
                    if (path.charCodeAt(i) === 47 /*/*/) {
                        // If we reached a path separator that was not part of a set of path
                        // separators at the end of the string, stop now
                        if (!matchedSlash) {
                            start = i + 1;
                            break;
                        }
                    }
                    else if (end === -1) {
                        // We saw the first non-path separator, mark this as the end of our
                        // path component
                        matchedSlash = false;
                        end = i + 1;
                    }
                }

                if (end === -1) return '';
                return path.slice(start, end);
            }
        },

        extname: function extname(path) {
            assertPath(path);
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            // Track the state of characters (if any) we see before our first dot and
            // after any path separator we find
            var preDotState = 0;
            for (var i = path.length - 1; i >= 0; --i) {
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        startPart = i + 1;
                        break;
                    }
                    continue;
                }
                if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // extension
                    matchedSlash = false;
                    end = i + 1;
                }
                if (code === 46 /*.*/) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1)
                        startDot = i;
                    else if (preDotState !== 1)
                        preDotState = 1;
                }
                else if (startDot !== -1) {
                    // We saw a non-dot and non-path separator before our dot, so we should
                    // have a good chance at having a non-empty extension
                    preDotState = -1;
                }
            }

            if (startDot === -1 || end === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                return '';
            }
            return path.slice(startDot, end);
        },

        format: function format(pathObject) {
            if (pathObject === null || typeof pathObject !== 'object') {
                throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
            }
            return _format('/', pathObject);
        },

        parse: function parse(path) {
            assertPath(path);

            var ret = { root: '', dir: '', base: '', ext: '', name: '' };
            if (path.length === 0) return ret;
            var code = path.charCodeAt(0);
            var isAbsolute = code === 47 /*/*/;
            var start;
            if (isAbsolute) {
                ret.root = '/';
                start = 1;
            }
            else {
                start = 0;
            }
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var i = path.length - 1;

            // Track the state of characters (if any) we see before our first dot and
            // after any path separator we find
            var preDotState = 0;

            // Get non-dir info
            for (; i >= start; --i) {
                code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        startPart = i + 1;
                        break;
                    }
                    continue;
                }
                if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // extension
                    matchedSlash = false;
                    end = i + 1;
                }
                if (code === 46 /*.*/) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1) startDot = i; else if (preDotState !== 1) preDotState = 1;
                }
                else if (startDot !== -1) {
                    // We saw a non-dot and non-path separator before our dot, so we should
                    // have a good chance at having a non-empty extension
                    preDotState = -1;
                }
            }

            if (startDot === -1 || end === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                if (end !== -1) {
                    if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end); else ret.base = ret.name = path.slice(startPart, end);
                }
            }
            else {
                if (startPart === 0 && isAbsolute) {
                    ret.name = path.slice(1, startDot);
                    ret.base = path.slice(1, end);
                }
                else {
                    ret.name = path.slice(startPart, startDot);
                    ret.base = path.slice(startPart, end);
                }
                ret.ext = path.slice(startDot, end);
            }

            if (startPart > 0) ret.dir = path.slice(0, startPart - 1); else if (isAbsolute) ret.dir = '/';

            return ret;
        },

        sep: '/',
        delimiter: ':',
        win32: null,
        posix: null
    };
    return posix;
})();
        moduleFactories["node_modules/absol/src/String/getFunctionName.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/String/getFunctionName.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFunctionName;

/**
 * 
 * @param {Function} func 
 */
function getFunctionName(func) {
  var ret = func.toString();
  ret = ret.substr('function '.length);
  ret = ret.substr(0, ret.indexOf('('));
  return ret;
}
return module.exports;
};

moduleFactories["node_modules/absol/src/JSX/attribute.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/JSX/attribute.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseStyleAttr = parseStyleAttr;
exports.parseClassAttr = parseClassAttr;

/**
 * 
 * @param {String} text 
 *  @returns {Object}
 */
function parseStyleAttr(text) {
  return text.split(';').map(function (line) {
    var parts = line.split(':');
    if (parts.length < 2) return null;
    var key = parts.shift().trim();
    var value = parts.join(':').trim();
    if (key.length == 0 || value.length == 0) return null;
    return [key, value];
  }).filter(function (it) {
    return it != null;
  }).reduce(function (ac, cr) {
    ac[cr[0]] = cr[1];
    return ac;
  }, {});
}
/**
 * 
 * @param {String} text 
 *  @returns {Array<String>}
 */


function parseClassAttr(text) {
  return text.trim().split(/\s+/);
}
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/OOP.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/OOP.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var OOP = {};
/**
 * @param {Object} object
 * @param {String} key
 * @param {Function} method
 */

OOP.overrideMethod = function (object, key, method) {
  if (object[key] === undefined) object[key] = method;else {
    var _superMethod = object[key];

    object[key] = function (_superMethod, method) {
      return function () {
        var _super = this.super;
        this.super = _superMethod;
        var result = method.apply(this, arguments);
        this.super = _super;
        return result;
      };
    }(_superMethod, method);
  }
};

OOP.extends = function (object, prototype) {
  // do not use setter, getter
  for (var key in prototype) {
    if (key !== 'constructor' && key !== '__proto__') {
      if (typeof prototype[key] == 'function') {
        OOP.overrideMethod(object, key, prototype[key]);
      } else if (prototype[key] !== undefined && prototype[key] !== null) {
        object[key] = prototype[key]; //just copy
      }
    }
  }
};

OOP.inherit = function (child, parent) {
  // do not use setter, getter
  Object.keys(parent).forEach(function (key) {
    if (key !== 'constructor' && typeof parent[key] == 'function') {
      var superMethod = parent[key];
      var currentMethod = child[key];
      if (!currentMethod) child[key] = superMethod;else {
        child[key] = function () {
          var _super = this.super;
          this.super = superMethod;
          var result = currentMethod.apply(this, arguments);
          this.super = _super;
          return result;
        };
      }
    }
  });
};

OOP.drillProperty = function (topObject, botObject, keyTop, keyBot) {
  if (typeof keyTop == 'string') {
    keyBot = keyBot || keyTop;
    Object.defineProperty(topObject, keyTop, {
      set: function (value) {
        botObject[keyBot] = value;
      },
      get: function () {
        return botObject[keyBot];
      }
    });
  } else {
    if (keyTop instanceof Array) {
      for (var i = 0; i < keyTop.length; ++i) {
        OOP.drillProperty(topObject, botObject, keyTop[i], keyTop[i]);
      }
    } else {
      for (var key in keyTop) {
        OOP.drillProperty(topObject, botObject, key, keyTop[key]);
      }
    }
  }
};

OOP.bindFunctions = function (_this, handlers) {
  var res = {};

  for (var key in handlers) {
    res[key] = handlers[key].bind(_this);
  }

  return res;
};

OOP.inheritCreator = function (parent, child) {
  var i;

  if (child.property) {
    if (parent.property) {
      for (i in parent.property) {
        if (!child.property[i]) child.property[i] = parent.property[i];
      }
    }
  }

  for (i in parent.prototype) {
    if (!child.prototype[i]) {
      child.prototype[i] = parent.prototype[i];
    } else {
      child.prototype[i] = function (superFunction, childFunction) {
        return function () {
          var _super = this.super;
          this.super = superFunction;
          var result = childFunction.apply(this, arguments);
          this.super = _super;
          return result;
        };
      }(parent.prototype[i], child.prototype[i]);
    }
  }
};
/***
 *
 * @param {Function} constructor
 */


OOP.mixClass = function (constructor) {
  var descriptors = {};

  for (var i = 1; i < arguments.length; ++i) {
    Object.assign(descriptors, Object.getOwnPropertyDescriptors(arguments[i].prototype));
  }

  Object.defineProperties(constructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
};

var _default = OOP;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/EventEmitter.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/EventEmitter.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMouseRight = isMouseRight;
exports.isMouseLeft = isMouseLeft;
exports.hitElement = hitElement;
exports.copyEvent = copyEvent;
exports.copyTouch = copyTouch;
exports.findChangedTouchByIdent = findChangedTouchByIdent;
exports.findTouchByIdent = findTouchByIdent;
exports.default = exports.touchProperties = exports.eventProperties = void 0;

function EventEmitter() {
  if (!this._azar_extendEvents) {
    Object.defineProperty(this, '_azar_extendEvents', {
      enumerable: false,
      value: this._azar_extendEvents || {
        supported: {},
        prioritize: {},
        nonprioritize: {}
      }
    });
    Object.defineProperty(this, '__azar_force', {
      value: !(typeof Node === "object" ? this instanceof Node : this && typeof this === "object" && typeof this.nodeType === "number" && typeof this.nodeName === "string"),
      enumerable: false
    });
  }
}

EventEmitter.prototype.defineEvent = function (name) {
  if (name instanceof Array) {
    for (var i = 0; i < name.length; ++i) this._azar_extendEvents.supported[name[i]] = true;
  } else this._azar_extendEvents.supported[name] = true;

  return this;
};

EventEmitter.prototype.isSupportedEvent = function (name) {
  return this.__azar_force || !!this._azar_extendEvents.supported[name];
};

EventEmitter.prototype.emit = function (eventName, data) {
  this.fire.apply(this, arguments);
};

EventEmitter.prototype.fire = function (eventName, data) {
  var others = Array.prototype.slice.call(arguments, 1);

  if (this.isSupportedEvent(eventName)) {
    var listenerList;
    var i;

    if (this._azar_extendEvents.prioritize[eventName]) {
      listenerList = this._azar_extendEvents.prioritize[eventName].slice();

      for (i = 0; i < listenerList.length; ++i) {
        try {
          listenerList[i].wrappedCallback.apply(this, others);
        } catch (e) {
          console.error(e);
        }
      }
    }

    if (this._azar_extendEvents.nonprioritize[eventName]) {
      listenerList = this._azar_extendEvents.nonprioritize[eventName].slice();

      for (i = 0; i < listenerList.length; ++i) {
        try {
          listenerList[i].wrappedCallback.apply(this, others);
        } catch (e) {
          console.error(e);
        }
      }
    }
  } else {
    if (this.dispatchEvent) {
      var event = new Event(eventName);
      data && Object.assign(event, data);
      this.dispatchEvent(event);
    } else throw new Error("Not support event " + eventName);
  }

  return this;
};

EventEmitter.prototype.eventEmittorOnWithTime = function (isOnce, arg0, arg1, arg2) {
  if (typeof arg0 == 'object') {
    for (var key in arg0) {
      this.eventEmittorOnWithTime(isOnce, key, arg0[key]);
    }

    return this;
  } else {
    if (typeof arg1 == 'object') {
      return this.eventEmittorOnWithTime(isOnce, arg0, arg1.callback, arg1.cap);
    } else {
      var eventArr = this._azar_extendEvents[arg2 ? 'prioritize' : 'nonprioritize'][arg0] || [];
      var eventIndex = -1;

      for (var i = 0; i < eventArr.length; ++i) {
        if (eventArr[i].wrappedCallback == arg1) {
          eventIndex = i;
          break;
        }
      }

      if (eventIndex < 0) {
        var event = {
          isOnce: isOnce,
          eventName: arg0,
          callback: arg1,
          cap: !!arg2
        }; //wrappedCallback will be call

        if (isOnce) {
          event.wrappedCallback = function () {
            event.callback.apply(this, arguments);
            this.off(event.eventName, event.wrappedCallback, event.cap);
          };
        } else {
          event.wrappedCallback = event.callback;
        }

        if (!this.isSupportedEvent(arg0)) {
          if (this.addEventListener) {
            this.addEventListener(arg0, event.wrappedCallback, !!arg2);
          } else {
            this.attachEvent('on' + arg0, arg1, !!arg2);
          }
        }

        eventArr.push(event);
        this._azar_extendEvents[arg2 ? 'prioritize' : 'nonprioritize'][arg0] = eventArr;
      } else {
        console.warn("dupplicate event");
      }
    }

    return this;
  }
};

EventEmitter.prototype.on = function (arg0, arg1, arg2) {
  this.eventEmittorOnWithTime(false, arg0, arg1, arg2);
  return this;
};

EventEmitter.prototype.once = function (arg0, arg1, arg2) {
  this.eventEmittorOnWithTime(true, arg0, arg1, arg2);
  return this;
};

EventEmitter.prototype.off = function (arg0, arg1, arg2) {
  if (typeof arg0 == 'object') {
    for (var key in arg0) {
      this.off(key, arg0[key]);
    }

    return this;
  } else {
    if (typeof arg1 == 'object') {
      return this.off(arg0, arg1.callback, arg1.cap);
    } else {
      var eventArr = this._azar_extendEvents[arg2 ? 'prioritize' : 'nonprioritize'][arg0] || [];
      var newEventArray = [];

      for (var i = 0; i < eventArr.length; ++i) {
        var event = eventArr[i];

        if (event.wrappedCallback == arg1) {
          //Dont add to newEventArray
          if (this.isSupportedEvent(arg0)) {} else {
            if (this.removeEventListener) {
              this.removeEventListener(event.eventName, event.wrappedCallback, !!event.cap);
            } else {
              this.detachEvent('on' + event.eventName, event.wrappedCallback, !!event.cap);
            }
          }
        } else {
          newEventArray.push(event);
        }
      }

      this._azar_extendEvents[arg2 ? 'prioritize' : 'nonprioritize'][arg0] = newEventArray;
      return this;
    }
  }
};

var eventProperties = ["altKey", "bubbles", "button", "buttons", "cancelBubble", "cancelable", "clientX", "clientY", "composed", "ctrlKey", "currentTarget", "defaultPrevented", "deltaMode", "deltaX", "deltaY", "deltaZ", "detail", "eventPhase", "explicitOriginalTarget", "isTrusted", "layerX", "layerY", "metaKey", "movementX", "movementY", "mozInputSource", "mozPressure", "offsetX", "offsetY", "originalTarget", "pageX", "pageY", "rangeOffset", "rangeParent", "region", "relatedTarget", "returnValue", "screenX", "screenY", "shiftKey", "srcElement", "target", "timeStamp", "type", "deltaMode", "deltaX", "deltaY", "deltaZ", 'preventDefault'];
exports.eventProperties = eventProperties;
var touchProperties = ['clientX', 'clientY', 'force', 'identifier', 'pageX', 'pageY', 'rotationAngle', 'screenX', 'screenY', 'target'];
exports.touchProperties = touchProperties;

function isMouseRight(event) {
  var isRightMB = false;
  if ("which" in event) // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
    isRightMB = event.which == 3;else if ("button" in event) // IE, Opera
    isRightMB = event.button == 2;
  return isRightMB;
}

function isMouseLeft(event) {
  var isLeftMB = false;
  if ("which" in event) // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
    isLeftMB = event.which == 1;else if ("button" in event) // IE, Opera
    isLeftMB = event.button == 1;
  return isLeftMB;
}

function hitElement(element, event) {
  var current = event.target;

  while (current) {
    if (current == element) return true;
    current = current.parentElement;
  }

  return false;
}

function copyEvent(event, props) {
  var result = {};
  var key, value; //copy native property

  for (var i = 0; i < eventProperties.length; ++i) {
    key = eventProperties[i];
    value = event[key];

    if (value !== undefined) {
      if (typeof value == "function") {
        result[key] = event[key].bind(event);
      } else {
        result[key] = event[key];
      }
    }
  }

  Object.assign(result, event);
  if (props) Object.assign(result, props);

  if (event.changedTouches) {
    result.changedTouches = Array.prototype.map.call(event.changedTouches, function (touch) {
      return copyTouch(touch);
    });
  }

  if (event.touches) {
    result.touches = Array.prototype.map.call(event.touches, function (touch) {
      return copyTouch(touch);
    });
  }

  return result;
}

function copyTouch(touch, props) {
  var result = {};
  var key, value; //copy native property

  for (var i = 0; i < touchProperties.length; ++i) {
    key = touchProperties[i];
    value = touch[key];

    if (value !== undefined) {
      if (typeof value == "function") {
        result[key] = touch[key].bind(touch);
      } else {
        result[key] = touch[key];
      }
    }
  }

  Object.assign(result, touch);
  if (props) Object.assign(result, props);
  return result;
}
/***
 *
 * @param {TouchEvent} event
 * @return {Touch | null}
 */


function findChangedTouchByIdent(event, identifier) {
  if (event.changedTouches) {
    for (var i = 0; i < event.changedTouches.length; ++i) {
      if (event.changedTouches[i].identifier === identifier) {
        return event.changedTouches[i];
      }
    }
  }

  return null;
}
/***
 *
 * @param event
 * @param identifier
 * @return {Touch|null}
 */


function findTouchByIdent(event, identifier) {
  if (event.touches) {
    for (var i = 0; i < event.touches.length; ++i) {
      if (event.touches[i].identifier === identifier) {
        return event.touches[i];
      }
    }
  }

  return null;
}

EventEmitter.isMouseRight = isMouseRight;
EventEmitter.isMouseLeft = isMouseLeft;
EventEmitter.hitElement = hitElement;
EventEmitter.copyEvent = copyEvent;
EventEmitter.eventProperties = eventProperties;
var _default = EventEmitter;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/Detector/BrowserRules.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/Detector/BrowserRules.js ***/
"use strict";

const external = global.external;
const re_msie = /\b(?:msie |ie |trident\/[0-9].*rv[ :])([0-9.]+)/;
const re_blackberry_10 = /\bbb10\b.+?\bversion\/([\d.]+)/;
const re_blackberry_6_7 = /\bblackberry\b.+\bversion\/([\d.]+)/;
const re_blackberry_4_5 = /\bblackberry\d+\/([\d.]+)/;
const NA_VERSION = "-1";
const DEVICES = [["nokia", function (ua) {
  //  nokia/-1
  if (ua.indexOf("nokia ") !== -1) {
    return /\bnokia ([0-9]+)?/;
  } else {
    return /\bnokia([a-z0-9]+)?/;
  }
}], //Android WP
["samsung", function (ua) {
  if (ua.indexOf("samsung") !== -1) {
    return /\bsamsung(?:[ \-](?:sgh|gt|sm))?-([a-z0-9]+)/;
  } else {
    return /\b(?:sgh|sch|gt|sm)-([a-z0-9]+)/;
  }
}], ["wp", function (ua) {
  return ua.indexOf("windows phone ") !== -1 || ua.indexOf("xblwp") !== -1 || ua.indexOf("zunewp") !== -1 || ua.indexOf("windows ce") !== -1;
}], ["pc", "windows"], ["ipad", "ipad"], // ipod iphone
["ipod", "ipod"], ["iphone", /\biphone\b|\biph(\d)/], ["mac", "macintosh"], ["mi", /\bmi[ \-]?([a-z0-9 ]+(?= build|\)))/], ["hongmi", /\bhm[ \-]?([a-z0-9]+)/], ["aliyun", /\baliyunos\b(?:[\-](\d+))?/], ["meizu", function (ua) {
  return ua.indexOf("meizu") >= 0 ? /\bmeizu[\/ ]([a-z0-9]+)\b/ : /\bm([0-9cx]{1,4})\b/;
}], ["nexus", /\bnexus ([0-9s.]+)/], ["huawei", function (ua) {
  const re_mediapad = /\bmediapad (.+?)(?= build\/huaweimediapad\b)/;

  if (ua.indexOf("huawei-huawei") !== -1) {
    return /\bhuawei\-huawei\-([a-z0-9\-]+)/;
  } else if (re_mediapad.test(ua)) {
    return re_mediapad;
  } else {
    return /\bhuawei[ _\-]?([a-z0-9]+)/;
  }
}], ["lenovo", function (ua) {
  if (ua.indexOf("lenovo-lenovo") !== -1) {
    return /\blenovo\-lenovo[ \-]([a-z0-9]+)/;
  } else {
    return /\blenovo[ \-]?([a-z0-9]+)/;
  }
}], ["zte", function (ua) {
  if (/\bzte\-[tu]/.test(ua)) {
    return /\bzte-[tu][ _\-]?([a-su-z0-9\+]+)/;
  } else {
    return /\bzte[ _\-]?([a-su-z0-9\+]+)/;
  }
}], ["vivo", /\bvivo(?: ([a-z0-9]+))?/], ["htc", function (ua) {
  if (/\bhtc[a-z0-9 _\-]+(?= build\b)/.test(ua)) {
    return /\bhtc[ _\-]?([a-z0-9 ]+(?= build))/;
  } else {
    return /\bhtc[ _\-]?([a-z0-9 ]+)/;
  }
}], ["oppo", /\boppo[_ ]([a-z0-9]+)/], ["konka", /\bkonka[_\-]([a-z0-9]+)/], ["sonyericsson", /\bmt([a-z0-9]+)/], ["coolpad", /\bcoolpad[_ ]?([a-z0-9]+)/], ["lg", /\blg[\-]([a-z0-9]+)/], ["android", /\bandroid\b|\badr\b/], ["blackberry", function (ua) {
  if (ua.indexOf("blackberry") >= 0) {
    return /\bblackberry\s?(\d+)/;
  }

  return "bb10";
}]];
const OS = [["wp", function (ua) {
  if (ua.indexOf("windows phone ") !== -1) {
    return /\bwindows phone (?:os )?([0-9.]+)/;
  } else if (ua.indexOf("xblwp") !== -1) {
    return /\bxblwp([0-9.]+)/;
  } else if (ua.indexOf("zunewp") !== -1) {
    return /\bzunewp([0-9.]+)/;
  }

  return "windows phone";
}], ["windows", /\bwindows nt ([0-9.]+)/], ["macosx", /\bmac os x ([0-9._]+)/], ["ios", function (ua) {
  if (/\bcpu(?: iphone)? os /.test(ua)) {
    return /\bcpu(?: iphone)? os ([0-9._]+)/;
  } else if (ua.indexOf("iph os ") !== -1) {
    return /\biph os ([0-9_]+)/;
  } else {
    return /\bios\b/;
  }
}], ["yunos", /\baliyunos ([0-9.]+)/], ["android", function (ua) {
  if (ua.indexOf("android") >= 0) {
    return /\bandroid[ \/-]?([0-9.x]+)?/;
  } else if (ua.indexOf("adr") >= 0) {
    if (ua.indexOf("mqqbrowser") >= 0) {
      return /\badr[ ]\(linux; u; ([0-9.]+)?/;
    } else {
      return /\badr(?:[ ]([0-9.]+))?/;
    }
  }

  return "android"; //return /\b(?:android|\badr)(?:[\/\- ](?:\(linux; u; )?)?([0-9.x]+)?/;
}], ["chromeos", /\bcros i686 ([0-9.]+)/], ["linux", "linux"], ["windowsce", /\bwindows ce(?: ([0-9.]+))?/], ["symbian", /\bsymbian(?:os)?\/([0-9.]+)/], ["blackberry", function (ua) {
  const m = ua.match(re_blackberry_10) || ua.match(re_blackberry_6_7) || ua.match(re_blackberry_4_5);
  return m ? {
    version: m[1]
  } : "blackberry";
}], ['ie', /\rv\:\/([0-9.]+)/]];
const ENGINE = [["edgehtml", /edge\/([0-9.]+)/], ["trident", re_msie], ["blink", function () {
  return "chrome" in global && "CSS" in global && /\bapplewebkit[\/]?([0-9.+]+)/;
}], ["webkit", /\bapplewebkit[\/]?([0-9.+]+)/], ["gecko", function (ua) {
  const match = ua.match(/\brv:([\d\w.]+).*\bgecko\/(\d+)/);

  if (match) {
    return {
      version: match[1] + "." + match[2]
    };
  }
}], ["presto", /\bpresto\/([0-9.]+)/], ["androidwebkit", /\bandroidwebkit\/([0-9.]+)/], ["coolpadwebkit", /\bcoolpadwebkit\/([0-9.]+)/], ["u2", /\bu2\/([0-9.]+)/], ["u3", /\bu3\/([0-9.]+)/]];
const BROWSER = [['coccoc', /coc_coc_browser\/([0-9.]+)/], // Microsoft Edge Browser, Default browser in Windows 10.
["edge", /edge\/([0-9.]+)/], ["chrome-edge", /chrome.+edg\/([0-9.]+)/], // Sogou.
["sogou", function (ua) {
  if (ua.indexOf("sogoumobilebrowser") >= 0) {
    return /sogoumobilebrowser\/([0-9.]+)/;
  } else if (ua.indexOf("sogoumse") >= 0) {
    return true;
  }

  return / se ([0-9.x]+)/;
}], // Maxthon
["maxthon", function () {
  try {
    if (external && (external.mxVersion || external.max_version)) {
      return {
        version: external.mxVersion || external.max_version
      };
    }
  } catch (ex) {
    /* */
  }

  return /\b(?:maxthon|mxbrowser)(?:[ \/]([0-9.]+))?/;
}], ["micromessenger", /\bmicromessenger\/([\d.]+)/], ["qq", /\bm?qqbrowser\/([0-9.]+)/], ["green", "greenbrowser"], ["tt", /\btencenttraveler ([0-9.]+)/], ["liebao", function (ua) {
  if (ua.indexOf("liebaofast") >= 0) {
    return /\bliebaofast\/([0-9.]+)/;
  }

  if (ua.indexOf("lbbrowser") === -1) {
    return false;
  }

  var version;

  try {
    if (external && external.LiebaoGetVersion) {
      version = external.LiebaoGetVersion();
    }
  } catch (ex) {
    /* */
  }

  return {
    version: version || NA_VERSION
  };
}], ["tao", /\btaobrowser\/([0-9.]+)/], ["coolnovo", /\bcoolnovo\/([0-9.]+)/], ["saayaa", "saayaa"], ["baidu", /\b(?:ba?idubrowser|baiduhd)[ \/]([0-9.x]+)/], ["ie", re_msie], ["mi", /\bmiuibrowser\/([0-9.]+)/], ["opera", function (ua) {
  const re_opera_old = /\bopera.+version\/([0-9.ab]+)/;
  const re_opera_new = /\bopr\/([0-9.]+)/;
  return re_opera_old.test(ua) ? re_opera_old : re_opera_new;
}], ["oupeng", /\boupeng\/([0-9.]+)/], ["yandex", /yabrowser\/([0-9.]+)/], ["ali-ap", function (ua) {
  if (ua.indexOf("aliapp") > 0) {
    return /\baliapp\(ap\/([0-9.]+)\)/;
  } else {
    return /\balipayclient\/([0-9.]+)\b/;
  }
}], ["ali-ap-pd", /\baliapp\(ap-pd\/([0-9.]+)\)/], ["ali-am", /\baliapp\(am\/([0-9.]+)\)/], ["ali-tb", /\baliapp\(tb\/([0-9.]+)\)/], ["ali-tb-pd", /\baliapp\(tb-pd\/([0-9.]+)\)/], ["ali-tm", /\baliapp\(tm\/([0-9.]+)\)/], ["ali-tm-pd", /\baliapp\(tm-pd\/([0-9.]+)\)/], ["uc", function (ua) {
  if (ua.indexOf("ucbrowser/") >= 0) {
    return /\bucbrowser\/([0-9.]+)/;
  } else if (ua.indexOf("ubrowser/") >= 0) {
    return /\bubrowser\/([0-9.]+)/;
  } else if (/\buc\/[0-9]/.test(ua)) {
    return /\buc\/([0-9.]+)/;
  } else if (ua.indexOf("ucweb") >= 0) {
    // `ucweb/2.0` is compony info.
    // `UCWEB8.7.2.214/145/800` is browser info.
    return /\bucweb([0-9.]+)?/;
  } else {
    return /\b(?:ucbrowser|uc)\b/;
  }
}], ["baiduboxapp", function (ua) {
  var back = 0;
  var a;

  if (/ baiduboxapp\//i.test(ua)) {
    a = /([\d+.]+)_(?:diordna|enohpi)_/.exec(ua);

    if (a) {
      a = a[1].split(".");
      back = a.reverse().join(".");
    } else if (a = /baiduboxapp\/([\d+.]+)/.exec(ua)) {
      back = a[1];
    }

    return {
      version: back
    };
  }

  return false;
}], ["oppobrowser", /\boppobrowser\/([0-9.]+)/], ["edge-android", / (?:edga)\/([0-9.]+)/], ["chrome", / (?:chrome|crios|crmo)\/([0-9.]+)/], // Android safari 
["android", function (ua) {
  if (ua.indexOf("android") === -1) {
    return;
  }

  return /\bversion\/([0-9.]+(?: beta)?)/;
}], ["blackberry", function (ua) {
  const m = ua.match(re_blackberry_10) || ua.match(re_blackberry_6_7) || ua.match(re_blackberry_4_5);
  return m ? {
    version: m[1]
  } : "blackberry";
}], ["safari", /\bversion\/([0-9.]+(?: beta)?)(?: mobile(?:\/[a-z0-9]+)?)? safari\//], //  Safari， WebView
["webview", /\bcpu(?: iphone)? os (?:[0-9._]+).+\bapplewebkit\b/], ["firefox", /\bfirefox\/([0-9.ab]+)/], ["nokia", /\bnokiabrowser\/([0-9.]+)/]];
module.exports = {
  device: DEVICES,
  os: OS,
  browser: BROWSER,
  engine: ENGINE,
  re_msie: re_msie
};
return module.exports;
};

moduleFactories["node_modules/absol/src/Detector/BrowserDetector.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/Detector/BrowserDetector.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BrowserRules = _interopRequireDefault(require("./BrowserRules"));


/**
 *
 * @param {BrowserRules} rulesheet
 */
function BrowserDetector(rulesheet) {
  this.au = global.navigator ? navigator.userAgent || '' : '';
  this.rulesheet = rulesheet;
  this.os = this.detectByRules(this.rulesheet.os);
  this.device = this.detectByRules(this.rulesheet.device);
  this.engine = this.detectByRules(this.rulesheet.engine);
  this.browser = this.detectByRules(this.rulesheet.browser);
  this.isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
  this.isCococ = navigator.userAgent.toLowerCase().indexOf('coc_coc_browser') >= 1;
  this.isSafari = !this.isCococ && navigator.userAgent.toLowerCase().indexOf('safari') > -1 && navigator.userAgent.toLowerCase().indexOf('win') < 0 && navigator.userAgent.toLowerCase().indexOf('android') < 0; // this.isSafari = /constructor/i.test(window.HTMLElement) || window.safari;

  this.isMobile = navigator.userAgent.indexOf('KFFOWI') > -1 || navigator.userAgent.toLowerCase().indexOf('mobile') > -1;
  this.isMacOSWebView = /Macintosh/.test(this.au) && /AppWebkit/.test(this.au) && !/Safari/.test(this.au);
  this.isChromeIOS = /CriOS\/[\d]+/.test(this.au);
  this.hasTouch = 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0;
  this.isTouchDevice = this.isMobile && this.hasTouch;

  this.supportPassiveEvent = function () {
    var supportsPassiveOption = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function () {
          supportsPassiveOption = true;
        }
      });
      window.addEventListener('test', null, opts);
      window.removeEventListener('test', null, opts);
    } catch (e) {}

    return supportsPassiveOption;
  }();
}

BrowserDetector.prototype.detectByRules = function (rules) {
  var result = {};

  for (var i = 0; i < rules.length; ++i) {
    var rule = rules[i];
    var type = rule[0];
    var rgx = rule[1];

    if (typeof rgx == 'function') {
      rgx = rgx(this.au.toLowerCase());
    }

    if (Object.prototype.toString.call(rgx).indexOf('RegExp') >= 0) {
      var matched = this.au.toLowerCase().match(rgx);

      if (matched) {
        result.type = type;

        if (matched[1]) {
          result.version = matched[1];
        }

        break;
      }
    } else if (typeof rgx == 'string') {
      if (this.au.toLowerCase().indexOf(rgx) >= 0) {
        result.type = type;
      }
    }
  }

  return result;
};

var _default = new BrowserDetector(_BrowserRules.default);

exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/AElement.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/AElement.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventEmitter = _interopRequireDefault(require("./EventEmitter"));

var _BrowserDetector = _interopRequireDefault(require("../Detector/BrowserDetector"));

var _OOP = _interopRequireDefault(require("./OOP"));


/***
 * @augments Node
 * @augments ChildNode
 * @augments ParentNode
 * @augments Element
 * @augments HTMLElement
 * @augments EventEmitter
 * @augments ElementCSSInlineStyle
 * @constructor
 */
function AElement() {
  _EventEmitter.default.call(this);

  this._azar_extendAttributes = this._azar_extendAttributes || {};
  this._azar_extendTags = {};
  this.eventHandler = {};
}

_OOP.default.mixClass(AElement, _EventEmitter.default);

AElement.prototype.init = function (props) {
  Object.assign(this, props || {});
};

AElement.prototype.eventHandler = {};
/***
 * run super-class method
 */

AElement.prototype.super = function () {
  /* nope */
};
/**
 * @typedef {Object} AttributeDefiner
 * @property {Function} set
 * @property {Function} get
 * @property {Function} remove
 *
 * @param {String} key
 * @param {AttributeDefiner} def
 */


AElement.prototype.defineAttribute = function (key, def) {
  this._azar_extendAttributes[key] = def;
};

AElement.prototype.defineAttributes = function (defs) {
  for (var key in defs) {
    this.defineAttribute(key, defs[key]);
  }
};

AElement.prototype.attr = function () {
  if (arguments.length == 1) {
    if (typeof arguments[0] == 'string') {
      if (this._azar_extendAttributes[arguments[0]]) {
        return this._azar_extendAttributes[arguments[0]].get.call(this);
      } else return this.getAttribute(arguments[0]);
    } else {
      for (var key in arguments[0]) {
        this.attr(key, arguments[0][key]);
      }
    }
  } else {
    if (arguments.length == 2) {
      if (arguments[1] === null || arguments[1] === undefined) {
        if (this._azar_extendAttributes[arguments[0]]) {
          this._azar_extendAttributes[arguments[0]].remove.call(this, arguments[1]);
        } else this.removeAttribute(arguments[0]);
      } else {
        if (this._azar_extendAttributes[arguments[0]]) {
          this._azar_extendAttributes[arguments[0]].set.call(this, arguments[1]);
        } else {
          this.setAttribute(arguments[0], arguments[1]);
        }
      }
    }
  }

  return this;
};
/***
 * add style
 * @param {CSSStyleDeclaration|string|{}} arg0
 * @param {string} arg1
 * @returns {AElement}
 */

/**
 * add style
 * @param {CSSStyleDeclaration|string|{}} arg0
 * @returns {AElement}
 */


AElement.prototype.addStyle = function (arg0, arg1) {
  if (typeof arg0 == 'string') {
    if (arg0.indexOf('-') >= 0) {
      this.style.setProperty(arg0, arg1);
    } else {
      this.style[arg0] = arg1;
    }
  } else {
    for (var key in arg0) this.addStyle(key, arg0[key]);
  }
  return this;
};
/***
 *
 * @param {string|string[]|CSSStyleDeclaration} arg0
 * @returns {AElement}
 */


AElement.prototype.removeStyle = function (arg0) {
  var key;

  if (arg0.charAt) {
    if (arg0.indexOf('-') >= 0) {
      this.style.removeProperty(arg0);
    } else {
      this.style[arg0] = null;
      delete this.style[arg0];
    }
  } else {
    if (arg0.map && arg0.forEach) {
      for (var i = 0; i < arg0.length; ++i) this.removeStyle(arg0[i]);
    } else {
      for (key in arg0) this.removeStyle(key);
    }
  }

  return this;
};

AElement.prototype.addChild = function (child) {
  if (child.indexOf && child.map && child.forEach) {
    for (var i = 0; i < child.length; ++i) this.appendChild(child[i]);
  } else this.appendChild(child);

  return this;
};

AElement.prototype.addTo = function (parent) {
  if (parent && parent.appendChild) {
    if (parent.addChild) parent.addChild(this);else parent.appendChild(this);
  } else throw Error("Can not append to " + parent + "!");

  return this;
};

AElement.prototype.selfRemove = function () {
  if (this.parentElement) this.parentElement.removeChild(this);
  return this;
};

AElement.prototype.selfReplace = function (newNode) {
  if (this.parentElement) this.parentElement.replaceChild(newNode, this);
  return this;
};

AElement.prototype.clearChild = function () {
  while (this.firstChild) {
    this.removeChild(this.firstChild);
  }

  return this;
};
/**
 *
 * @param {string|Array} className
 * @returns {Boolean}
 */


AElement.prototype.containsClass = function (className) {
  if (className.forEach && className.map) {
    for (var i = 0; i < className.length; ++i) if (!this.classList.containsClass(className[i])) return false;

    return true;
  } else return this.classList.contains(className);
};
/**
 *
 * @param {string|Array} className
 * @returns {AElement}
 */


AElement.prototype.addClass = function (className) {
  if (className && className.forEach && className.map) {
    for (var i = 0; i < className.length; ++i) this.classList.add(className[i]);
  } else this.classList.add(className);

  return this;
};
/**
 *
 * @param {string|Array} className
 * @returns {AElement}
 */


AElement.prototype.removeClass = function (className) {
  if (className && className.forEach && className.map) {
    for (var i = 0; i < className.length; ++i) this.classList.remove(className[i]);
  } else this.classList.remove(className);

  return this;
};

AElement.prototype.getComputedStyleValue = function (key) {
  return window.getComputedStyle(this).getPropertyValue(key);
};

AElement.prototype.getFontSize = function () {
  return parseFloat(this.getComputedStyleValue('font-size').replace('px', ''));
};

AElement.prototype.findChildAfter = function (obj) {
  var r = 0;

  for (var i = 0; i < this.childNodes.length; ++i) {
    if (obj == this.childNodes[i]) {
      r = i + 1;
      break;
    }
  }

  if (this.childNodes[r]) return this.childNodes[r];
  return undefined;
};

AElement.prototype.findChildBefore = function (obj) {
  var r = 0;

  for (var i = 0; i < this.childNodes.length; ++i) {
    if (obj == this.childNodes[i]) {
      r = i - 1;
      break;
    }
  }

  if (this.childNodes[r]) return this.childNodes[r];
  return undefined;
};

AElement.prototype.addChildBefore = function (newItem, bf) {
  this.insertBefore(newItem, bf);
  return this;
};

AElement.prototype.addChildAfter = function (newItem, at) {
  var bf = this.findChildAfter(at);
  if (bf) return this.addChildBefore(newItem, bf);
  return this.addChild(newItem);
};
/**
 * @returns {DOMRect}
 */


AElement.prototype.getBoundingRecursiveRect = function (depth) {
  if (depth === undefined) depth = 10000;
  var current, next;
  var oo = 1000000;
  var ac = {
    left: oo,
    right: -oo,
    top: oo,
    bottom: -oo,
    width: 0,
    height: 0
  };
  var stacks = [{
    e: this,
    d: 0
  }];

  while (stacks.length > 0) {
    current = stacks.pop();

    if (current.e.getBoundingClientRect) {
      var cRect = current.e.getBoundingClientRect();
      if (!cRect || !(cRect.width || cRect.height || cRect.left || cRect.right)) continue;
      ac.left = Math.min(ac.left, cRect.left);
      ac.top = Math.min(ac.top, cRect.top);
      ac.bottom = Math.max(ac.bottom, cRect.bottom);
      ac.right = Math.max(ac.right, cRect.right);
      ac.height = ac.bottom - ac.top;
      ac.width = ac.right - ac.left;
      var childNodes = current.e.childNodes;

      if (childNodes && childNodes.length > 0 && current.d < depth) {
        for (var i = 0; i < childNodes.length; ++i) {
          next = {
            e: childNodes[i],
            d: current.d + 1
          };
          stacks.push(next);
        }
      }
    }
  }

  return ac;
};
/***
 *
 * @param parent
 * @returns {boolean}
 */


AElement.prototype.isDescendantOf = function (parent) {
  var child = this;

  while (child) {
    if (child === parent) return true;
    child = child.parentNode;
  }

  return false;
};
/*************************** **********************/


AElement.prototype.getCSSRules = function () {
  var sheets = document.styleSheets;
  var ret = [];
  this.matches = this.matches || this.webkitMatchesSelector || this.mozMatchesSelector || this.msMatchesSelector || this.oMatchesSelector;

  for (var i in sheets) {
    if (sheets[i].href) continue; //because can not access, you must clone link node instead

    var rules = sheets[i].rules || sheets[i].cssRules;

    for (var r in rules) {
      if (this.matches(rules[r].selectorText)) {
        ret.push(rules[r]);
      }
    }
  }

  return ret;
};
/***
 * @returns {Promise}
 */

/***
 * WARNING: this function may be unsafe
 */


AElement.prototype.afterDisplayed = function (requestTimesOut) {
  if (!requestTimesOut) requestTimesOut = 24 * 3600 * 33; // var tracer = new Error();

  var current = this;
  return new Promise(function (resolve, reject) {
    function trace() {
      if (requestTimesOut < 0) {// reject(tracer);
        // if (absol.BUILD && absol.BUILD.version == "DEBUG")
        //     console.warn("Element not displayed", trace);
      } else {
        requestTimesOut--;
        var bound = current.getBoundingClientRect();

        if (bound.width > 0 || bound.height > 0) {
          resolve();
        } else {
          setTimeout(trace, 33);
          return;
        }
      }
    }

    trace();
  });
};

!function () {
  var origin = AElement.prototype.on;

  if (_BrowserDetector.default.isSafari && !_BrowserDetector.default.isMobile) {
    AElement.prototype.on = function () {
      if (!this.isSupportedEvent('mouseleave') && arguments[0] == 'mouseleave') {
        this.defineEvent('mouseleave');

        var mouseLeaveEventHandler = function (event) {
          var bound = this.getBoundingClientRect();
          var ok = false;
          ok |= event.clientX < bound.left + 1;
          ok |= event.clientX >= bound.right - 1;
          ok |= event.clientY < bound.top + 1;
          ok |= event.clientY >= bound.bottom - 1;
          if (ok) this.emit('mouseleave', event);
        };

        this.addEventListener('mouseleave', mouseLeaveEventHandler, true);
      }

      origin.apply(this, arguments);
      return this;
    };
  }

  if (_BrowserDetector.default.isFirefox) {
    AElement.prototype.on = function () {
      if (!this.isSupportedEvent('wheel') && arguments[0] == 'wheel') {
        this.defineEvent('wheel');

        var wheelEventHandler = function (oldEvent) {
          //clone event to avoid some lib fix it
          var event = oldEvent.absolEvent;

          if (!event) {
            event = Object.assign({}, oldEvent);

            for (var i = 0; i < AElement.eventProperties.length; ++i) {
              var key = AElement.eventProperties[i];

              if (typeof event[key] == 'function') {
                event[key] = event[key].bind(oldEvent);
              }
            }

            event.preventDefault = function () {
              oldEvent.preventDefault();
            };

            if (!event.mozFixWheelScale) {
              event.mozDeltaY = oldEvent.deltaY;
              event.mozFixWheelScale = true;
              Object.defineProperty(event, 'deltaY', {
                get: function () {
                  return this.mozDeltaY * 100 / 3;
                }
              });
            }

            oldEvent.absolEvent = event;
          }

          this.emit('wheel', event);
        };

        this.addEventListener('wheel', wheelEventHandler);
      }

      origin.apply(this, arguments);
      return this;
    };
  }
}();
AElement.eventProperties = ["altKey", "bubbles", "button", "buttons", "cancelBubble", "cancelable", "clientX", "clientY", "composed", "ctrlKey", "currentTarget", "defaultPrevented", "deltaMode", "deltaX", "deltaY", "deltaZ", "detail", "eventPhase", "explicitOriginalTarget", "isTrusted", "layerX", "layerY", "metaKey", "movementX", "movementY", "mozInputSource", "mozPressure", "offsetX", "offsetY", "originalTarget", "pageX", "pageY", "rangeOffset", "rangeParent", "region", "relatedTarget", "returnValue", "screenX", "screenY", "shiftKey", "srcElement", "target", "timeStamp", "type", "deltaMode", "deltaX", "deltaY", "deltaZ"];
var _default = AElement;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/AElementNS.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/AElementNS.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _AElement = _interopRequireDefault(require("./AElement"));

var _OOP = _interopRequireDefault(require("./OOP"));


/***
 * @augments AElement
 * @augments SVGGraphicsElement
 * @constructor
 */
function AElementNS() {
  _AElement.default.call(this);
}

_AElement.default.prototype.afterAttached = function () {
  if (this.isDescendantOf(document.body)) return Promise.resolve();
  var attachHookElt = this.$attachhook || this.querySelector('.absol-attachhook');

  if (!attachHookElt) {
    var constructor;

    if (this.tagName.toLowerCase() === 'svg' || this.getBBox) {
      attachHookElt = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      attachHookElt.setAttributeNS(null, 'href', '');
      constructor = AElementNS;
    } else {
      attachHookElt = document.createElement('img');
      attachHookElt.src = '';
      constructor = AElementNS;
    }

    attachHookElt.classList.add('absol-attachhook');
    Object.assign(attachHookElt, constructor.prototype);
    constructor.call(attachHookElt);
    attachHookElt.defineEvent('attached');
    this.$attachhook = attachHookElt;
    this.$attachhook.on('error', function (event) {
      if (this.isDescendantOf(document.body)) this.emit('attached', event, this);
    });
    this.appendChild(attachHookElt);
  }

  return new Promise(function (rs) {
    attachHookElt.once('attached', rs);
  });
};

_OOP.default.mixClass(AElementNS, _AElement.default);

AElementNS.prototype.attr = function () {
  if (arguments.length == 1) {
    if (typeof arguments[0] == 'string') {
      if (this._azar_extendAttributes[arguments[0]]) {
        return this._azar_extendAttributes[arguments[0]].get.call(this);
      } else return this.getAttributeNS(null, arguments[0]);
    } else {
      for (var key in arguments[0]) {
        this.attr(key, arguments[0][key]);
      }
    }
  } else {
    if (arguments.length == 2) {
      if (arguments[1] === null || arguments[1] === undefined) {
        if (this._azar_extendAttributes[arguments[0]]) {
          this._azar_extendAttributes[arguments[0]].remove.call(this, arguments[1]);
        } else this.removeAttributeNS(null, arguments[0]);
      } else {
        if (this._azar_extendAttributes[arguments[0]]) {
          this._azar_extendAttributes[arguments[0]].set.call(this, arguments[1]);
        } else {
          this.setAttributeNS(null, arguments[0], arguments[1]);
        }
      }
    }
  }

  return this;
};

var _default = AElementNS;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/ResizeSystem.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/ResizeSystem.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _AElement = _interopRequireDefault(require("./AElement"));

var _AElementNS = _interopRequireDefault(require("./AElementNS"));


/**
 *
 * @constructor
 */
function ResizeSystem() {
  this.elts = [];
  this.cache = [];
  this.cacheOf = null;
  this.lastResizeTime = 0;
  window.addEventListener('resize', this.update.bind(this));
  this['goDown' + 'AndCache'] = this.goDownAndCache.bind(this);
  this['notify' + 'ToElt'] = this.notifyToElt.bind(this);
}
/***
 *
 * @param {AElement | AElementNS} elt
 */


ResizeSystem.prototype.goDownAndCache = function (elt) {
  if (this.notifyToElt(elt)) this.cache.push(elt);

  if (elt.childNodes) {
    Array.prototype.forEach.call(elt.childNodes, this.goDownAndCache);
  }
};

ResizeSystem.prototype.notifyToElt = function (elt) {
  if (typeof elt.requestUpdateSize == 'function') {
    elt.requestUpdateSize();
    return true;
  } else if (typeof elt.updateSize == 'function') {
    elt.updateSize();
    return true;
  } else if (typeof elt.onresize == 'function') {
    elt.onresize();
    return true;
  }
};

ResizeSystem.prototype.update = function () {
  var now = new Date().getTime();

  if (now - 100 > this.lastResizeTime) {
    this.removeTrash();
    this.cache = undefined;
  }

  this.lastResizeTime = now;

  if (this.cacheOf !== null) {
    this.cache = undefined;
    this.cacheOf = null;
  }

  if (this.cache === undefined) {
    this.cache = [];
    this.elts.forEach(this.goDownAndCache);
  } else {
    this.cache.forEach(this.notifyToElt);
  }
};

ResizeSystem.prototype.removeTrash = function () {
  this.elts = this.elts.filter(function (element) {
    return _AElement.default.prototype.isDescendantOf.call(element, document.body);
  });
};
/***
 *
 * @param  {AElement| AElementNS | Node} fromElt
 * @returns {boolean}
 */


ResizeSystem.prototype.updateUp = function (fromElt) {
  while (fromElt) {
    if (typeof fromElt.requestUpdateSize == 'function') {
      fromElt.requestUpdateSize();
      return true;
    } else if (typeof fromElt.updateSize == 'function') {
      fromElt.updateSize();
      return true;
    } else if (typeof fromElt.onresize == 'function') {
      fromElt.onresize();
      return true;
    }

    fromElt = fromElt.parentElement;
  }
};
/***
 *
 * @param  {AElement| AElementNS | Node} fromElt
 * @returns {boolean}
 */


ResizeSystem.prototype.updateDown = function (fromElt) {
  var now = new Date().getTime();

  if (now - 100 > this.lastResizeTime) {
    this.cache = undefined;
  }

  this.lastResizeTime = now;

  if (this.cacheOf !== fromElt) {
    this.cache = undefined;
    this.cacheOf = fromElt;
  }

  if (this.cache === undefined) {
    this.cache = [];
    this.goDownAndCache(fromElt);
  } else {
    this.cache.forEach(this.notifyToElt);
  }
};
/***
 *
 * @param {AElement| AElementNS | Node} elt
 * @return {boolean}
 */


ResizeSystem.prototype.add = function (elt) {
  for (var i = 0; i < this.elts.length; ++i) if (_AElement.default.prototype.isDescendantOf.call(elt, this.elts[i])) {
    return false;
  }

  this.elts = this.elts.filter(function (e) {
    return !_AElement.default.prototype.isDescendantOf.call(e, elt);
  });
  this.elts.push(elt);
  return true;
};

var _default = new ResizeSystem();

exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/JSPath.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/JSPath.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function JSPath(props) {
  this.path = props.path;
}
/**
 *
 * @param {Element} element
 * @returns {Boolean}
 */


JSPath.prototype.match = function (element, query) {
  if (query.id) {
    if (!element.getAttribute || element.getAttribute('id') != query.id) return false;
  }

  if (query.tagName) {
    var matchTag = false;
    if (element._azar_extendTags && element._azar_extendTags[query.tagName]) matchTag = true;
    matchTag = matchTag || (element.tagName || '').toUpperCase() == query.tagName.toUpperCase();
    if (!matchTag) return false;
  }

  if (query.classList) for (var i = 0; i < query.classList.length; ++i) {
    if (!element.classList || !element.classList.contains(query.classList[i])) return false;
  }

  if (query.attributes) {
    for (var key in query.attributes) {
      var value;

      if (element.attr) {
        value = element.attr(key);
        if (value != query.attributes[key]) return false;
      } else if (element.getAttribute) {
        value = element.getAttribute(key);
        if (value != query.attributes[key]) return false;
      }
    }
  }

  return true;
};
/**
 * Warning : still fail in some testcase
 */


JSPath.prototype.findFirst = function (root, onFound) {
  var queue = [{
    e: root,
    i: 0
  }];
  var current;

  while (queue.length > 0) {
    current = queue.shift();
    var isMathed = false;
    var currentElt = current.e;
    var currentI = current.i;

    if (this.match(currentElt, this.path[currentI])) {
      if (this.path[currentI].childCombinate) {
        var trackI = currentI;
        var trackElement = currentElt;
        var isTrackMatch = true;

        while (isTrackMatch && trackI > 0 && this.path[trackI].childCombinate) {
          if (!trackElement.parentNode || !this.match(trackElement.parentNode, this.path[trackI - 1])) {
            isTrackMatch = false;
          } else {
            trackElement = trackElement.parentNode;
            trackI--;
          }
        }

        if (isTrackMatch) isMathed = true;
      } else {
        isMathed = true;
      }
    }

    if (isMathed && currentI + 1 == this.path.length) {
      if (!onFound || onFound && onFound(currentElt)) return currentElt;
    }

    if (currentElt.childNodes) {
      var l = currentElt.childNodes.length;

      for (var i = 0; i < l; ++i) {
        if (currentElt.childNodes[i].tagName) queue.push({
          e: currentElt.childNodes[i],
          i: currentI + (isMathed && currentI + 1 < this.path.length ? 1 : 0)
        });
      }
    }
  }

  return undefined;
};

JSPath.prototype.findAll = function (root, onFound) {
  var res = [];
  var queue = [{
    e: root,
    i: 0
  }];
  var current;

  while (queue.length > 0) {
    current = queue.shift();
    var isMathed = false;
    var currentElt = current.e;
    var currentI = current.i;

    if (this.match(currentElt, this.path[currentI])) {
      if (this.path[currentI].childCombinate) {
        var trackI = currentI;
        var trackElement = currentElt;
        var isTrackMatch = true;

        while (isTrackMatch && trackI > 0 && this.path[trackI].childCombinate) {
          if (!trackElement.parentNode || !this.match(trackElement.parentNode, this.path[trackI - 1])) {
            isTrackMatch = false;
          } else {
            trackElement = trackElement.parentNode;
            trackI--;
          }
        }

        if (isTrackMatch) isMathed = true;
      } else {
        isMathed = true;
      }
    }

    if (isMathed && currentI + 1 == this.path.length) {
      if (!onFound || onFound && onFound(currentElt)) res.push(currentElt);
    }

    if (currentElt.childNodes) {
      var l = currentElt.childNodes.length;

      for (var i = 0; i < l; ++i) {
        if (currentElt.childNodes[i].tagName) queue.push({
          e: currentElt.childNodes[i],
          i: currentI + (isMathed && currentI + 1 < this.path.length ? 1 : 0)
        });
      }
    }
  }

  return res;
};

var identRegex = /[a-zA-Z0-9\-_]+/;
var stringRegex = /"(([^"\\]*|(\\.))*)"/;
var classRegex = new RegExp('\\.' + identRegex.source);
var idRegex = new RegExp('#' + identRegex.source);
var booleanRegex = /true|false/;
var valueRegex = new RegExp(stringRegex.source + '|' + booleanRegex.source);
var attributeRegex = new RegExp('\\[\\s*(' + identRegex.source + ')\\s*(=\\s*(' + valueRegex.source + '))\\]');
var queryRegex = new RegExp(['(', identRegex.source, '|', attributeRegex.source, '|', classRegex.source, '|', idRegex.source, ')+'].join(''));
JSPath.__tagRegex = new RegExp(queryRegex.source + '|\\>', 'g');
JSPath.__tagNameRegex = new RegExp('^' + identRegex.source, 'i');
JSPath.__classRegex = new RegExp(classRegex.source, 'g');
JSPath.__idRegex = new RegExp(idRegex.source, 'i');
JSPath.__attrRegex = new RegExp(attributeRegex.source, 'g');

JSPath.parseQuery = function (s) {
  var tag = {};
  s = s.replace(JSPath.__attrRegex, function (full, name, assign, jsonTextValue) {
    tag.attributes = tag.attributes || {};

    if (assign) {
      tag.attributes[name] = JSON.parse(jsonTextValue);
    } else tag.attributes[name] = true;

    return '';
  });
  var classList = s.match(this.__classRegex);
  var idList = s.match(this.__idRegex);
  var tagList = s.match(this.__tagNameRegex);

  if (idList && idList.length > 0) {
    tag.id = idList[0].substring(1);
  }

  if (tagList && tagList.length > 0) {
    tag.tagName = tagList[0].trim();
  }

  if (classList && classList.length > 0) {
    tag.classList = classList.map(function (s) {
      return s.substring(1);
    });
  }

  return tag;
};
/**
 * @param {String} text
 * @returns {JSPath}
 */


JSPath.compileJSPath = function (text) {
  var tagTexts = text.match(this.__tagRegex) || [''];
  var path = [];
  var childCombinate = false;

  for (var i = 0; i < tagTexts.length; ++i) {
    var s = tagTexts[i];

    if (s == '>') {
      childCombinate = true;
    } else {
      var tag = this.parseQuery(s);
      tag.childCombinate = childCombinate;
      path.push(tag);
      childCombinate = false;
    }
  }

  return new JSPath({
    path: path
  });
};

var _default = JSPath;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/ElementNS.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/ElementNS.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _AElementNS = _interopRequireDefault(require("./AElementNS"));


var _default = _AElementNS.default;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/Dom.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/Dom.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDomNode = isDomNode;
exports.activeFullScreen = activeFullScreen;
exports.deactiveFullScreen = deactiveFullScreen;
exports.isFullScreen = isFullScreen;
exports.traceOutBoundingClientRect = traceOutBoundingClientRect;
exports.fontFaceIsLoaded = fontFaceIsLoaded;
exports.getScreenSize = getScreenSize;
exports.waitImageLoaded = waitImageLoaded;
exports.waitIFrameLoaded = waitIFrameLoaded;
exports.imageToCanvas = imageToCanvas;
exports.getScrollSize = getScrollSize;
exports.depthClone = depthClone;
exports.depthCloneWithStyle = depthCloneWithStyle;
exports.copyStyleRule = copyStyleRule;
exports.getConstructDescriptor = getConstructDescriptor;
exports.default = exports.FeatureClass = void 0;

var _JSPath = _interopRequireDefault(require("./JSPath"));

var _OOP = _interopRequireDefault(require("./OOP"));

var _getFunctionName = _interopRequireDefault(require("../String/getFunctionName"));

var _ElementNS = _interopRequireDefault(require("./ElementNS"));

var _AElement = _interopRequireDefault(require("./AElement"));

var _ResizeSystem = _interopRequireDefault(require("./ResizeSystem"));

var _attribute = require("../JSX/attribute");


/***
 * @typedef {{"accept-charset":string, "http-equiv": string, accept : string, accesskey : string, action : string, align : string, allow : string, alt : string, async : string, autocapitalize : string, autocomplete : string, autofocus : string, autoplay : string, background : string, bgcolor : string, border : string, buffered : string, capture : string, challenge : string, charset : string, checked : string, cite : string, class : string, code : string, codebase : string, color : string, cols : string, colspan : string, content : string, contenteditable : string, contextmenu : string, controls : string, coords : string, crossorigin : string, csp : string, data : string, "data-*" : string, datetime : string, decoding : string, default : string, defer : string, dir : string, dirname : string, disabled : string, download : string, draggable : string, dropzone : string, enctype : string, enterkeyhint : string, for : string,     form : string, formaction : string, formenctype : string, formmethod : string, formnovalidate : string, formtarget : string, headers : string, height : string, hidden : string, high : string, href : string, hreflang : string, icon : string, id : string, importance : string, integrity : string, intrinsicsize : string, inputmode : string, ismap : string, itemprop : string, keytype : string, kind : string, label : string, lang : string, language : string, loading : string, list : string, loop : string, low : string, manifest : string, max : string, maxlength : string, minlength : string, media : string, method : string, min : string, multiple : string, muted : string, name : string, novalidate : string, open : string, optimum : string, pattern : string, ping : string, placeholder : string, poster : string, preload : string, radiogroup : string, readonly : string, referrerpolicy : string, rel : string, required : string, reversed : string, rows : string, rowspan : string, sandbox : string, scope : string, scoped : string, selected : string, shape : string, size : string, sizes : string, slot : string, span : string, spellcheck : string, src : string, srcdoc : string, srclang : string, srcset : string, start : string, step : string, style : string, summary : string, tabindex : string, target : string, title : string, translate : string, type : string, usemap : string, value : string, width : string, wrap : string, }} AElementAttributeDescriptor
 */

/**
 * @typedef {{"arabic-form":string,"baseline-shift": string, "accent-height": string,  "alignment-baseline": string,  "cap-height": string,  "clip-path": string,  "clip-rule": string,  "color-dinterpolation": string,  "color-interpolation-filters": string,  "color-profile": string,  "color-rendering": string,  "dominant-baseline": string,  "enable-background": string,  "fill-opacity": string,  "fill-rule": string,  "flood-color": string,  "flood-opacity": string,  "font-family": string,  "font-size": string,  "font-size-adjust": string,  "font-stretch": string,  "font-style": string,  "font-variant": string,  "font-weight": string,  "glyph-name": string,  "glyph-orientation-horizontal": string,  "glyph-orientation-vertical": string,  "horiz-adv-x": string,  "horiz-origin-x": string,  "image-rendering": string,  "letter-spacing": string,  "lighting-color": string,  "marker-end": string,  "marker-mid": string,  "marker-start": string,  "overline-position": string,  "overline-thickness": string,  "panose-1": string,  "paint-order": string,  "pointer-events": string,  "rendering-intent": string,  "shape-rendering": string,  "stop-color": string,  "stop-opacity": string,  "strikethrough-position": string,  "strikethrough-thickness": string,  "stroke-dasharray": string,  "stroke-dashoffset": string,  "stroke-linecap": string,  "stroke-linejoin": string,  "stroke-miterlimit": string,  "stroke-opacity": string,  "stroke-width": string,  "text-anchor": string,  "text-decoration": string,  "text-rendering": string,  "transform-origin": string,  "underline-position": string,  "underline-thickness": string,  "unicode-bidi": string,  "unicode-range": string,  "units-per-em": string,  "v-alphabetic": string,  "v-hanging": string,  "v-ideographic": string,  "v-mathematical": string,  "vector-effect": string,  "vert-adv-y": string,  "vert-origin-x": string,  "vert-origin-y": string,  "word-spacing": string,  "writing-mode": string,  "x-height": string,  "xlink:actuate": string,  "xlink:arcrole": string,  "xlink:href": string,  "xlink:role": string,  "xlink:show": string,  "xlink:title": string,  "xlink:type": string,  "xml:base": string,  "xml:lang": string,  "xml:space": string, accumulate:string, additive:string, allowReorder:string, alphabetic:string, amplitude:string, ascent:string, attributeName:string, attributeType:string, autoReverse:string, azimuth:string, baseFrequency:string, baseProfile:string, bbox:string, begin:string, bias:string, by:string, calcMode:string, class:string, clip:string, clipPathUnits:string, color:string, contentScriptType:string, contentStyleType:string, cursor:string, cx:string, cy:string, d:string, decelerate:string, descent:string, diffuseConstant:string, direction:string, display:string, divisor:string, dur:string, dx:string, dy:string, edgeMode:string, elevation:string, end:string, exponent:string, externalResourcesRequired:string, fill:NamedColor|Color|string, filter:string, filterRes:string, filterUnits:string, format:string, from:string, fr:string, fx:string, fy:string, g1:string, g2:string, glyphRef:string, gradientTransform:string, gradientUnits:string, hanging:string, height:string, href:string, hreflang:string, id:string, ideographic:string, in:string, in2:string, intercept:string, k:string, k1:string, k2:string, k3:string, k4:string, kernelMatrix:string, kernelUnitLength:string, kerning:string, keyPoints:string, keySplines:string, keyTimes:string, lang:string, lengthAdjust:string, limitingConeAngle:string, local:string, markerHeight:string, markerUnits:string, markerWidth:string, mask:string, maskContentUnits:string, maskUnits:string, mathematical:string, max:string, media:string, method:string, min:string, mode:string, name:string, numOctaves:string, offset:string, opacity:string, operator:string, order:string, orient:string, orientation:string, origin:string, overflow:string, path:string, pathLength:string, patternContentUnits:string, patternTransform:string, patternUnits:string, ping:string, points:string, pointsAtX:string, pointsAtY:string, pointsAtZ:string, preserveAlpha:string, preserveAspectRatio:string, primitiveUnits:string, r:string, radius:string, referrerPolicy:string, refX:string, refY:string, rel:string, repeatCount:string, repeatDur:string, requiredExtensions:string, requiredFeatures:string, restart:string, result:string, rotate:string, rx:string, ry:string, scale:string, seed:string, slope:string, spacing:string, specularConstant:string, specularExponent:string, speed:string, spreadMethod:string, startOffset:string, stdDeviation:string, stemh:string, stemv:string, stitchTiles:string, string:string, stroke:string, style:string, surfaceScale:string, systemLanguage:string, tabindex:string, tableValues:string, target:string, targetX:string, targetY:string, textLength:string, to:string, transform:string, type:string, u1:string, u2:string, unicode:string, values:string, version:string, viewBox:string, viewTarget:string, visibility:string, width:string, widths:string, x:string, x1:string, x2:string, xChannelSelector:string, y:string, y1:string, y2:string, yChannelSelector:string, z:string, zoomAndPan:string, }}  AElementNSAttributeDescriptor
 */

/***
 * @typedef {{abort:function(event:(UiEvent|Event)):void,afterprint:function(event:Event):void,animationend:function(event:AnimationEvent):void,animationiteration:function(event:AnimationEvent):void,animationstart:function(event:AnimationEvent):void,beforeprint:function(event:Event):void,beforeunload:function(event:(UiEvent|Event)):void,blur:function(event:FocusEvent):void,canplay:function(event:Event):void,canplaythrough:function(event:Event):void,change:function(event:Event):void,click:function(event:MouseEvent):void,contextmenu:function(event:MouseEvent):void,copy:function(event:ClipboardEvent):void,cut:function(event:ClipboardEvent):void,dblclick:function(event:MouseEvent):void,drag:function(event:DragEvent):void,dragend:function(event:DragEvent):void,dragenter:function(event:DragEvent):void,dragleave:function(event:DragEvent):void,dragover:function(event:DragEvent):void,dragstart:function(event:DragEvent):void,drop:function(event:DragEvent):void,durationchange:function(event:Event):void,ended:function(event:Event):void,error:function(event:(ProgressEvent|UiEvent|Event)):void,focus:function(event:FocusEvent):void,focusin:function(event:FocusEvent):void,focusout:function(event:FocusEvent):void,fullscreenchange:function(event:Event):void,fullscreenerror:function(event:Event):void,hashchange:function(event:HashChangeEvent):void,input:function(event:(InputEvent|Event)):void,invalid:function(event:Event):void,keydown:function(event:KeyboardEvent):void,keypress:function(event:KeyboardEvent):void,keyup:function(event:KeyboardEvent):void,load:function(event:(UiEvent|Event)):void,loadeddata:function(event:Event):void,loadedmetadata:function(event:Event):void,loadstart:function(event:ProgressEvent):void,message:function(event:Event):void,mousedown:function(event:MouseEvent):void,mouseenter:function(event:MouseEvent):void,mouseleave:function(event:MouseEvent):void,mousemove:function(event:MouseEvent):void,mouseover:function(event:MouseEvent):void,mouseout:function(event:MouseEvent):void,mouseup:function(event:MouseEvent):void,mousewheel:function(event:WheelEvent):void,offline:function(event:Event):void,online:function(event:Event):void,open:function(event:Event):void,pagehide:function(event:PageTransitionEvent):void,pageshow:function(event:PageTransitionEvent):void,paste:function(event:ClipboardEvent):void,pause:function(event:Event):void,play:function(event:Event):void,playing:function(event:Event):void,popstate:function(event:PopStateEvent):void,progress:function(event:Event):void,ratechange:function(event:Event):void,resize:function(event:(UiEvent|Event)):void,reset:function(event:Event):void,scroll:function(event:(UiEvent|Event)):void,search:function(event:Event):void,seeked:function(event:Event):void,seeking:function(event:Event):void,select:function(event:(UiEvent|Event)):void,show:function(event:Event):void,stalled:function(event:Event):void,storage:function(event:StorageEvent):void,submit:function(event:Event):void,suspend:function(event:Event):void,timeupdate:function(event:Event):void,toggle:function(event:Event):void,touchcancel:function(event:TouchEvent):void,touchend:function(event:TouchEvent):void,touchmove:function(event:TouchEvent):void,touchstart:function(event:TouchEvent):void,transitionend:function(event:TransitionEvent):void,unload:function(event:(UiEvent|Event)):void,volumechange:function(event:Event):void,waiting:function(event:Event):void,wheel:function(event:WheelEvent):void}} AElementEventDescriptor
 */

/***
 * @typedef AbsolConstructDescriptor
 * @property {string | function |null} tag
 * @property {CSSStyleDeclaration} style
 * @property {Array | string} extendEvent
 * @property {Array | string} class
 * @property {AElementAttributeDescriptor|AElementNSAttributeDescriptor} attr
 * @property {string|AElement | AElementNS | AbsolConstructDescriptor | string[] |AElement[] | AElementNS[] | AbsolConstructDescriptor[]} child
 * @property {string} text to create a TextNode, not Element
 * @property {AElement} elt
 * @property {AElementEventDescriptor|{}} on
 * @property {Object} props
 *
 */

/****
 *
 * @returns {AElement}
 */
var attachhookCreator = function () {
  var res = Dom.ShareInstance._({
    tag: 'img',
    class: 'absol-attachhook',
    extendEvent: ['attached'],
    style: {
      display: 'none'
    },
    attr: {
      src: ''
    },
    on: {
      error: function (event) {
        if (!this._attached && this.isDescendantOf(document.body)) {
          this._attached = true;
          this.emit('attached', event, this);
        }
      }
    }
  });

  res._attached = false;
  Object.defineProperty(res, 'attached', {
    get: function () {
      return this._attached;
    }
  });

  res.resetState = function () {
    this._attached = false;
    this.src = '';
  };

  return res;
};

var svgCreator = function () {
  var temp = document.createElement('div');
  temp.innerHTML = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"></svg>';
  var element = temp.childNodes[0];
  var prototypes = Object.getOwnPropertyDescriptors(_AElement.default.prototype);
  Object.defineProperties(element, prototypes);

  _AElement.default.call(element);

  return element;
};
/***
 *
 * @param {*=} option
 * @constructor
 */


function Dom(option) {
  this.defaultTag = 'div';
  option = option || {};
  this.creator = option.creator || {};
  Object.defineProperties(this.creator, {
    svg: {
      set: function () {//do nothing
      },
      get: function () {
        return svgCreator;
      }
    },
    attachhook: {
      set: function () {//do nothing
      },
      get: function () {
        return attachhookCreator;
      }
    }
  });
  this['$ '.trim()] = this.$.bind(this);
  this['_ '.trim()] = this._.bind(this);
  this['$' + '$'] = this.$$.bind(this);
  this.buildDom = this._;
}

Dom.prototype.fromCode = function (code) {
  code = code.trim().replace(/>\s+</gm, '><');
  var temTag = 'div';
  if (code.startsWith('<td') || code.startsWith('<th') && !code.startsWith('<thead')) temTag = 'tr';else if (code.startsWith('<tr')) temTag = 'tbody';else if (code.startsWith('<thead') || code.startsWith('<tbody')) temTag = 'table';
  var tempDiv = document.createElement(temTag);
  tempDiv.innerHTML = code;
  var element = tempDiv.childNodes[0];
  var prototypes = Object.getOwnPropertyDescriptors(_AElement.default.prototype);
  Object.defineProperties(element, prototypes);

  _AElement.default.call(element);

  return element;
};
/**
 * DFS
 * @param {string | AElement} query
 * @param {AElement} root
 * @param {function} onFound - return true to stop find
 * @returns {AElement | AElementNS}
 */


Dom.prototype.$ = function (query, root, onFound) {
  var res;
  if (Dom.isDomNode(query)) res = query;else res = this.select(query, root, onFound);
  if (res) this.attach(res);
  return res;
};
/***
 *
 * @type {function(string, AElement, Function): AElement}
 */


Dom.prototype.selectAttacth = Dom.prototype.$;
/**
 * DFS
 * @param {string} query
 * @param {AElement} root
 * @param {function} onFound - return true to stop find
 */

Dom.prototype.select = function (query, root, onFound) {
  root = root || document.documentElement;

  var matcher = _JSPath.default.compileJSPath(query);

  return matcher.findFirst(root, onFound);
};

var FeatureClass = {
  AElementNS: {
    constructor: _ElementNS.default,
    prototypeKeys: Object.keys(_ElementNS.default.prototype)
  },
  AElement: {
    constructor: _AElement.default,
    prototypeKeys: Object.keys(_AElement.default.prototype)
  }
};
/**
 *
 * @param {AElement | AElementNS } element
 */

exports.FeatureClass = FeatureClass;

Dom.prototype.attach = function (element) {
  if (element.attr) return;
  var feature = element.getBBox && element.tagName !== 'svg' ? FeatureClass.AElementNS : FeatureClass.AElement;
  var elementConstructor = feature.constructor;
  var proto = elementConstructor.prototype;
  var prototypeKeys = feature.prototypeKeys;
  var n = prototypeKeys.length;
  var key;

  for (var i = 0; i < n; ++i) {
    key = prototypeKeys[i];
    element[key] = proto[key];
  }

  Object.assign(element, elementConstructor.prototype);
  elementConstructor.call(element);
};

Dom.prototype.makeNewElement = function (tagName) {
  return document.createElement(tagName);
};

Dom.prototype.makeNewTextNode = function (data) {
  return document.createTextNode(data);
};
/**
 *
 * @param {AbsolConstructDescriptor | string | {} } option
 * @returns {AElementNS| AElement | Text}
 */


Dom.prototype._ = function (option, isInherited) {
  var res;
  var creator;

  if (Dom.isDomNode(option)) {
    res = option;
    option = {};
    /** fix reinit component */

    isInherited = true;
  } else {
    if (option.charAt) {
      option = option.trim();

      if (option[0] == '<') {
        res = this.fromCode(option);
        option = {};
      } else {
        var queryObj = _JSPath.default.parseQuery(option);

        option = {};
        option.tag = queryObj.tagName || this.defaultTag;
        if (queryObj.classList && queryObj.classList.length > 0) option.class = queryObj.classList;
        if (queryObj.id) option.id = queryObj.id;
        if (queryObj.attributes) option.attr = queryObj.attributes;
      }
    }
  }

  if (option.text || option.text === '') {
    //is textNode
    return this.makeNewTextNode(option.text);
  }

  option.tag = option.tag || this.defaultTag;
  creator = option.tag.prototype ? option.tag : this.creator[option.tag];
  if (option.tag.prototype) option.tag = option.tag.tag;

  if (option.elt) {
    res = option.elt;
  } else {
    if (!res) {
      if (creator) {
        if (creator.render) {
          res = creator.render(option.data);
        } else {
          res = creator(option.data);
        }
      } else {
        res = this.makeNewElement(option.tag);
        Object.assign(res, option.data);
      }
    }
  }

  this.attach(res);

  if (creator) {
    res._azar_extendTags = res._azar_extendTags || {};
    res._azar_extendTags[option.tag] = creator;
    creator.property && Object.defineProperties(res, creator.property);
    creator.prototype && _OOP.default.extends(res, creator.prototype);
    creator.attribute && res.defineAttributes(creator.attribute);

    if (creator.render) {
      if (creator.eventHandler) {
        res.eventHandler = res.eventHandler || {};

        var eventHandler = _OOP.default.bindFunctions(res, creator.eventHandler || creator.prototype.eventHandler);

        for (var eventHandlerKey in eventHandler) {
          if (res.eventHandler[eventHandlerKey]) {
            throw new Error("Same name of eventHandler[" + eventHandlerKey + "]");
          } else {
            res.eventHandler[eventHandlerKey] = eventHandler[eventHandlerKey];
          }
        }
      }

      creator.call(res);
    }
  }

  option.extendEvent && res.defineEvent(option.extendEvent);
  option.attr && res.attr(option.attr);
  option.on && res.on(option.on);
  option.once && res.once(option.once);
  option.class && res.addClass(option.class);
  option.style && res.addStyle(option.style);
  option.id && res.attr('id', option.id);
  if (!isInherited) res.init(option.props);

  if (option.child) {
    option.child = option.child instanceof Array ? option.child : [option.child];

    for (var i = 0; i < option.child.length; ++i) {
      res.addChild(this._(option.child[i], false, true));
    }
  }

  return res;
};
/***
 *
 * @type {function(Object, boolean): AElement}
 */


Dom.prototype.create = Dom.prototype._;
/***
 *
 * @param query
 * @param root
 * @returns {Array<AElement|AElementNS>}
 */

Dom.prototype.$$ = function (query, root) {
  var thisD = this;
  var res = [];
  this.selectAttacth(query, root, function (elt) {
    thisD.attach(elt);
    res.push(elt);
  });
  return res;
};

Dom.prototype.install = function (arg0, arg1) {
  var _this = this;

  if (arguments.length == 1) {
    if (arg0.creator && arg0.create && arg0.select) {
      // is a dom core
      var creator = arg0.creator;
      Object.keys(creator).forEach(function (key) {
        if (key.startsWith('_') || key.startsWith('$')) return;
        var func = creator[key];
        if (typeof func == 'function') if (_this.creator[key] != func) _this.creator[key] = func;
      });
    } else if (typeof arg0 == 'function') {
      var name = arg0.tag || (0, _getFunctionName.default)(arg0) || arg0.name;

      if (name) {
        this.creator[name.toLowerCase()] = arg0;
      } else {
        console.error('No ident name of creator function', arg0);
      }
    } else if (arg0 instanceof Array) {
      arg0.forEach(function (func) {
        var name = func.tag || (0, _getFunctionName.default)(func) || func.name;

        if (name) {
          _this.creator[name.toLowerCase()] = func;
        }
      });
    } else if (typeof arg0 == 'object') {
      Object.keys(arg0).forEach(function (key) {
        if (key.startsWith('_') || key.startsWith('$')) return;
        var func = arg0[key];
        if (typeof func == 'function') if (_this.creator[key] != func) _this.creator[key] = func;
      });
    } else {
      console.error('Unknown data', arg0);
    }
  } else if (arguments.length == 2) {
    if (arg0 instanceof Array) {
      if (arg1.creator) arg1 = arg1.creator;
      arg0.forEach(function (key) {
        var func = arg1[key];
        if (typeof func == 'function') if (_this.creator[key] != func) _this.creator[key] = func;
      });
    } else if (arg0 instanceof RegExp) {
      if (arg1.creator) arg1 = arg1.creator;
      Object.keys(arg1).forEach(function (key) {
        if (key.match(arg0)) {
          var func = arg1[key];
          if (typeof func == 'function') if (_this.creator[key] != func) _this.creator[key] = func;
        }
      });
    } else if (typeof arg0 == 'string' && arg0.length > 0) {
      if (typeof arg1 == 'function') {
        this.creator[arg0] = arg1;
      } else {
        console.error('arg1 is not a function');
      }
    }
  } else {
    console.error('Invalid param');
  }

  return this;
};
/***
 *
 * @param {String | null} tagName
 */


Dom.prototype.require = function (tagName) {
  return this.creator[tagName] || null;
};
/**
 *
 * @param {*} o
 * @returns {Boolean}
 */


function isDomNode(o) {
  return typeof Node === "object" ? o instanceof Node : o && typeof o === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string";
}

Dom.isDomNode = isDomNode;
/**
 * @param {AElement|Node|HTMLElement} element
 */

function activeFullScreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen(_AElement.default.ALLOW_KEYBOARD_INPUT);
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  }
}

Dom.activeFullScreen = activeFullScreen;

function deactiveFullScreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  }
}

Dom.deactiveFullScreen = deactiveFullScreen;

function isFullScreen() {
  var fullScreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
  return !!fullScreenElement;
}

Dom.isFullScreen = isFullScreen;
/**
 * @param {AElement|Node|HTMLElement} current
 * @returns {ClientRect}
 */

function traceOutBoundingClientRect(current) {
  var screenSize = Dom.getScreenSize();
  var left = 0;
  var right = screenSize.width;
  var top = 0;
  var bottom = screenSize.height;

  while (current) {
    var ox = _AElement.default.prototype.getComputedStyleValue.call(current, 'overflow-x') !== "visible";
    var oy = _AElement.default.prototype.getComputedStyleValue.call(current, 'overflow-y') !== "visible";
    var isHtml = current.tagName.toLowerCase() === 'html';

    if (ox || oy || isHtml) {
      var bound = current.getBoundingClientRect();

      if (ox || isHtml) {
        left = Math.max(left, bound.left);
        right = Math.min(right, bound.right);
      }

      if (oy || isHtml) {
        top = Math.max(top, bound.top);
        bottom = Math.min(bottom, bound.bottom);
      }
    }

    if (isHtml) break;
    current = current.parentElement;
  }

  return {
    left: left,
    right: right,
    top: top,
    bottom: bottom,
    width: right - left,
    height: bottom - top
  };
}

Dom.traceOutBoundingClientRect = traceOutBoundingClientRect;
/***
 *
 * @param {string} fontFace
 * @param {number} timeout
 * @returns {Promise<boolean>}
 */

function fontFaceIsLoaded(fontFace, timeout) {
  timeout = timeout || 0;

  var element = this.ShareInstance._({
    tag: 'span',
    style: {
      visibility: 'hidden',
      position: 'fixed',
      top: '-9999px',
      left: '-9999px',
      'font-size': '256px'
    },
    props: {
      innerHTML: "Test string long long long"
    }
  });

  element.addTo(document.body);
  return element.afterAttached().then(function () {
    var lastOffsetWidth = element.getBoundingClientRect().width;
    element.addStyle('font-family', fontFace);
    return new Promise(function (resolve, reject) {
      function check(remainTime) {
        if (remainTime < 0) {
          resolve(false);
          element.selfRemove();
        } else requestAnimationFrame(function () {
          var currentOffsetWidth = element.getBoundingClientRect().width;

          if (currentOffsetWidth != lastOffsetWidth) {
            resolve(true);
            element.selfRemove();
          } else check(remainTime - 10);
        });
      }

      check(timeout);
    });
  });
}

Dom.fontFaceIsLoaded = fontFaceIsLoaded;
/***
 *
 * @returns {{width: number, WIDTH: number, HEIGHT: number, height: number}}
 */

function getScreenSize() {
  var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
  var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
  return {
    WIDTH: width,
    HEIGHT: height,
    width: width,
    height: height
  };
}

Dom.getScreenSize = getScreenSize;
/***
 *
 * @param {HTMLImageElement} img
 * @param {number=} timeout
 * @returns {Promise<void>}
 */

function waitImageLoaded(img, timeout) {
  var isLoaded = true;

  if (!img.complete) {
    isLoaded = false;
  }

  if (img.naturalWidth === 0) {
    isLoaded = false;
  }

  if (isLoaded) return Promise.resolve();
  return new Promise(function (rs) {
    if (img.addEventListener) {
      img.addEventListener('load', rs, false);
    } else {
      img.attachEvent('onload', rs, false);
    }

    setTimeout(rs, timeout || 5000);
  }); // No other way of checking: assume it’s ok.
}

Dom.waitImageLoaded = waitImageLoaded;
/***
 *
 * @param {HTMLIFrameElement| Worker} iframe
 * @returns {Promise}
 */

function waitIFrameLoaded(iframe) {
  return new Promise(function (rs, rj) {
    if (document.all) {
      iframe.onreadystatechange = function () {
        if (iframe.readyState === "complete" || iframe.readyState === "loaded") rs();
      };
    } else {
      iframe.onload = rs;
    }

    setTimeout(rs, 5000);
  });
}

Dom.waitIFrameLoaded = waitIFrameLoaded;
/***
 *
 * @param {Image} element
 * @returns {Promise<HTMLCanvasElement>}
 */

function imageToCanvas(element) {
  if (typeof element == 'string') {
    element = Dom.ShareInstance.$(element);
  }

  if (element.tagName.toLowerCase() === 'img') {
    var preRender = Dom.ShareInstance._('div');

    preRender.addStyle({
      position: 'fixed',
      top: '0',
      left: '0',
      zIndex: '-10000',
      opacity: '0'
    }).addTo(document.body);
    var canvas = document.createElement("canvas");
    preRender.addChild(canvas);
    return Dom.waitImageLoaded(element).then(function () {
      canvas.width = element.width;
      canvas.height = element.height;
      var context = canvas.getContext("2d");
      context.drawImage(element, 0, 0);
      preRender.selfRemove();
      return canvas;
    });
  } else {
    throw new Error("AElement must be image");
  }
}

Dom.imageToCanvas = imageToCanvas;
Dom.ShareInstance = new Dom();
Dom.scrollWidthPromise;
Dom.documentReady = new Promise(function (resolve) {
  if (document.body) {
    resolve();
  } else {
    window.addEventListener("load", resolve);
  }
});

function getScrollSize() {
  if (!Dom.scrollWidthPromise) Dom.scrollWidthPromise = new Promise(function (resolve) {
    function prerender() {
      var parent = Dom.ShareInstance._({
        style: {
          'z-index': '-100',
          opacity: '0',
          width: '100px',
          height: '100px',
          overflow: 'scroll',
          top: '0',
          left: '0',
          'box-sizing': 'content-box',
          position: 'fixed'
        }
      }).addTo(document.body);

      var child = Dom.ShareInstance._({
        style: {
          width: '100%',
          height: '100%'
        }
      }).addTo(parent);

      requestAnimationFrame(function () {
        var parentBound = parent.getBoundingClientRect();
        var childBound = child.getBoundingClientRect();
        resolve({
          width: parentBound.width - childBound.width,
          height: parentBound.height - childBound.height
        });
        parent.selfRemove();
      });
    }

    Dom.documentReady.then(prerender);
  });
  return Dom.scrollWidthPromise;
}

Dom.getScrollSize = getScrollSize;
/***
 *
 * @param {(AElement|AElementNS|Node)} originElt
 * @param {function(originElt: (AElement|AElementNS|Node), originElt: (AElement|AElementNS|Node)):void } afterCloneCb
 * @return {AElement|AElementNS|Node}
 */

function depthClone(originElt, afterCloneCb) {
  /***
   *
   * @type {AElement|AElementNS|Node}
   */
  var newElt = originElt.cloneNode(); //no deep

  if (originElt.childNodes) {
    /***
     *
     * @type {(AElement|AElementNS)[]}
     */
    var children = Array.prototype.map.call(originElt.childNodes, function (child) {
      return depthClone(child, afterCloneCb);
    });

    for (var i = 0; i < children.length; ++i) {
      newElt.appendChild(children[i]);
    }
  }

  return afterCloneCb && afterCloneCb(originElt, newElt) || newElt;
}
/***
 *
 * @param originElt
 * @returns {AElement|HTMLElement|Node}
 */


function depthCloneWithStyle(originElt, afterCloneCb) {
  return depthClone(originElt, function (originElt, newElt) {
    if (!originElt.getAttribute && !originElt.getAttributeNS) return;
    copyStyleRule(originElt, newElt);
    afterCloneCb && afterCloneCb(originElt, newElt);
  });
}

Dom.depthClone = depthClone;
Dom.depthCloneWithStyle = depthCloneWithStyle;
/***
 *
 * @param  {AElement|HTMLElement|Node}sourceElt
 * @param  {AElement|HTMLElement|Node} destElt
 * @returns  {AElement|HTMLElement|Node}
 */

function copyStyleRule(sourceElt, destElt) {
  if (!sourceElt.getAttribute && !sourceElt.getAttributeNS) return destElt; //is text node

  if (!destElt.getAttribute && !destElt.getAttributeNS) return destElt; //is text node, nothing to copy

  var cssRules = _AElement.default.prototype.getCSSRules.call(sourceElt);

  var cssKey = cssRules.reduce(function (ac, rule) {
    for (var i = 0; i < rule.style.length; ++i) {
      ac[rule.style[i]] = true;
    }

    return ac;
  }, {});

  for (var key in cssKey) {
    destElt.style[key] = _AElement.default.prototype.getComputedStyleValue.call(sourceElt, key);
  }

  return destElt;
}

Dom.copyStyleRule = copyStyleRule;
/***
 * get absol construct descriptor for HTML element only
 * @param {AElement | Text} elt
 * @returns {AbsolConstructDescriptor}
 */

function getConstructDescriptor(elt) {
  var obj = {};
  obj.tag = elt.tagName.toLowerCase();
  var classAttr = elt.getAttribute('class');
  var classList;
  if (classAttr) classList = (0, _attribute.parseClassAttr)(classAttr);
  if (classList && classList.length > 0) obj.class = classList;
  var styleAttr = elt.getAttribute('style');
  var style;
  if (styleAttr) style = (0, _attribute.parseStyleAttr)(styleAttr);
  var attributes = elt.attributes;
  var attNode;
  var attrName;
  var attrValue;
  var attr = {};
  var on = {};
  var props = {};
  var eventMatch, eventName;
  var propMatch, propName;

  for (var i = 0; i < attributes.length; ++i) {
    attNode = attributes[i];
    attrName = attNode.nodeName;
    attrValue = attNode.nodeValue;
    if (attrName == 'style' || attrName == 'class') continue;
    eventMatch = attrName.match(/^on(.+)/);

    if (eventMatch) {
      eventName = eventMatch[1];
      on[eventName] = new Function('event', 'sender', attrValue);
      continue;
    }

    propMatch = attrName.match(/^prop-(.+)/);

    if (propMatch) {
      propName = propMatch[1];
      props[propName] = attrValue;
      continue;
    }

    attr[attrName] = attrValue;
  }

  var key;

  for (key in style) {
    //style is not empty
    obj.style = style;
    break;
  }

  for (key in attr) {
    obj.attr = attr;
    break;
  }

  for (key in on) {
    obj.on = on;
    break;
  }

  for (key in props) {
    obj.props = props;
    break;
  }

  return obj;
}

Dom.getConstructDescriptor = getConstructDescriptor;

Dom.addToResizeSystem = function (element) {
  _ResizeSystem.default.add(element);
};

Dom.updateResizeSystem = function () {
  _ResizeSystem.default.update();
};

Dom.updateSizeUp = function (fromElt) {
  _ResizeSystem.default.updateUp(fromElt);
};

var _default = Dom;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/ACore.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/ACore.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.$$ = exports.$ = exports._ = void 0;

require("./css/default.css");

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));


var ACore = new _Dom.default({
  creator: Object.assign({}, _Dom.default.ShareInstance.creator)
});
var _ = ACore._;
exports._ = _;
var $ = ACore.$;
exports.$ = $;
var $$ = ACore.$$;
exports.$$ = $$;
var _default = ACore;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/adapter/SearchObjectArrayAdapter.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/adapter/SearchObjectArrayAdapter.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @typedef {Object} SearchObjectArrayAdapter
 * @property {function} getItemText
 * 
 * 
 * 
 * @param {Array<Object>} arr 
 * @param {SearchArrayAdapterOption} options
 */
function SearchObjectArrayAdapter(objects, options) {
  if (!this.queryItems) return new SearchObjectArrayAdapter(texts, options);
  this.objects = objects;
  this.options = options;
}

SearchObjectArrayAdapter.prototype.queryItems = function (query, mInput) {
  var query = query.toLocaleLowerCase();
  return this.objects.map(function (object) {
    var text = this.getItemText(object);
    var start = text.toLocaleLowerCase().indexOf(query);

    if (start >= 0) {
      var hightlightedText = text.substr(0, start) + '<strong style="color:red">' + text.substr(start, query.length) + '</strong>' + text.substr(start + query.length);
      return Object.assign(object, {
        __hightlightedText__: hightlightedText
      });
    } else return null;
  }.bind(this)).filter(function (it) {
    return it !== null;
  });
};

SearchObjectArrayAdapter.prototype.onAttached = function (parent) {
  this.parent = parent;

  parent.getSelectedObject = function () {
    if (this._selectedIndex >= 0) {
      return this.$poolItems[this._selectedIndex]._holderItem;
    } else {
      return null;
    }
  };
};

SearchObjectArrayAdapter.prototype.getItemText = function (item, mInput) {
  if (this.options && this.options.getItemText) return this.options.getItemText.call(this, item, mInput);else if (typeof item.text == 'string') {
    return item.text;
  } else return item.toString();
};

SearchObjectArrayAdapter.prototype.getItemView = function (item, index, _, $, query, reuseItem, refParent, mInput) {
  if (reuseItem) {
    reuseItem.childNodes[0].innerHTML = item.__hightlightedText__;
    return reuseItem;
  } else return _({
    tag: 'div',
    child: {
      tag: 'span',
      props: {
        innerHTML: item.__hightlightedText__
      }
    }
  });
};

var _default = SearchObjectArrayAdapter;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/adapter/SearchStringArrayAdapter.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/adapter/SearchStringArrayAdapter.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @typedef {Object} SearchArrayAdapterOption
 * @property {function} searchFuntion
 * 
 * 
 * 
 * @param {Array<String>} arr 
 * @param {SearchArrayAdapterOption} options not implement yet
 */
function SearchStringArrayAdapter(texts, options) {
  if (!this.queryItems) return new SearchStringArrayAdapter(texts, options);
  this.texts = texts;
}

SearchStringArrayAdapter.prototype.queryItems = function (query, mInput) {
  var query = query.toLocaleLowerCase();
  return this.texts.map(function (text) {
    var start = text.toLocaleLowerCase().indexOf(query);

    if (start >= 0) {
      var hightlightedText = text.substr(0, start) + '<strong style="color:red">' + text.substr(start, query.length) + '</strong>' + text.substr(start + query.length);
      return {
        text: text,
        hightlightedText: hightlightedText
      };
    } else return null;
  }).filter(function (it) {
    return it !== null;
  });
};

SearchStringArrayAdapter.onAttached = function (parent) {
  this.parent = parent;
};

SearchStringArrayAdapter.prototype.getItemText = function (item, mInput) {
  return item.text;
};

SearchStringArrayAdapter.prototype.getItemView = function (item, index, _, $, query, reuseItem, refParent, mInput) {
  if (reuseItem) {
    reuseItem.childNodes[0].innerHTML = item.hightlightedText;
    return reuseItem;
  } else return _({
    tag: 'div',
    child: {
      tag: 'span',
      class: 'absol-autocomplete-input-item-text',
      props: {
        innerHTML: item.hightlightedText
      }
    }
  });
};

var _default = SearchStringArrayAdapter;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/AutoCompleteInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/AutoCompleteInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/autocompleteinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _SearchStringArrayAdapter = _interopRequireDefault(require("./adapter/SearchStringArrayAdapter"));

var _SearchObjectArrayAdapter = _interopRequireDefault(require("./adapter/SearchObjectArrayAdapter"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function AutoCompleteInput() {
  this.$input = $('input', this).on('keyup', this.eventHandler.keyup).on('keydown', this.eventHandler.keydown).on('focus', this.eventHandler.focus).on('blur', this.eventHandler.blur);
  this.$dropdown = $('.absol-autocomplete-input-dropdown', this);
  this.$vscroller = $('bscroller', this).on('click', this.eventHandler.vscrollerClick);
  this.$poolItems = [];
  this._currentData = [];
  this._sessionIndex = 0;
  this._updatedSession = -1;
  this._cache = {};

  _OOP.default.drillProperty(this, this.$input, 'value');

  return this;
}

AutoCompleteInput.tag = 'AutoCompleteInput';

AutoCompleteInput.render = function () {
  return _({
    extendEvent: 'change',
    class: 'absol-autocomplete-input',
    child: ['input[type="text"].absol-autocomplete-input-text', {
      class: 'absol-autocomplete-input-dropdown',
      style: {
        display: 'none'
      },
      child: {
        tag: 'bscroller',
        style: {
          'max-height': '500px'
        }
      }
    }]
  });
};

AutoCompleteInput.eventHandler = {};

AutoCompleteInput.eventHandler.keyup = function (event) {
  if (this._keyTimeout) {
    clearTimeout(this._keyTimeout);
    this._keyTimeout = 0;
  }

  var cTimeout = setTimeout(function () {
    clearTimeout(cTimeout);
    this.find();
  }.bind(this), 300);

  if (this._cacheTimeout) {
    clearTimeout(this._cacheTimeout);
    this._cacheTimeout = 0;
  }

  var cacheTimeout = setTimeout(function () {
    clearTimeout(cacheTimeout);
    this.clearCache();
  }.bind(this), 300);
  this._cacheTimeout = cacheTimeout;
  this._keyTimeout = cTimeout;
};

AutoCompleteInput.eventHandler.blur = function () {
  this.removeClass('focus');
};

AutoCompleteInput.eventHandler.focus = function () {
  this.addClass('focus');
  $(document.body).on('mousedown', this.eventHandler.clickOut); //todo
};

AutoCompleteInput.eventHandler.clickOut = function (event) {
  if (_EventEmitter.default.hitElement(this, event)) return;
  $(document.body).off('mousedown', this.eventHandler.clickOut);
  var text = this.$input.value;

  if (this._lastValue != text) {
    this._lastValue = text;
    this.$dropdown.addStyle('display', 'none');
    this._lastValue = text;
    this.emit('change', {
      target: this,
      value: text
    }, this);
  }
};

AutoCompleteInput.eventHandler.vscrollerClick = function (event) {
  var current = event.target;

  while (current && !current.containsClass('absol-autocomplete-input-item') && current != this.$vscroller) {
    current = current.parentElement;
  }

  if (current && current._holderItem) {
    var text = this.getItemText(current._holderItem);
    this.$input.value = text;
    this._lastQuery = text;
    this._selectedIndex = current._holderIndex;
    this.$dropdown.addStyle('display', 'none');
    this._lastValue = text;
    this.emit('change', {
      target: this,
      value: text
    }, this);
  }
};

AutoCompleteInput.eventHandler.keydown = function (event) {
  var key = event.key;

  if (key == 'ArrowDown') {
    if (this._selectedIndex + 1 < this._currentData.length) {
      if (this.$poolItems[this._selectedIndex]) {
        this.$poolItems[this._selectedIndex].removeClass('active');
      }

      this._selectedIndex += 1;

      if (this.$poolItems[this._selectedIndex]) {
        this.$poolItems[this._selectedIndex].addClass('active');

        this.$vscroller.scrollInto(this.$poolItems[this._selectedIndex]);
      }
    }

    event.preventDefault();
  } else if (key == 'ArrowUp') {
    if (this._selectedIndex - 1 >= 0) {
      if (this.$poolItems[this._selectedIndex]) {
        this.$poolItems[this._selectedIndex].removeClass('active');
      }

      this._selectedIndex -= 1;

      if (this.$poolItems[this._selectedIndex]) {
        this.$poolItems[this._selectedIndex].addClass('active');

        this.$vscroller.scrollInto(this.$poolItems[this._selectedIndex]);
      }
    }

    event.preventDefault();
  } else if (key == 'Enter') {
    var text;

    if (this._currentData[this._selectedIndex] === undefined) {
      text = this.$input.value;
    } else {
      text = this.getItemText(this._currentData[this._selectedIndex]);
      this.$input.value = text;
    }

    this._lastQuery = text;
    this.$dropdown.addStyle('display', 'none');
    this._lastValue = text;
    this.emit('change', {
      target: this,
      value: text
    }, this);
  }
};

AutoCompleteInput.prototype.focus = function () {
  if (this.disabled) return;
  this.$input.focus.apply(this.$input, arguments);
};

AutoCompleteInput.prototype.blur = function () {
  this.$input.blur.apply(this.$input, arguments);
};

AutoCompleteInput.prototype.select = function () {
  this.$input.select.apply(this.$input, arguments);
};

AutoCompleteInput.prototype.find = function () {
  var query = this.$input.value;
  if (query == this._lastQuery) return;
  this._lastQuery = query;
  var currentSession = ++this._sessionIndex;

  if (!query) {
    this.pushData([], currentSession, query);
    return;
  }

  if (this.disableCache) {
    var onReciveData = function (data) {
      cacheHolder.data = data;
      this.pushData(data, currentSession, query); //sessionIndex may be change
    }.bind(this);

    var result = this.queryItems(query);
    if (typeof result.then == 'function') result.then(onReciveData);else onReciveData(result);
  } else {
    if (this._cache[query]) {
      this._cache[query].sessionIndex = currentSession;

      if (!this._cache[query].pending) {
        var data = this._cache[query].data;
        this.pushData(data, currentSession);
      }
    } else {
      var cacheHolder = {
        pending: true,
        sessionIndex: currentSession
      };

      var onReciveData = function (data) {
        cacheHolder.data = data;
        cacheHolder.pending = false;
        this.pushData(data, cacheHolder.sessionIndex, query); //sessionIndex may be change
      }.bind(this);

      var result = this.queryItems(query);
      if (typeof result.then == 'function') result.then(onReciveData);else onReciveData(result);
      this._cache[query] = cacheHolder;
    }
  }
};

AutoCompleteInput.prototype.pushData = function (data, sessionIndex, query) {
  if (sessionIndex > this._updatedSession) {
    this._updatedSession = sessionIndex;
    this.$vscroller.clearChild();
    this._currentData = data;

    if (data && data.length > 0) {
      this.$dropdown.removeStyle('display');
    } else {
      this.$dropdown.addStyle('display', 'none');
    }

    var maxHeight = this.getComputedStyleValue('max-height');

    if (maxHeight == 'none' || !maxHeight) {
      maxHeight = 10000;
    } else {
      maxHeight = parseFloat(maxHeight.replace('px', ''));
    }

    var outBound = _Dom.default.traceOutBoundingClientRect(this);

    var bound = this.$input.getBoundingClientRect();
    var aTop = bound.top - outBound.top;
    var aBotom = outBound.bottom - bound.bottom;
    this.$dropdown.removeClass('top');

    if (aTop > aBotom) {
      maxHeight = Math.min(maxHeight, aTop - 10);
    } else {
      maxHeight = Math.min(maxHeight, aBotom - 10);
    }

    this.$vscroller.addStyle('max-height', maxHeight + 'px');
    this._selectedIndex = -1;
    data.reduce(function (sync, item, i, arr) {
      return sync.then(function () {
        if (this._updatedSession != sessionIndex) return;
        return new Promise(function (rs) {
          if (this._updatedSession != sessionIndex) return;
          var reuseItem = this.$poolItems.length > i ? this.$poolItems[i] : undefined;

          if (reuseItem) {
            reuseItem.removeClass('active');
          }

          var newView = this.getItemView(item, i, _, $, query, reuseItem, this);
          newView.addClass('absol-autocomplete-input-item');
          newView._holderItem = item;
          newView._holderIndex = i;
          if (i == this._selectedIndex) newView.addClass('active');

          if (this.$poolItems.length <= i) {
            this.$poolItems.push(newView);
          } else {
            this.$poolItems[i] = newView;
          }

          this.$vscroller.addChild(newView);

          if (i == 0) {
            var estimateHeight = newView.getBoundingClientRect().height * arr.length;

            if (aTop > aBotom && estimateHeight > aBotom) {
              this.$dropdown.addClass('top');
            }
          }

          if (i >= 50 && i % 50 == 0) setTimeout(rs, 0);else rs();
        }.bind(this));
      }.bind(this));
    }.bind(this), Promise.resolve());
  }
};

AutoCompleteInput.prototype.getItemText = function (item) {
  if (this.adapter && this.adapter.getItemText) {
    return this.adapter.getItemText(item, this);
  } else if (typeof item == 'string') {
    return item;
  } else {
    throw Error('You need adapter.getItemText(item, mAutoCompleteInput) to handle your item text!');
  }
};

AutoCompleteInput.prototype.getItemView = function (item, index, _, $, query, reuseItem, refParent) {
  if (this.adapter && this.adapter.getItemView) {
    return this.adapter.getItemView(item, index, _, $, query, reuseItem, refParent, this);
  } else {
    var text = this.getItemText(item);

    if (reuseItem) {
      reuseItem.childNodes[0].innerHTML = text;
      return reuseItem;
    }

    return _({
      child: {
        tag: 'span',
        class: 'absol-autocomplete-input-item-text',
        child: {
          text: text
        }
      }
    });
  }
};
/**
 * @param {String} query
 * @returns {Array}
 */


AutoCompleteInput.prototype.queryItems = function (query) {
  if (this.adapter && this.adapter.queryItems) {
    return this.adapter.queryItems(query, this);
  } else {
    throw new Error('Invalid adapter: queryItems(query, mAutoCompleteInput) not found!');
  }
};

AutoCompleteInput.prototype.clearCache = function (old) {
  if (typeof old != "number") old = 30;

  for (var key in this._cache) {
    var cacheHolder = this._cache[key];

    if (this._sessionIndex - cacheHolder.sessionIndex > old) {
      delete this._cache[key];
    }
  }
};

AutoCompleteInput.property = {};
AutoCompleteInput.property.adapter = {
  set: function (value) {
    if (value instanceof Array) {
      if (value[0] == 'SearchStringArray') {
        this._adapter = new _SearchStringArrayAdapter.default(value[1], value[2]);
      } else if (value[0] == 'SearchObjectArray') {
        this._adapter = new _SearchObjectArrayAdapter.default(value[1], value[2]);
      } else {
        throw new Error("Unknown adapter type name");
      }
    } else {
      this._adapter = value;
    }

    if (this.adapter && this.adapter.onAttached) {
      this.adapter.onAttached(this);
    }
  },
  get: function () {
    return this._adapter;
  }
};
AutoCompleteInput.property.disabled = {
  set: function (value) {
    if (value) {
      this.addClass('absol-disabled');
    } else {
      this.removeClass('absol-disabled');
    }
  },
  get: function () {
    return this.containsClass('absol-disabled');
  }
};
AutoCompleteInput.attribute = {};
AutoCompleteInput.attribute.disabled = {
  set: function (value) {
    if (value === true || value === 'true' || value === null) {
      this.disabled = true;
    } else {
      this.disabled = false;
    }
  },
  get: function () {
    return this.disabled ? 'true' : 'false';
  },
  remove: function () {
    this.disabled = false;
  }
};

_ACore.default.install('AutoCompleteInput'.toLowerCase(), AutoCompleteInput);

var _default = AutoCompleteInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/Element.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/Element.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _AElement = _interopRequireDefault(require("./AElement"));


var _default = _AElement.default;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/BScroller.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/BScroller.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/bscroller.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Element = _interopRequireDefault(require("absol/src/HTML5/Element"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function BScroller() {
  this.addClass('as-bscroller');
}

BScroller.tag = "bscroller";

BScroller.render = function (data) {
  if (data && data.elt) {
    return $(data.elt);
  } else return _('div');
};

BScroller.prototype.scrollInto = function (element) {
  if (_Element.default.prototype.isDescendantOf.call(element, this)) {
    var elementBound = element.getBoundingClientRect();
    var viewportBound = this.getBoundingClientRect();
    var currentScrollTop = this.scrollTop;
    var newScrollTop = currentScrollTop;

    if (elementBound.bottom > viewportBound.bottom) {
      newScrollTop = currentScrollTop + (elementBound.bottom - viewportBound.bottom);
    }

    if (elementBound.top < viewportBound.top) {
      newScrollTop = currentScrollTop - (viewportBound.top - elementBound.top);
    }

    if (newScrollTop != currentScrollTop) {
      this.scrollTop = newScrollTop;
    }

    var currentScrollLeft = this.scrollLeft;
    var newScrollLeft = currentScrollLeft;

    if (elementBound.right > viewportBound.right) {
      newScrollLeft = currentScrollLeft + (elementBound.right - viewportBound.right);
    }

    if (elementBound.left < viewportBound.left) {
      newScrollLeft = currentScrollLeft - (viewportBound.left - elementBound.left);
    }

    if (newScrollLeft != currentScrollLeft) {
      this.scrollLeft = newScrollLeft;
    }
  }
};

_ACore.default.install(BScroller);

var _default = BScroller;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Board.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Board.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/boardtable.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function Board() {}

Board.tag = "board";

Board.render = function () {
  return _({
    class: 'as-board',
    extendEvent: ['sizechange', 'changeposition']
  });
};

Board.prototype.getParent = function () {
  var parent = this.parentElement;

  while (parent) {
    if (parent.classList.contains('ac-board-table')) return parent;
    parent = parent.parentElement;
  }

  return null;
};

_ACore.default.install(Board);

var _default = Board;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/Math/Vec2.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/Math/Vec2.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/***
 *
 * @param  {Number} x
 * @param {Number} y
 * @constructor
 */
function Vec2(x, y) {
  this.x = x;
  this.y = y;
}
/***
 *
 * @returns {Vec2}
 */


Vec2.prototype.copy = function () {
  return new Vec2(this.x, this.y);
};
/***
 *
 * @returns {string}
 */


Vec2.prototype.toString = function () {
  return "(" + this.x + ", " + this.y + ")";
};
/***
 *
 * @returns {number}
 */


Vec2.prototype.abs = function () {
  return Math.sqrt(this.x * this.x + this.y * this.y);
};
/***
 *
 * @returns {Vec2}
 */


Vec2.prototype.normalized = function () {
  var l = this.abs();
  if (l == 0) l = 1;
  return this.div(l);
};
/***
 *
 * @param {number} h
 * @returns {Vec2}
 */


Vec2.prototype.mult = function (h) {
  return new Vec2(this.x * h, this.y * h);
};
/***
 *
 * @param {number} h
 * @returns {Vec2}
 */


Vec2.prototype.div = function (h) {
  return new Vec2(this.x / h, this.y / h);
};
/***
 *
 * @param v
 * @returns {number}
 */


Vec2.prototype.dist = function (v) {
  var dx = v.x - this.x;
  var dy = v.y - this.y;
  return Math.sqrt(dx * dx + dy * dy);
};
/***
 *
 * @param {Vec2} v
 * @returns {Vec2}
 */


Vec2.prototype.sub = function (v) {
  return new Vec2(this.x - v.x, this.y - v.y);
};
/***
 *
 * @param {Vec2} v
 * @returns {Vec2}
 */


Vec2.prototype.add = function (v) {
  return new Vec2(this.x + v.x, this.y + v.y);
};
/***
 *
 * @returns {Vec2}
 */


Vec2.prototype.inv = function () {
  return new Vec2(-this.x, -this.y);
};
/***
 *
 * @param {Vec2} v
 * @param {number} h
 * @returns {Vec2}
 */


Vec2.prototype.linear = function (v, h) {
  return new Vec2(this.x * (1 - h) + v.x * h, this.y * (1 - h) + v.y * h);
};
/***
 *
 * @param {Vec2} v1
 * @returns {number}
 */


Vec2.prototype.dot = function (v1) {
  return this.x * v1.x + this.y * v1.y;
};
/***
 *
 * @returns {number}
 */


Vec2.prototype.direction = function () {
  return Math.atan2(this.y, this.x);
};
/***
 *
 * @param {Number} dx
 * @param {Number} dy
 */


Vec2.prototype.translate = function (dx, dy) {
  return this.add(new Vec2(dx, dy));
};
/****
 *
 * @param {Number} angle - radian
 * @returns {Vec2}
 */


Vec2.prototype.rotate = function (angle) {
  var sinA = Math.sin(angle);
  var cosA = Math.cos(angle);
  var x = this.x * cosA - this.y * sinA;
  var y = this.x * sinA + this.y * cosA;
  return new Vec2(x, y);
};
/***
 *
 * @returns {Vec2}
 */


Vec2.prototype.rotate90 = function () {
  return new Vec2(-this.y, this.x);
};
/***
 *
 * @param {number} angle
 * @returns {Vec2}
 */


Vec2.fromDirection = function (angle) {
  return new Vec2(Math.cos(angle), Math.sin(angle));
};
/***
 *
 * @param x
 * @param y
 * @returns {Vec2}
 */


Vec2.make = function (x, y) {
  if (x instanceof Array) {
    return new Vec2(x[0], x[1]);
  } else if (x instanceof Vec2) {
    return x.copy();
  } else return new Vec2(x, y);
};

var _default = Vec2;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/Math/Rectangle.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/Math/Rectangle.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Vec = _interopRequireDefault(require("./Vec2"));


/**
 *
 * @param {Number} x
 * @param {Number} y
 * @param {Number} width
 * @param {Number} height
 */
function Rectangle(x, y, width, height) {
  this.width = width;
  this.height = height;
  this.x = x;
  this.y = y;
}
/**
 *
 * @return {Vec2}
 * @constructor
 */


Rectangle.prototype.A = function () {
  return new _Vec.default(this.x, this.y);
};
/***
 *
 * @return {Vec2}
 * @constructor
 */


Rectangle.prototype.B = function () {
  return new _Vec.default(this.x + this.width, this.y);
};
/***
 *
 * @return {Vec2}
 * @constructor
 */


Rectangle.prototype.C = function () {
  return new _Vec.default(this.x + this.width, this.y + this.height);
};
/***
 *
 * @return {Vec2}
 * @constructor
 */


Rectangle.prototype.D = function () {
  return new _Vec.default(this.x, this.y + this.height);
};
/***
 *
 * @return {number}
 */


Rectangle.prototype.square = function () {
  return this.width * this.height;
};

Rectangle.prototype.nearestPoint = function (arg0, arg1) {
  if (arg1) arg0 = _Vec.default.make(arg0, arg1);
  var res = this.A();
  var mind = res.dist(arg0);
  var d = this.B().dist(arg0);

  if (d < mind) {
    mind = d;
    res = this.B();
  }

  d = this.C().dist(arg0);

  if (d < mind) {
    mind = d;
    res = this.C();
  }

  d = this.D().dist(arg0);

  if (d < mind) {
    mind = d;
    res = this.D();
  }

  return res;
};

Rectangle.prototype.centerPoint = function () {
  return new _Vec.default(this.x + this.width / 2, this.y + this.height / 2);
};
/***
 *
 * @param {Rectangle} r
 * @param {boolean} margin
 * @return {boolean}
 */


Rectangle.prototype.isCollapse = function (r, margin) {
  if (!margin) margin = 0;
  if (this.x >= r.x + r.width + margin) return false;
  if (this.y >= r.y + r.height + margin) return false;
  if (r.x >= this.x + this.width + margin) return false;
  if (r.y >= this.y + this.height + margin) return false;
  return true;
};
/***
 *
 * @param {Rectangle} r
 * @return {number}
 */


Rectangle.prototype.collapsedSquare = function (r) {
  var collapseRect = this.collapsedRect(r);

  if (collapseRect) {
    return collapseRect.square();
  } else {
    return 0;
  }
};
/***
 *
 * @param {Rectangle} r
 * @return {Rectangle}
 */


Rectangle.prototype.collapsedRect = function (r) {
  var maxX, minX, maxY, minY, width, height;
  minX = Math.max(this.x, r.x);
  minY = Math.max(this.y, r.y);
  maxX = Math.min(this.x + this.width, r.x + r.width);
  maxY = Math.min(this.y + this.height, r.y + r.height);
  width = maxX - minX;
  height = maxY - minY;

  if (width >= 0 && height >= 0) {
    return new Rectangle(minX, minY, width, height);
  }

  return null;
};
/**
 * @param {Rectangle} r
 * @returns {Boolean}
 */


Rectangle.prototype.contains = function (r) {
  return this.x <= r.x && this.y <= r.y && this.x + this.width >= r.x + r.width && this.y + this.height >= r.y + r.height;
};
/**
 * @param {Vec2} p
 * @returns {Boolean}
 */


Rectangle.prototype.containsPoint = function (p) {
  return this.x <= p.x && this.y <= p.y && this.x + this.width >= p.x && this.y + this.height >= p.y;
};
/**
 * @param {Rectangle} other
 * @returns {Rectangle}
 */


Rectangle.prototype.merge = function (other) {
  var left = Math.min(this.x, other.x);
  var top = Math.min(this.y, other.y);
  var right = Math.max(this.x + this.width, other.x + other.width);
  var bottom = Math.max(this.y + this.height, other.y + other.height);
  return new Rectangle(left, top, right - left, bottom - top);
};
/**
 * @returns {Rectangle}
 */


Rectangle.prototype.clone = function () {
  return new Rectangle(this.x, this.y, this.width, this.height);
};
/***
 *
 * @param {Rectangle} r
 */


Rectangle.prototype.equals = function (r) {
  return this.x == r.x && this.y == r.y && this.height == r.height && this.width == r.width;
};
/**
 * @param {Number} x
 * @param {Number} y
 * @param {Number} width
 * @param {Number} height
 * @returns {Rectangle}
 */


Rectangle.make = function (x, y, width, height) {
  return new Rectangle(x, y, width, height);
};
/**
 * @param {Number} x
 * @param {Number} y
 * @param {Number} width
 * @param {Number} height
 * @returns {Rectangle}
 */


Rectangle.makeCenter = function (x, y, width, height) {
  return new Rectangle(x - width / 2, y - height / 2, width, height);
};
/**
 * @param {ClientRect|DOMRect} clientRect
 * @returns {Rectangle}
 */


Rectangle.fromClientRect = function (clientRect) {
  return new Rectangle(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
};

var _default = Rectangle;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/utils.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/utils.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.insertTextAtCursor = insertTextAtCursor;
exports.contenteditableTextOnly = contenteditableTextOnly;
exports.getSelectionText = getSelectionText;
exports.positiveIntMod = positiveIntMod;
exports.measureText = measureText;
exports.getCaretPosition = getCaretPosition;
exports.preventNotNumberInput = preventNotNumberInput;
exports.buildCss = buildCss;
exports.openFileDialog = openFileDialog;
exports.estimateWidth14 = estimateWidth14;
exports.absCeil = absCeil;
exports.zeroPadding = zeroPadding;
exports.cleanMenuItemProperty = cleanMenuItemProperty;
exports.swapElt = swapElt;
exports.vScrollIntoView = vScrollIntoView;
exports.fileSize2Text = fileSize2Text;
exports.isDateTimeFormatToken = isDateTimeFormatToken;
exports.charWidth = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


function insertTextAtCursor(text) {
  var sel, range;

  if (window.getSelection) {
    sel = window.getSelection();

    if (sel.getRangeAt && sel.rangeCount) {
      range = sel.getRangeAt(0);
      range.deleteContents();
      range.insertNode(document.createTextNode(text));
    }
  } else if (document.selection && document.selection.createRange) {
    document.selection.createRange().text = text;
  }
}

function contenteditableTextOnly(element, processText) {
  if (element.__contenteditableTextOnly__) return;
  element.__contenteditableTextOnly__ = true;
  element.addEventListener("paste", function (e) {
    e.preventDefault();

    if (e.clipboardData && e.clipboardData.getData) {
      var text = e.clipboardData.getData("text/plain");
      if (processText) text = processText(text);
      document.execCommand("insertHTML", false, text);
    } else if (window.clipboardData && window.clipboardData.getData) {
      var text = window.clipboardData.getData("Text");
      if (processText) text = processText(text);
      insertTextAtCursor(text);
    }
  });
}

function getSelectionText() {
  var text = "";
  var activeEl = document.activeElement;
  var activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;

  if (activeElTagName == "textarea" || activeElTagName == "input" && /^(?:text|search|password|tel|url)$/i.test(activeEl.type) && typeof activeEl.selectionStart == "number") {
    text = activeEl.value.slice(activeEl.selectionStart, activeEl.selectionEnd);
  } else if (window.getSelection) {
    text = window.getSelection().toString();
  }

  return text;
}
/***
 *
 * @param num
 * @param maxVal
 * @return {number}
 */


function positiveIntMod(num, maxVal) {
  if (maxVal <= 0) return 0;

  if (num >= 0 && num < maxVal) {
    return Math.floor(num);
  } else if (num === Infinity) {
    if (maxVal === Infinity) return Infinity;else return 0;
  } else if (num < 0) {
    return (num + Math.ceil(-num / maxVal) * maxVal) % maxVal;
  } else if (num >= maxVal) {
    return Math.floor(num) % maxVal;
  } else return 0;
}

function measureText(text, font) {
  // re-use canvas object for better performance
  var canvas = measureText.canvas || (measureText.canvas = document.createElement("canvas"));
  var context = canvas.getContext("2d");
  if (font) context.font = font;
  var metrics = context.measureText(text);
  return metrics;
}

function getCaretPosition(oField) {
  var iCaretPos = 0;

  if (document.selection) {
    oField.focus();
    var oSel = document.selection.createRange();
    oSel.moveStart('character', -oField.value.length);
    iCaretPos = oSel.text.length;
  } else if (oField.selectionStart || oField.selectionStart == '0') iCaretPos = oField.selectionDirection == 'backward' ? oField.selectionStart : oField.selectionEnd;

  return iCaretPos;
}
/**
 *
 * @param {AElement} elt
 */


function preventNotNumberInput(elt) {
  elt.addEventListener('keyup', function () {
    var lastValue = elt.tagName === "DIV" || elt.tagName === "SPAN" ? elt.innerHTML : elt.attributes.value;
    var cValue = parseFloat(this.value);

    if (this.value != lastValue) {
      elt.attributes.value = cValue;
      elt.emit('change', cValue, elt);
    }
  });
  elt.addEventListener("paste", function (e) {
    e.preventDefault();
    var text = "";

    if (e.clipboardData && e.clipboardData.getData) {
      text = e.clipboardData.getData("text/plain");
    } else if (window.clipboardData && window.clipboardData.getData) {
      text = window.clipboardData.getData("Text");
    }

    var matched = text.match(/[+-]?([0-9]*[.])?[0-9]+/);

    if (matched) {
      this.value = matched[0];
    }
  });
  elt.addEventListener('keydown', function (event) {
    var key = event.key;

    if (key && key.length == 1 && !event.ctrlKey && !event.altKey) {
      if (key.match(/[0-9.\-\+]/)) {
        if (key == '.' && this.value.indexOf('.') >= 0) event.preventDefault();
        if ((key == '+' || key == '-') && (this.value.indexOf('+') >= 0 || this.value.indexOf('-') >= 0 || getCaretPosition(this) > 0)) event.preventDefault();
      } else event.preventDefault();
    }
  });
}

function buildCss(StyleSheet) {
  _ACore.default._({
    tag: 'style',
    props: {
      innerHTML: Object.keys(StyleSheet).map(function (key) {
        var style = StyleSheet[key];
        return key + ' {\n' + Object.keys(style).map(function (propName) {
          return propName + ': ' + style[propName] + ';';
        }).join('\n') + '}';
      }).join('\n')
    }
  }).addTo(document.head);
}
/***
 *
 * @param {"camera"|"microphone"|"camcorder"|{accept:("image/*"|"audio/*"|"video/*"|undefined), capture:boolean|undefined, multiple:boolean|undefined}|{}} props
 * @return {Promise<File[]>}
 */


function openFileDialog(props, unSafe) {
  return new Promise(function (resolve) {
    var input = _ACore.default._({
      tag: 'input',
      style: {
        display: 'none'
      },
      attr: {
        type: 'file'
      }
    }).addTo(document.body);

    props = props || {};

    if (props === 'camera') {
      props = {
        accept: 'image/*',
        capture: 'camera'
      };
    } else if (props === 'microphone') {
      props = {
        accept: 'audio/*',
        capture: "microphone"
      };
    } else if (props === 'camcorder') {
      props = {
        accept: 'video/*',
        capture: 'camcorder'
      };
    }

    if (props.accept) {
      if (props.accept instanceof Array) input.attr('accept', props.accept.join(','));else input.attr('accept', props.accept);
    } else {
      input.attr('accept', null);
    }

    if (props.capture) {
      input.attr('capture', props.capture);
    }

    if (props.multiple) {
      input.attr('multiple', 'true');
    } else {
      input.attr('multiple');
    }

    input.value = null;

    function focusHandler() {
      setTimeout(function () {
        window.removeEventListener('focus', focusHandler);

        if (unSafe) {
          input.off('change', changeHandler);
          input.remove();
          resolve([]);
        }
      }, 1000);
    }

    function changeHandler() {
      input.off('change', changeHandler);
      window.removeEventListener('focus', focusHandler);
      var files = Array.prototype.slice.call(input.files);
      resolve(files);
      input.remove();
    }

    input.on('change', changeHandler);
    input.click();
    setTimeout(function () {
      window.addEventListener('focus', focusHandler);
    }, 10);
  });
}

var charWidth = {
  "A": 9.337890625,
  "a": 7.7861328125,
  "Ă": 9.337890625,
  "ă": 7.7861328125,
  "Â": 9.337890625,
  "â": 7.7861328125,
  "B": 9.337890625,
  "b": 7.7861328125,
  "C": 10.1103515625,
  "c": 7,
  "D": 10.1103515625,
  "d": 7.7861328125,
  "Đ": 10.1103515625,
  "đ": 7.7861328125,
  "E": 9.337890625,
  "e": 7.7861328125,
  "Ê": 9.337890625,
  "ê": 7.7861328125,
  "G": 10.8896484375,
  "g": 7.7861328125,
  "H": 10.1103515625,
  "h": 7.7861328125,
  "I": 3.8896484375,
  "i": 3.1103515625,
  "K": 9.337890625,
  "k": 7,
  "L": 7.7861328125,
  "l": 3.1103515625,
  "M": 11.662109375,
  "m": 11.662109375,
  "N": 10.1103515625,
  "n": 7.7861328125,
  "O": 10.8896484375,
  "o": 7.7861328125,
  "Ô": 10.8896484375,
  "ô": 7.7861328125,
  "Ơ": 12.00390625,
  "ơ": 9.1806640625,
  "P": 9.337890625,
  "p": 7.7861328125,
  "Q": 10.8896484375,
  "q": 7.7861328125,
  "R": 10.1103515625,
  "r": 4.662109375,
  "S": 9.337890625,
  "s": 7,
  "T": 8.5517578125,
  "t": 3.8896484375,
  "U": 10.1103515625,
  "u": 7.7861328125,
  "Ư": 11.9560546875,
  "ư": 9.3720703125,
  "V": 9.337890625,
  "v": 7,
  "X": 9.337890625,
  "x": 7,
  "Y": 9.337890625,
  "y": 7,
  " ": 3.8896484375
};
exports.charWidth = charWidth;

function estimateWidth14(text) {
  // return absol.text.measureText(text, '14px arial').width
  var l = 0;

  for (var j = 0; j < text.length; ++j) {
    l += charWidth[text.charAt(j)] || 9.337890625;
  }

  return l;
}
/***
 *
 * @param {number} v
 * @returns {number}
 */


function absCeil(v) {
  var a = Math.ceil(Math.abs(v));
  return v < 0 ? -a : a;
}
/***
 *
 * @param {number} x
 * @param {number} l
 * @returns {String}
 */


function zeroPadding(x, l) {
  var res = Math.abs(x) + '';

  while (res.length < l) {
    res = '0' + res;
  }

  if (x < 0) res = '-' + res;
  return res;
}

var propertyFilter = ["$trigger", "$content", "_isShow", "defineEvent", "isSupportedEvent", "emit", "fire", "eventEmittorOnWithTime", "on", "once", "off", "init", "eventHandler", "super", "defineAttribute", "defineAttributes", "attr", "addStyle", "removeStyle", "addChild", "addTo", "selfRemove", "selfReplace", "clearChild", "containsClass", "addClass", "removeClass", "getComputedStyleValue", "getFontSize", "findChildAfter", "findChildBefore", "addChildBefore", "addChildAfter", "getBoundingRecursiveRect", "isDescendantOf", "getCSSRules", "afterAttached", "afterDisplayed", "_azar_extendEvents", "__azar_force", "_azar_extendAttributes", "_azar_extendTags", "findAvailablePosition", "$container", "autoFixParrentSize", "sync", "$dropper", "$vmenu", "$button", "$text", "$key", "$arrow", "$iconCtn", "_textMarginRight", "_tabIndex", '$icon', '_icon', '$textNode', '$primaryBtn', '$extendBtn', '_menuHolder', '_items'].reduce(function (ac, cr) {
  ac[cr] = true;
  return ac;
}, {});
/**
 * This is a solution for menu, before a better one.
 * @param obj
 * @returns {{}}
 */

function cleanMenuItemProperty(obj) {
  var res = {};
  var keys = Object.keys(obj);
  var key;

  for (var i = 0; i < keys.length; ++i) {
    key = keys[i];

    if (!propertyFilter[key]) {
      res[key] = obj[key];
    }
  }

  res.text = obj.text;

  if (obj.icon) {
    res.icon = obj.icon;
  }

  if (obj.items) {
    res.items = obj.items;
  }

  return res;
}
/***
 *
 * @param {AElement} e1
 * @param {AElement} e2
 */


function swapElt(e1, e2) {
  var temp = _('div');

  e1.parentElement.replaceChild(temp, e1);
  e2.parentElement.replaceChild(e1, e2);
  temp.parentElement.replaceChild(e2, temp);
}
/**
 *
 * @param {HTMLElement} elt
 */


function vScrollIntoView(elt) {
  var parent = elt.parentElement;
  var overflowStyle;

  while (parent) {
    overflowStyle = window.getComputedStyle(parent)['overflow'];

    if ((overflowStyle === 'auto' || overflowStyle === 'hidden auto' || overflowStyle === 'scroll' || parent.tagName === 'HTML') && parent.clientHeight < parent.scrollHeight) {
      break;
    }

    parent = parent.parentElement;
  }

  if (!parent) return;
  var eBound = elt.getBoundingClientRect();
  var viewportBound = parent.getBoundingClientRect();
  var currentScrollTop = parent.scrollTop;
  var newScrollTop = currentScrollTop;

  if (eBound.bottom > viewportBound.bottom) {
    newScrollTop = currentScrollTop + (eBound.bottom - viewportBound.bottom);
  }

  if (eBound.top < viewportBound.top) {
    newScrollTop = currentScrollTop - (viewportBound.top - eBound.top);
  }

  if (newScrollTop != currentScrollTop) {
    parent.scrollTop = newScrollTop;
  }
}

function fileSize2Text(s) {
  if (typeof s !== "number" || isNaN(s)) return '';
  var units = ['B', 'KB', 'MB', 'GB', 'TB'];
  var b = 1;

  for (var i = 0; i < units.length; ++i) {
    if (s <= b * 1024) {
      return Math.floor(s / b * 100) / 100 + units[i];
    }

    b *= 1024;
  }

  return Math.floor(s / b * 10) / 100 + 'PB';
}

function isDateTimeFormatToken(text) {
  return ['d', 'dd', 'M', 'MM', 'y', 'yyyy', 'h', 'hh', 'H', 'HH', 'm', 'mm', 'a'].indexOf(text) >= 0;
}
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Hanger.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Hanger.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/hanger.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Vec = _interopRequireDefault(require("absol/src/Math/Vec2"));

var _BrowserDetector = _interopRequireDefault(require("absol/src/Detector/BrowserDetector"));

var _EventEmitter = require("absol/src/HTML5/EventEmitter");

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/****
 * @extends AElement
 * @constructor
 */

function Hanger() {
  this.addClass('as-hanger');
  this.defineEvent(['predrag', 'dragstart', 'drag', 'dragend']);
  this._hangOn = 0;
  this._hangerPointerData = null;
  this.on2({
    mousedown: this.eventHandler.hangerPointerDown,
    touchstart: this.eventHandler.hangerPointerDown
  });
  this._touchEvents = {
    touchend: this.eventHandler.hangerPointerFinish,
    touchcancel: this.eventHandler.hangerPointerFinish,
    touchmove: this.eventHandler.hangerPointerMove
  };
  this._mouseEvents = {
    mouseup: this.eventHandler.hangerPointerFinish,
    mouseleave: this.eventHandler.hangerPointerFinish,
    mousemove: this.eventHandler.hangerPointerMove
  };
}

Hanger.tag = 'hanger';

Hanger.render = function () {
  return _('div');
};

Hanger.prototype.on2 = function () {
  if (arguments.length == 1) {
    for (var name in arguments[0]) {
      Hanger.prototype.on2.call(this, name, arguments[0][name]);
    }
  } else if (arguments.length == 2) {
    this.addEventListener(arguments[0], arguments[1], _BrowserDetector.default.supportPassiveEvent ? {
      passive: false
    } : true);
  }
};

Hanger.prototype.off2 = function () {
  if (arguments.length == 1) {
    for (var name in arguments[0]) {
      Hanger.prototype.off2.call(this, name, arguments[0][name]);
    }
  } else if (arguments.length == 2) {
    this.removeEventListener(arguments[0], arguments[1], _BrowserDetector.default.supportPassiveEvent ? {
      passive: false
    } : true);
  }
};

Hanger.property = {};
/**
 * @type {Hanger}
 */

Hanger.property.hangOn = {
  set: function (value) {
    if (!(value > 0)) value = 0;
    this._hangOn = value;
  },
  get: function () {
    return this._hangOn;
  }
};
/**
 * @type {Hanger}
 */

Hanger.eventHandler = {};

Hanger.eventHandler.hangerPointerDown = function (event) {
  if (this._hangerPointerData) return;
  var bound = this.getBoundingClientRect();
  var startingPoint;
  var isTouch = event.type === 'touchstart';
  var pointerIdent = -1;
  var target;

  if (isTouch) {
    var touch = event.changedTouches[0];
    target = touch.target;
    pointerIdent = touch.identifier;
    startingPoint = new _Vec.default(touch.clientX, touch.clientY);
  } else {
    startingPoint = new _Vec.default(event.clientX, event.clientY);
    target = event.target;
  }

  var offsetVec = startingPoint.sub(new _Vec.default(bound.left, bound.top));
  this._hangerPointerData = {
    state: 0,
    isTouch: isTouch,
    bound: bound,
    startingPoint: startingPoint,
    offsetVec: offsetVec,
    pointerIdent: pointerIdent,
    target: target
  };
  var preDragEvent = {
    type: 'predrag',
    originEvent: event,
    isTouch: isTouch,
    bound: bound,
    startingPoint: startingPoint,
    currentPoint: startingPoint,
    offsetVec: offsetVec,
    pointerIdent: pointerIdent,
    canceled: false,
    cancel: function () {
      this.canceled = true;
    },
    clientX: startingPoint.x,
    clientY: startingPoint.y,
    target: target,
    preventDefault: function () {
      event.preventDefault();
    }
  };
  this.emit('predrag', preDragEvent, this);

  if (preDragEvent.canceled) {
    this._hangerPointerData = null;
    return;
  }

  ;
  if (isTouch) this.on2.call(document.body, this._touchEvents);else this.on2.call(document.body, this._mouseEvents);
};

Hanger.eventHandler.hangerPointerMove = function (event) {
  var pointerData = this._hangerPointerData;
  var isTouch = pointerData.isTouch;
  var pointerIdent = -2;
  var currentPoint;

  if (isTouch) {
    var touch = (0, _EventEmitter.findChangedTouchByIdent)(event, pointerData.pointerIdent);

    if (touch) {
      pointerIdent = touch.identifier;
      currentPoint = new _Vec.default(touch.clientX, touch.clientY);
    }
  } else {
    currentPoint = new _Vec.default(event.clientX, event.clientY);
    pointerIdent = -1;
  }

  if (pointerIdent != pointerData.pointerIdent) return;
  pointerData.currentPoint = currentPoint;

  if (pointerData.state == 0) {
    var distance = currentPoint.sub(pointerData.startingPoint).abs();

    if (distance >= this._hangOn) {
      var dragStartEvent = {
        type: 'dragstart',
        originEvent: event,
        isTouch: isTouch,
        bound: pointerData.bound,
        startingPoint: pointerData.startingPoint,
        offsetVec: pointerData.offsetVec,
        pointerIdent: pointerIdent,
        currentPoint: currentPoint,
        target: pointerData.target,
        clientX: currentPoint.x,
        clientY: currentPoint.y,
        preventDefault: function () {
          event.preventDefault();
        }
      };
      pointerData.state = 1;
      this.emit('dragstart', dragStartEvent, this);
    }
  }

  if (pointerData.state === 1) {
    var dragEvent = {
      type: 'drag',
      originEvent: event,
      isTouch: isTouch,
      bound: pointerData.bound,
      startingPoint: pointerData.startingPoint,
      offsetVec: pointerData.offsetVec,
      pointerIdent: pointerIdent,
      currentPoint: currentPoint,
      target: pointerData.target,
      clientX: currentPoint.x,
      clientY: currentPoint.y,
      preventDefault: function () {
        event.preventDefault();
      }
    };
    this.emit('drag', dragEvent, this);
  }
};

Hanger.eventHandler.hangerPointerFinish = function (event) {
  var pointerData = this._hangerPointerData;
  var isTouch = event.type === 'touchend';
  if (pointerData.isTouch !== isTouch) return;
  var pointerIdent = -2;
  var currentPoint;

  if (isTouch) {
    var touch = (0, _EventEmitter.findChangedTouchByIdent)(event, pointerData.pointerIdent);

    if (touch) {
      pointerIdent = touch.identifier;
      currentPoint = new _Vec.default(touch.clientX, touch.clientY);
    }
  } else {
    currentPoint = new _Vec.default(event.clientX, event.clientY);
    pointerIdent = -1;
  }

  if (pointerIdent !== pointerData.pointerIdent) return;

  if (pointerData.state === 1) {
    var dragEndEvent = {
      type: 'dragend',
      originEvent: event,
      isTouch: isTouch,
      bound: pointerData.bound,
      startingPoint: pointerData.startingPoint,
      offsetVec: pointerData.offsetVec,
      pointerIdent: pointerIdent,
      currentPoint: currentPoint,
      target: pointerData.target,
      clientX: currentPoint.x,
      clientY: currentPoint.y,
      preventDefault: function () {
        event.preventDefault();
      }
    };
    this.emit('dragend', dragEndEvent, this);
  }

  this._hangerPointerData = null;
  if (isTouch) this.off2.call(document.body, this._touchEvents);else this.off2.call(document.body, this._mouseEvents);
};

_ACore.default.install(Hanger);

var _default = Hanger;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/BoardTable.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/BoardTable.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FREE_ZONE_CLASS_NAME = exports.DRAG_ZONE_CLASS_NAME = exports.EFFECT_ZONE_CLASS_NAME = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

require("../css/boardtable.css");

require("./Board");

var _Vec = _interopRequireDefault(require("absol/src/Math/Vec2"));

var _Element = _interopRequireDefault(require("absol/src/HTML5/Element"));

var _Rectangle = _interopRequireDefault(require("absol/src/Math/Rectangle"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _EventEmitter = _interopRequireWildcard(require("absol/src/HTML5/EventEmitter"));

var _utils = require("./utils");

var _Hanger = _interopRequireDefault(require("./Hanger"));




var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function BoardTable() {
  var events = {
    touchstart: this.eventHandler.mousedown,
    mousedown: this.eventHandler.mousedown
  };

  _Hanger.default.prototype.on2.call(this, events);

  this._childHolders = [];
  this._dragEventData = null;
  this._friends = [];
  this._longPressEventData = null;
}

BoardTable.tag = 'boardtable';

BoardTable.render = function () {
  return _({
    class: 'as-board-table',
    extendEvent: ['sizechange', 'orderchange', 'itemleave', 'itementer', 'dragitemstart', 'dragitemend']
  });
};

var EFFECT_ZONE_CLASS_NAME = 'as-board-table-effect-zone';
exports.EFFECT_ZONE_CLASS_NAME = EFFECT_ZONE_CLASS_NAME;
var DRAG_ZONE_CLASS_NAME = 'as-board-drag-zone';
exports.DRAG_ZONE_CLASS_NAME = DRAG_ZONE_CLASS_NAME;
var FREE_ZONE_CLASS_NAME = 'as-board-free-zone';
exports.FREE_ZONE_CLASS_NAME = FREE_ZONE_CLASS_NAME;
BoardTable.EFFECT_ZONE_CLASS_NAME = EFFECT_ZONE_CLASS_NAME;
BoardTable.DRAG_ZONE_CLASS_NAME = DRAG_ZONE_CLASS_NAME;
BoardTable.FREE_ZONE_CLASS_NAME = FREE_ZONE_CLASS_NAME;
BoardTable.prototype.$preventContext = _({
  tag: 'textarea',
  class: 'as-board-table-prevent-context',
  props: {
    readOnly: true
  }
});
BoardTable.prototype.maxScrollSpeed = 300;

BoardTable.prototype.findDomChildBefore = function (elt) {
  var nodes = this.childNodes;

  for (var i = 0; i < nodes.length; ++i) {
    if (nodes[i] == elt) return nodes[i - 1];
  }

  return null;
};

BoardTable.prototype.findDomChildAfter = function (elt) {
  var nodes = this.childNodes;

  for (var i = 0; i < nodes.length; ++i) {
    if (nodes[i] == elt) return nodes[i + 1];
  }

  return null;
};

BoardTable.prototype.addChild = function (elt) {
  if (elt.classList.contains('as-board')) {
    elt.selfRemove();
    var atElt;

    if (this._childHolders.length > 0) {
      atElt = this.findDomChildAfter(this._childHolders[this._childHolders.length - 1].elt);

      if (atElt) {
        if (atElt != -1) this.insertBefore(elt, atElt);else throw new Error("Violation data!");
      } else {
        this.appendChild(elt);
      }
    } else {
      this.appendChild(elt);
    }

    var holder = {
      elt: elt
    };
    elt.on('sizechange', holder.onsizechange);

    this._childHolders.push(holder);
  } else {
    this.appendChild(elt);
  }

  return this;
};

BoardTable.prototype.removeChild = function (elt) {
  var holderIndex = this.findChildHolderIndex(elt);

  if (holderIndex >= 0) {
    var holder = this._childHolders[holderIndex];
    holder.elt.off('sizechange', holder.onsizechange);

    this._childHolders.splice(holderIndex, 1);

    holder.elt.remove();
  } else {
    this.super(elt);
  }
};

BoardTable.prototype.findChildBefore = function (elt) {
  var holderIndex = this.findChildHolderIndex(elt);
  if (holderIndex < 0) return holderIndex;
  if (holderIndex < 1) return null;
  return this._childHolders[holderIndex - 1];
};

BoardTable.prototype.findChildAfter = function (elt) {
  var holderIndex = this.findChildHolderIndex(elt);
  if (holderIndex < 0) return holderIndex;
  if (holderIndex <= this._childHolders.length) return null;
  return this._childHolders[holderIndex + 1];
};

BoardTable.prototype.addChildBefore = function (elt, at) {
  elt.selfRemove();
  var atIndex = this.findChildHolderIndex(at);

  if (elt.classList.contains('as-board')) {
    if (atIndex < 0) {
      if (this._childHolders.length > 0) {
        if (this.findDomChildAfter(this._childHolders[this._childHolders.length - 1].elt) == at) {
          atIndex = this._childHolders.length;
        } else {
          throw new Error("Invalid position, you must insert board next to other board!");
        }
      }
    }

    this.insertBefore(elt, at);
    var holder = {
      elt: elt
    };

    this._childHolders.splice(atIndex, 0, holder);
  } else {
    if (atIndex > 0) {
      throw new Error("Invalid position, you can not insert othert type between two board!");
    } else {
      this.insertBefore(elt, at);
    }
  }

  return this;
};

BoardTable.prototype.addChildAfter = function (elt, at) {
  elt.selfRemove();
  var atIndex = this.findChildHolderIndex(at);
  var afterAt = this.findDomChildAfter(at);

  if (elt.classList.contains('as-board')) {
    if (atIndex < 0) {
      if (this._childHolders.length > 0) {
        if (this.findDomChildBefore(this._childHolders[0].elt) == at) {
          atIndex = -1;
        } else throw new Error("Invalid position,  you must insert board next to other board!");
      }
    }

    var holder = {
      elt: elt
    };

    if (!afterAt) {
      this.appendChild(elt);
    } else {
      this.insertBefore(elt, afterAt);
    }

    this._childHolders.splice(atIndex + 1, 0, holder);
  } else {
    if (this._childHolders.length > 1 && atIndex >= 0 && atIndex + 1 < this._childHolders.length) {
      throw new Error("Invalid position, you can not insert othert type between two board!");
    } else {
      if (!afterAt) {
        this.appendChild(elt);
      } else {
        this.insertBefore(elt, afterAt);
      }
    }
  }

  return this;
};

BoardTable.prototype.clearChild = function () {
  this._childHolders = [];
  return _Element.default.prototype.clearChild.call(this);
};

BoardTable.prototype.findChildHolder = function (elt) {
  return this._childHolders[this.findChildHolderIndex(elt)];
};

BoardTable.prototype.findChildHolderIndex = function (elt) {
  for (var i = 0; i < this._childHolders.length; ++i) {
    if (this._childHolders[i].elt == elt) return i;
  }

  return -1;
};

BoardTable.prototype.getEffectZone = function () {
  var ez = this;

  while (ez) {
    if (ez.classList.contains(EFFECT_ZONE_CLASS_NAME)) {
      return ez;
    }

    ez = ez.parentElement;
  }

  return this;
};

BoardTable.prototype._findDragZone = function (elt) {
  var res = null;

  while (elt != this && elt) {
    if (elt.classList.contains('as-board-table')) return null; //maybe in other

    if (!res && elt.classList.contains(DRAG_ZONE_CLASS_NAME)) {
      res = elt;
    }

    if (!res && elt.classList.contains(FREE_ZONE_CLASS_NAME)) return null; // do not drag

    elt = elt.parentElement;
  }

  return res;
};

BoardTable.prototype._findBoard = function (elt) {
  while (elt != this && elt) {
    if (elt.classList.contains('as-board')) return elt;
    elt = elt.parentElement;
  }

  return null;
};

BoardTable.prototype.getAllFriends = function () {
  var thisBT = this;
  var res = [];
  var friendQR;

  for (var i = 0; i < this._friends.length; ++i) {
    friendQR = this._friends[i];

    if (friendQR != this && friendQR && friendQR.classList && friendQR.classList.contains('as-board-table')) {
      res.push(friendQR);
    } else if (typeof friendQR == 'string') {
      // query
      $(friendQR, false, function (elt) {
        if (thisBT != elt && elt.classList && elt.classList.contains('as-board-table')) {
          res.push(elt);
        }

        return false;
      });
    }
  }

  return res;
};

BoardTable.prototype._findHoverBoardIndex = function (clientX, clientY, excludes) {
  var cli = new _Vec.default(clientX, clientY);
  var bound;

  for (var i = 0; i < this._childHolders.length; ++i) {
    // holder =
    if (excludes && excludes.indexOf(this._childHolders[i].elt) >= 0) continue;
    bound = _Rectangle.default.fromClientRect(this._childHolders[i].elt.getBoundingClientRect());
    if (bound.containsPoint(cli)) return i;
  }

  return -1;
};
/**
 * @type {BoardTable}
 */


BoardTable.eventHandler = {};

BoardTable.eventHandler.mousedown = function (event) {
  if (this._dragEventData) return;
  var mousePos;
  var pointerIdent = -1;
  var target;
  var isTouch = event.type === 'touchstart';

  if (isTouch) {
    var touch = event.changedTouches[0];
    target = touch.target;
    pointerIdent = touch.identifier;
    mousePos = new _Vec.default(touch.clientX, touch.clientY);
  } else {
    mousePos = new _Vec.default(event.clientX, event.clientY);
    target = event.target;
  }

  var dragzone = this._findDragZone(target);

  if (dragzone) {
    var boardElt = this._findBoard(dragzone);

    var holderIndex = this.findChildHolderIndex(boardElt);
    if (holderIndex < 0) return; // can not move

    var cBound = boardElt.getBoundingClientRect();
    var mouseBoardOffset = mousePos.sub(new _Vec.default(cBound.left, cBound.top));
    this._dragEventData = {
      boardElt: boardElt,
      state: 'WAIT',
      mouseStartPos: mousePos,
      mousePos: mousePos,
      mouseBoardOffset: mouseBoardOffset,
      holderIndex: holderIndex,
      boardBound: cBound,
      isTouch: isTouch,
      pointerIdent: pointerIdent
    };

    var cEvent = _EventEmitter.default.copyEvent(event);

    if (isTouch) {
      _Hanger.default.prototype.on2.call(document.body, {
        touchend: this.eventHandler.touchFinishBeforeReadyDrag,
        touchcancel: this.eventHandler.touchFinishBeforeReadyDrag,
        touchmove: this.eventHandler.touchMoveBeforeReadyDrag
      });

      this.$preventContext.off('contextmenu', this.eventHandler.contextMenu); //event maybe not remove because of double click

      this.$preventContext.on('contextmenu', this.eventHandler.contextMenu);
      var thisBT = this;
      this._dragEventData._longPressTimeout = setTimeout(function () {
        thisBT._longPressEventData = -1;
        thisBT.$preventContext.addStyle({
          '--x': mousePos.x + 'px',
          '--y': mousePos.y + 'px'
        }).addTo(document.body);
        thisBT.eventHandler.readyDrag(cEvent);
      }, 400);
    } else {
      this.eventHandler.readyDrag(event);
    }
  }
};

BoardTable.eventHandler.touchFinishBeforeReadyDrag = function (event) {
  var thisBT = this;
  var dragEventData = this._dragEventData;
  if (!dragEventData) return;

  _Hanger.default.prototype.off2.call(document.body, {
    touchend: this.eventHandler.touchFinishBeforeReadyDrag,
    touchcancel: this.eventHandler.touchFinishBeforeReadyDrag,
    touchmove: this.eventHandler.touchMoveBeforeReadyDrag
  });

  if (this._dragEventData._longPressTimeout > 0) {
    clearTimeout(this._dragEventData._longPressTimeout);
  }

  if (dragEventData.state === 'WAIT') {
    this._dragEventData = null; // canceled
  } else {
    setTimeout(function () {
      thisBT.$preventContext.off('contextmenu', thisBT.eventHandler.contextMenu);
      thisBT.$preventContext.remove();
    }, 60);
  }
};

BoardTable.eventHandler.contextMenu = function (event) {
  event.preventDefault();
  this.$preventContext.off('contextmenu', this.eventHandler.contextMenu);
  this.$preventContext.remove();
  this.eventHandler.touchFinishBeforeReadyDrag(event);
};

BoardTable.eventHandler.touchMoveBeforeReadyDrag = function (event) {
  var dragEventData = this._dragEventData;
  var touch = (0, _EventEmitter.findChangedTouchByIdent)(event, dragEventData.pointerIdent);
  if (!touch) return;
  var mousePos = new _Vec.default(touch.clientX, touch.clientY);

  if (dragEventData.state === 'WAIT') {
    var dv = mousePos.sub(dragEventData.mouseStartPos);

    if (dv.abs() > 8) {
      this.eventHandler.touchFinishBeforeReadyDrag(event);
      this._dragEventData = null; // cancel
    }
  } else {
    this.$preventContext.addStyle({
      '--x': mousePos.x + 'px',
      '--y': mousePos.y + 'px'
    });
  }
};

BoardTable.eventHandler.readyDrag = function (event) {
  var dragEventData = this._dragEventData;
  dragEventData.state = "PRE_DRAG";
  var bodyEvents = {};

  if (dragEventData.isTouch) {
    bodyEvents.touchmove = this.eventHandler.mousemove;
    bodyEvents.touchcancel = this.eventHandler.mousefinish;
    bodyEvents.touchend = this.eventHandler.mousefinish;
  } else {
    bodyEvents.mousemove = this.eventHandler.mousemove;
    bodyEvents.mouseup = this.eventHandler.mousefinish;
    bodyEvents.mouseleave = this.eventHandler.mousefinish;
  }

  _Hanger.default.prototype.on2.call(document.body, bodyEvents);

  if (dragEventData.isTouch) {
    this.eventHandler.mousemove(event);
  }
};

BoardTable.eventHandler.mousemovePredrag = function (event) {
  var dragEventData = this._dragEventData;
  var mousePos = dragEventData.mousePos;
  var thisBT = this;
  event.preventDefault();
  var cBound = dragEventData.boardElt.getBoundingClientRect();

  if (mousePos.sub(dragEventData.mouseStartPos).abs() > 8 || dragEventData.isTouch) {
    dragEventData.placeHolderElt = $(dragEventData.boardElt.cloneNode(false)).addClass('as-board-place-holder').addStyle({
      width: cBound.width + 'px',
      height: cBound.height + 'px'
    });
    dragEventData.friendHolders = this.getAllFriends().concat([this]).map(function (elt) {
      //include itself
      var effectZone = elt.getEffectZone();
      var res = {
        elt: elt,
        effectZone: effectZone
      };

      if (!dragEventData.isTouch) {
        var enterEvent = thisBT.eventHandler.enterFriendEffectZone.bind(thisBT, elt);

        _Hanger.default.prototype.on2.call(effectZone, dragEventData.isTouch ? 'touchmove' : 'mouseenter', enterEvent);

        res.enterEvent = enterEvent;
      } else {// use move event to detect
      }

      return res;
    });
    dragEventData.inEffectZoneOf = this;
    dragEventData.cardStyle = {
      width: dragEventData.boardElt.style.width,
      height: dragEventData.boardElt.style.height
    };
    dragEventData.boardElt.addStyle({
      width: cBound.width + 'px',
      height: cBound.height + 'px'
    });
    this.insertBefore(dragEventData.placeHolderElt, dragEventData.boardElt);
    dragEventData.state = "DRAG";
    $(document.body).addClass('as-has-board-table-drag');
    dragEventData.boardElt.addClass('as-board-moving');
    dragEventData.boardAt = dragEventData.holderIndex;
    dragEventData.boardIn = thisBT;
    this.emit('dragitemstart', {
      type: 'dragitemstart',
      target: this,
      boardElt: this._dragEventData.boardElt
    }, this);
  }
};

BoardTable.eventHandler.mousemoveDragInSelf = function (event) {
  var dragEventData = this._dragEventData;
  var mousePos = dragEventData.mousePos;

  if (this._childHolders.length < 2) {
    if (dragEventData.boardIn != this) {
      this.insertBefore(dragEventData.placeHolderElt, this._childHolders[0].elt);
      dragEventData.boardIn = this;
      dragEventData.boardAt = 0;
    }
  } else {
    // bản thân chỉ có 1, hoặc nhiều hơn
    var i = this._findHoverBoardIndex(mousePos.x, mousePos.y, [dragEventData.boardElt]);

    if (i >= 0) {
      if (dragEventData.boardIn != this) {
        dragEventData.boardIn = this;
      }

      var viewIndex;

      if (i < dragEventData.holderIndex && i < dragEventData.boardAt || i > dragEventData.holderIndex && i > dragEventData.boardAt || dragEventData.holderIndex == dragEventData.boardAt) {
        viewIndex = i;
      } else {
        if (dragEventData.holderIndex > dragEventData.boardAt) {
          viewIndex = i + 1;
        } else {
          viewIndex = i - 1;
        }
      }

      var fbound = this._childHolders[i].elt.getBoundingClientRect();

      var displayStyple = this._childHolders[i].elt.getComputedStyleValue('display');

      if (mousePos.x > fbound.left && mousePos.x < fbound.right && mousePos.y > fbound.top && mousePos.y < fbound.bottom) {
        if (displayStyple.startsWith('inline')) {
          if (dragEventData.boardBound.width < fbound.width) {
            if (dragEventData.boardAt > viewIndex && mousePos.x > fbound.left + dragEventData.boardBound.width) {
              viewIndex += 1;
            } else if (dragEventData.boardAt < viewIndex && mousePos.x < fbound.left + fbound.width - dragEventData.boardBound.width) {
              viewIndex -= 1;
            }
          }
        } else {
          if (dragEventData.boardBound.height < fbound.height) {
            if (dragEventData.boardAt > viewIndex && mousePos.y >= fbound.top + dragEventData.boardBound.height) {
              viewIndex += 1;
            } else if (dragEventData.boardAt < viewIndex && mousePos.y <= fbound.top + fbound.height - dragEventData.boardBound.height) {
              viewIndex -= 1;
            }
          }
        }

        viewIndex = Math.max(0, Math.min(this._childHolders.length, viewIndex));

        if (viewIndex != dragEventData.boardAt) {
          dragEventData.boardAt = viewIndex;

          if (dragEventData.holderIndex >= viewIndex) {
            this.insertBefore(dragEventData.placeHolderElt, this._childHolders[viewIndex].elt);
          } else {
            var bf = _Element.default.prototype.findChildAfter.call(this, this._childHolders[viewIndex].elt);

            if (bf) this.insertBefore(dragEventData.placeHolderElt, bf);else {
              this.appendChild(dragEventData.placeHolderElt);
            }
          }
        }
      }
    }
  }
};

BoardTable.eventHandler.mousemoveDragInOther = function (event) {
  var dragEventData = this._dragEventData;
  var mousePos = dragEventData.mousePos;
  var other = dragEventData.inEffectZoneOf;

  if (other._childHolders.length == 0) {
    if (dragEventData.boardIn != other) {
      dragEventData.boardIn = other;
      dragEventData.boardAt = 0;
      other.appendChild(dragEventData.placeHolderElt);
    }
  } else {
    var i = other._findHoverBoardIndex(mousePos.x, mousePos.y);

    if (i >= 0) {
      if (dragEventData.boardIn != other) {
        dragEventData.boardIn = other;
      }

      var displayStyple = other._childHolders[i].elt.getComputedStyleValue('display');

      var di = 0;

      var bbound = other._childHolders[i].elt.getBoundingClientRect();

      if (displayStyple.startsWith('inline')) {
        if (mousePos.x > bbound.left + bbound.width / 2) di++;
      } else {
        if (mousePos.y > bbound.top + bbound.height / 2) di++;
      }

      i += di;

      if (i < other._childHolders.length) {
        other.insertBefore(dragEventData.placeHolderElt, other._childHolders[i].elt);
      } else {
        var bf = other.findChildAfter(other._childHolders[other._childHolders.length - 1].elt);

        if (bf) {
          other.insertBefore(dragEventData.placeHolderElt, bf);
        } else {
          other.appendChild(dragEventData.placeHolderElt);
        }
      }

      dragEventData.boardAt = i;
    }
  }
};

BoardTable.eventHandler.mousemoveDrag = function (event) {
  var dragEventData = this._dragEventData;

  if (dragEventData.inEffectZoneOf == this) {
    this.eventHandler.mousemoveDragInSelf(event);
  } else {
    this.eventHandler.mousemoveDragInOther(event);
  }
};

BoardTable.eventHandler.boarDrag = function (event) {
  var dragEventData = this._dragEventData;
  var mousePos = dragEventData.mousePos;
  var boardPos = mousePos.sub(dragEventData.mouseBoardOffset);
  dragEventData.boardElt.addStyle({
    left: boardPos.x + 'px',
    top: boardPos.y + 'px'
  });
};

BoardTable.eventHandler.dragOnEffectZone = function (event) {
  var dragEventData = this._dragEventData;
  var mousePos = dragEventData.mousePos;
  var friendHolders = dragEventData.friendHolders;
  var bound;

  for (var i = 0; i < friendHolders.length; ++i) {
    bound = _Rectangle.default.fromClientRect(friendHolders[i].effectZone.getBoundingClientRect());

    if (bound.containsPoint(mousePos)) {
      dragEventData.inEffectZoneOf = friendHolders[i].elt;
      break;
    }
  }
};

BoardTable.eventHandler.mousemoveOverflow = function (event) {
  if (!this._dragEventData) return;
  var dragEventData = this._dragEventData;
  var scrollerX = this._dragEventData.boardIn;
  var overflowStyle;

  while (scrollerX) {
    overflowStyle = window.getComputedStyle(scrollerX)['overflow'];
    if ((overflowStyle === 'auto' || overflowStyle === 'auto hidden' || overflowStyle === 'scroll' || scrollerX.tagName === 'HTML') && scrollerX.clientWidth < scrollerX.scrollWidth) break;
    scrollerX = scrollerX.parentElement;
  }

  var scrollerY = this._dragEventData.boardIn;

  while (scrollerY) {
    overflowStyle = window.getComputedStyle(scrollerY)['overflow'];
    if ((overflowStyle === 'auto' || overflowStyle === 'hidden auto' || overflowStyle === 'scroll' || scrollerY.tagName === 'HTML') && scrollerY.clientHeight < scrollerY.scrollHeight) break;
    scrollerY = scrollerY.parentElement;
  }

  var outBound;
  var bBound;

  var screenSize = _Dom.default.getScreenSize();

  var vx = 0;
  var vy = 0;
  bBound = this._dragEventData.boardElt.getBoundingClientRect();

  if (scrollerX) {
    if (dragEventData.$scrollerX !== scrollerX) {
      dragEventData.scrollerXValue = scrollerX.scrollLeft;
      dragEventData.$scrollerX = scrollerX;
    }

    outBound = scrollerX.getBoundingClientRect();
    outBound = {
      left: Math.max(outBound.left, 0),
      top: Math.max(outBound.top, 0),
      bottom: Math.min(outBound.bottom, screenSize.height),
      right: Math.min(outBound.right, screenSize.width)
    };

    if (bBound.left < outBound.left) {
      vx = bBound.left - outBound.left;
    } else if (bBound.right > outBound.right) {
      vx = bBound.right - outBound.right;
    }
  } else {
    dragEventData.$scrollerX = null;
  }

  if (scrollerY) {
    if (dragEventData.$scrollerY !== scrollerY) {
      dragEventData.scrollerYValue = scrollerY.scrollTop;
      dragEventData.$scrollerY = scrollerY;
    }

    outBound = scrollerY.getBoundingClientRect();
    outBound = {
      left: Math.max(outBound.left, 0),
      top: Math.max(outBound.top, 0),
      bottom: Math.min(outBound.bottom, screenSize.height),
      right: Math.min(outBound.right, screenSize.width)
    };

    if (bBound.top < outBound.top) {
      vy = bBound.top - outBound.top;
    } else if (bBound.bottom > outBound.bottom) {
      vy = bBound.bottom - outBound.bottom;
    }
  } else {
    dragEventData.$scrollerY = null;
  }

  vx = Math.max(-this.maxScrollSpeed, Math.min(this.maxScrollSpeed, vx * Math.sqrt(Math.abs(vx))));
  vy = Math.max(-this.maxScrollSpeed, Math.min(this.maxScrollSpeed, vy * Math.sqrt(Math.abs(vy))));

  if (vx !== 0 || vy !== 0) {
    var copyEvent = {
      type: event.type,
      preventDefault: function () {
        /* noop */
      },
      target: event.target
    };

    if (event.type === 'touchmove') {
      copyEvent.changedTouches = Array.prototype.map.call(event.changedTouches, function (it) {
        return {
          identifier: it.identifier,
          clientX: it.clientX,
          clientY: it.clientY,
          target: it.target
        };
      });
      copyEvent.touches = Array.prototype.map.call(event.touches, function (it) {
        return {
          identifier: it.identifier,
          clientX: it.clientX,
          clientY: it.clientY,
          target: it.target
        };
      });
    } else {
      copyEvent.clientX = event.clientX;
      copyEvent.clientY = event.clientY;
    }

    var thisBT = this;
    var now = new Date().getTime();

    if (dragEventData.requestAnimationFrameId >= 0) {
      cancelAnimationFrame(dragEventData.requestAnimationFrameId);
    }

    dragEventData.requestAnimationFrameId = requestAnimationFrame(function () {
      dragEventData.requestAnimationFrameId = -1;
      var dt = (new Date().getTime() - now) / 1000;

      if (dragEventData.$scrollerY) {
        dragEventData.scrollerYValue += vy * dt;
        dragEventData.scrollerYValue = Math.max(0, Math.min(dragEventData.$scrollerY.scrollHeight - dragEventData.$scrollerY.clientHeight, dragEventData.scrollerYValue));
        dragEventData.$scrollerY.scrollTop = dragEventData.scrollerYValue;
      }

      if (dragEventData.$scrollerX) {
        dragEventData.scrollerXValue += vx * dt;
        dragEventData.scrollerXValue = Math.max(0, Math.min(dragEventData.$scrollerX.scrollWidth - dragEventData.$scrollerX.clientWidth, dragEventData.scrollerXValue));
        dragEventData.$scrollerX.scrollLeft = dragEventData.scrollerXValue;
      }

      if (thisBT._dragEventData && thisBT._dragEventData.state === "DRAG") {
        thisBT.eventHandler.mousemoveOverflow(copyEvent);
      }
    });
  }
};

BoardTable.eventHandler.mousemove = function (event) {
  var dragEventData = this._dragEventData;
  var isTouch = event.type === 'touchmove' || event.type === 'touchstart'; // call from timeout

  if (dragEventData.isTouch !== isTouch) return;
  var mousePos;
  var pointerIdent;
  var touch = -2;

  if (isTouch) {
    touch = (0, _EventEmitter.findChangedTouchByIdent)(event, dragEventData.pointerIdent);

    if (touch) {
      pointerIdent = touch.identifier;
      mousePos = new _Vec.default(touch.clientX, touch.clientY);
    }
  } else {
    pointerIdent = -1;
    mousePos = new _Vec.default(event.clientX, event.clientY);
  }

  if (dragEventData.pointerIdent !== pointerIdent) return;
  dragEventData.mousePos = mousePos;
  event.preventDefault();

  if (dragEventData.isTouch && dragEventData.state === 'DRAG') {
    this.eventHandler.dragOnEffectZone(event); //because touch not have mouseenter event
  }

  if (dragEventData.state === 'PRE_DRAG') {
    this.eventHandler.mousemovePredrag(event);
  }

  if (dragEventData.state === 'DRAG') {
    this.eventHandler.mousemoveDrag(event);
    this.eventHandler.boarDrag(event);
    this.eventHandler.mousemoveOverflow(event);
  }
};

BoardTable.eventHandler.mousefinish = function (event) {
  var dragEventData = this._dragEventData;
  var isTouch = event.type === 'touchend';
  if (dragEventData.isTouch !== isTouch) return;
  var mousePos;
  var pointerIdent;
  var touch = -2;

  if (isTouch) {
    touch = (0, _EventEmitter.findChangedTouchByIdent)(event, dragEventData.pointerIdent);

    if (touch) {
      pointerIdent = touch.identifier;
      mousePos = new _Vec.default(touch.clientX, touch.clientY);
    }
  } else {
    pointerIdent = -1;
    mousePos = new _Vec.default(event.clientX, event.clientY);
  }

  if (dragEventData.pointerIdent !== pointerIdent) return;
  dragEventData.mousePos = mousePos;
  var changed;

  if (dragEventData.state == 'DRAG') {
    setTimeout(function () {
      $(document.body).removeClass('as-has-board-table-drag');
    }, 1);
    dragEventData.boardElt.removeClass('as-board-moving').removeStyle('left').removeStyle('top');
    dragEventData.boardElt.addStyle(dragEventData.cardStyle);
    dragEventData.placeHolderElt.remove();
    dragEventData.state = "FINISH";
    if (!dragEventData.isTouch) dragEventData.friendHolders.forEach(function (holder) {
      _Hanger.default.prototype.off2.call(holder.effectZone, 'mouseenter', holder.enterEvent);
    });

    if (dragEventData.boardIn == this) {
      if (dragEventData.holderIndex != dragEventData.boardAt) {
        if (dragEventData.holderIndex > dragEventData.boardAt) {
          this.insertBefore(dragEventData.boardElt, this._childHolders[dragEventData.boardAt].elt);
        } else if (dragEventData.holderIndex < dragEventData.boardAt) {
          var bf = _Element.default.prototype.findChildAfter.call(this, this._childHolders[dragEventData.boardAt].elt);

          if (bf) this.insertBefore(dragEventData.boardElt, bf);else {
            this.appendChild(dragEventData.boardElt);
          }
        }

        var holder = this._childHolders.splice(dragEventData.holderIndex, 1)[0];

        this._childHolders.splice(dragEventData.boardAt, 0, holder);

        changed = 'orderchange';
        this.emit('orderchange', {
          type: 'orderchange',
          boardElt: holder.elt,
          action: 'move',
          from: dragEventData.holderIndex,
          to: dragEventData.boardAt,
          target: this
        }, this);
      }
    } else {
      var holder = this._childHolders.splice(dragEventData.holderIndex, 1)[0];

      holder.elt.remove(); ///remove all event

      var other = dragEventData.boardIn;
      changed = 'itemleave';
      this.emit('itemleave', {
        type: 'itemleave',
        item: holder.elt,
        from: {
          index: dragEventData.holderIndex,
          table: this
        },
        to: {
          index: dragEventData.boardAt,
          table: other
        },
        target: this
      }, this);

      if (other._childHolders.length == 0) {
        other.appendChild(holder.elt);

        other._childHolders.push(holder);
      } else {
        if (dragEventData.boardAt < other._childHolders.length) {
          other.insertBefore(holder.elt, other._childHolders[dragEventData.boardAt].elt);

          other._childHolders.splice(dragEventData.boardAt, 0, holder);
        } else {
          var bf = other.findDomChildAfter(other._childHolders.elt);

          if (bf) {
            other.insertBefore(holder.elt, bf);
          } else {
            other.appendChild(holder.elt);
          }

          other._childHolders.push(holder);
        }
      }

      other.emit('itementer', {
        type: 'itementer',
        item: holder.elt,
        target: other,
        from: {
          index: dragEventData.holderIndex,
          table: this
        },
        to: {
          index: dragEventData.boardAt,
          table: other
        }
      }, other);
    }

    this.emit('dragitemend', {
      type: 'dragitemend',
      target: this,
      changed: changed,
      boardElt: this._dragEventData.boardElt
    }, this);
  }

  var bodyEvents = {};

  if (dragEventData.isTouch) {
    bodyEvents.touchmove = this.eventHandler.mousemove;
    bodyEvents.touchcancel = this.eventHandler.mousefinish;
    bodyEvents.touchend = this.eventHandler.mousefinish;
  } else {
    bodyEvents.mousemove = this.eventHandler.mousemove;
    bodyEvents.mouseup = this.eventHandler.mousefinish;
    bodyEvents.mouseleave = this.eventHandler.mousefinish;
  }

  _Hanger.default.prototype.off2.call(document.body, bodyEvents);

  this._dragEventData = null;
};

BoardTable.eventHandler.enterFriendEffectZone = function (friendElt, event) {
  this._dragEventData.inEffectZoneOf = friendElt;
};

BoardTable.prototype.getAllBoards = function () {
  return this._childHolders.map(function (holder) {
    return holder.elt;
  });
};

BoardTable.property = {};
BoardTable.property.friends = {
  set: function (value) {
    value = value || [];
    if (!(value instanceof Array)) value = [value];
    this._friends = value;
  },
  get: function () {
    return this._friends;
  }
};

_ACore.default.install(BoardTable);

var _default = BoardTable;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/ButtonArray.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/ButtonArray.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/buttonarray.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function ButtonArray() {
  this._dict = {};
  this._pool = [];
  this._items = [];
  this.$lastActiveBtn = null;
  this._value = undefined;
  this._lastValue = this._value;
}

ButtonArray.tag = 'buttonarray';

ButtonArray.render = function () {
  return _({
    extendEvent: ['change'],
    class: 'as-button-array'
  });
};

ButtonArray.prototype._newButton = function () {
  var button = _({
    tag: 'button',
    class: 'as-button-array-item',
    child: {
      text: 'null'
    }
  });

  button.on('click', this.eventHandler.clickItem.bind(this, button));
  return button;
};

ButtonArray.prototype._requestButton = function (items) {
  var button;

  if (this._pool.length > 0) {
    button = this._pool.pop();
  } else {
    button = this._newButton();
  }

  return button;
};

ButtonArray.prototype._assignButton = function (button, data) {
  button._data = data;
  button.childNodes[0].data = data.text;
};

ButtonArray.prototype._releaseButton = function (button) {
  this._pool.push(button);
};

ButtonArray.prototype._getFullFormat = function (item) {
  var res = {};

  if (typeof item == 'string' || typeof item == 'number' || typeof item == 'boolean' || item === null || item === undefined) {
    res.ident = item;
    res.value = item;
    res.text = item + '';
  } else if (item && typeof item == 'object') {
    res.value = item.value;
    res.ident = res.value + '';
    res.text = item.text;
  }

  return res;
};

ButtonArray.property = {};
/**
 * @type {ButtonArray}
 */

ButtonArray.property.items = {
  set: function (items) {
    items = items || [];
    this._items = items;
    var child;

    while (this.childNodes.length > items.length) {
      child = this.lastChild;

      this._releaseButton(child);

      this.removeChild(child);
    }

    while (this.childNodes.length < items.length) {
      this.addChild(this._requestButton());
    }

    var item;

    for (var i = 0; i < items.length; ++i) {
      item = this._getFullFormat(items[i]);

      this._assignButton(this.childNodes[i], item);

      this._dict[item.ident] = {
        elt: this.childNodes[i],
        data: item
      };
    }

    if (items.length > 0) {
      if (!this._dict[this._value + '']) {
        this._value = this._getFullFormat(items[0]).value;
      }
    }

    this.value = this._value;
  },
  get: function () {
    return this._items;
  }
};
ButtonArray.property.value = {
  set: function (value) {
    this._value = value;
    this._lastValue = this._value;

    if (this.$lastActiveBtn) {
      this.$lastActiveBtn.removeClass('as-active');
      this.$lastActiveBtn = null;
    }

    var hodler = this._dict[value + ''];

    if (hodler) {
      hodler.elt.addClass('as-active');
      this.$lastActiveBtn = hodler.elt;
    }
  },
  get: function () {
    return this._value;
  }
};
ButtonArray.eventHandler = {};

ButtonArray.eventHandler.clickItem = function (item, event) {
  if (this._lastValue != item._data.value) {
    this.value = item._data.value;
    this.emit('change', {
      target: this,
      value: this.value,
      type: 'change'
    }, this);
  }
};

_ACore.default.install(ButtonArray);

var _default = ButtonArray;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/ButtonRange.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/ButtonRange.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/buttonrange.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _ButtonArray = _interopRequireDefault(require("./ButtonArray"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
var ChevronLeft = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Layer_1" x="0px" y="0px" viewBox="0 0 410.258 410.258" style="enable-background:new 0 0 410.258 410.258;" xml:space="preserve">\n' + '<polygon points="298.052,24 266.052,0 112.206,205.129 266.052,410.258 298.052,386.258 162.206,205.129 "/>\n' + '</svg>';
var ChevronRight = '<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n' + '\t viewBox="0 0 410.258 410.258" style="enable-background:new 0 0 410.258 410.258;" xml:space="preserve">\n' + '<polygon points="144.206,0 112.206,24 248.052,205.129 112.206,386.258 144.206,410.258 298.052,205.129 "/>\n' + '</svg>';
/***
 * @extends AElement
 * @constructor
 */

function ButtonRange() {
  this._dict = {};
  this._pool = [];
  this._items = [];
  this.$lastActiveBtn = null;
  this._value = undefined;
  this._lastValue = this._value;
  this.$scroller = $('.as-button-range-scroller', this).on('wheel', this.eventHandler.wheel);
  this.$prevBtn = $('.as-button-range-left-btn', this).on('click', this.prevValue.bind(this));
  this.$nextBtn = $('.as-button-range-right-btn', this).on('click', this.nextValue.bind(this));
  this._scrollTimeout = -1;
  this._scrollToSelected = this._scrollToSelected.bind(this);
  this.$attachhook = $('attachhook', this).on('error', this.eventHandler.attached);
  this.autoWidth = false;
}

ButtonRange.tag = 'buttonrange';

ButtonRange.render = function () {
  return _({
    extendEvent: ['change'],
    class: 'as-button-range',
    child: [{
      class: 'as-button-range-scroller'
    }, {
      class: 'as-button-range-left-ctn',
      child: {
        tag: 'button',
        class: 'as-button-range-left-btn',
        child: ChevronLeft
      }
    }, {
      class: 'as-button-range-right-ctn',
      child: {
        tag: 'button',
        class: 'as-button-range-right-btn',
        child: ChevronRight
      }
    }, 'attachhook']
  });
};

ButtonRange.prototype._updateUnderlinePosition = function () {
  if (!this.$lastActiveBtn) return;
  var scrollerFirstBound = this.$scroller.firstChild.getBoundingClientRect();
  if (scrollerFirstBound.width === 0) return;
  var activeBound = this.$lastActiveBtn.getBoundingClientRect();
  this.addStyle({
    '--underline-left': activeBound.left - scrollerFirstBound.left + 'px',
    '--underline-width': activeBound.width + 'px'
  });
};

ButtonRange.prototype.updateSize = function () {
  if (this.autoWidth) {
    if (this.$scroller.childNodes.length > 0) {
      var left = this.$scroller.firstChild.getBoundingClientRect().left;
      var right = this.$scroller.lastChild.getBoundingClientRect().right;

      if (left < right) {
        var fontSize = this.getFontSize() || 14;
        this.addStyle('width', (right - left + 2) / fontSize + 2 + 'em');
      }
    }
  }

  this._updateUnderlinePosition();

  this._scrollToSelected();
};

ButtonRange.prototype._newButton = function () {
  var button = _({
    tag: 'button',
    class: 'as-button-range-item',
    child: {
      text: 'null'
    }
  });

  button.on('click', this.eventHandler.clickItem.bind(this, button));
  return button;
};

ButtonRange.prototype._requestButton = function (items) {
  var button;

  if (this._pool.length > 0) {
    button = this._pool.pop();
  } else {
    button = this._newButton();
  }

  return button;
};

ButtonRange.prototype._assignButton = function (button, data) {
  button._data = data;
  button.childNodes[0].data = data.text;
};

ButtonRange.prototype._releaseButton = function (button) {
  this._pool.push(button);
};

ButtonRange.prototype._requireButton = function (n) {
  var child;

  while (this.$scroller.childNodes.length > n) {
    child = this.$scroller.lastChild;

    this._releaseButton(child);

    this.$scroller.removeChild(child);
  }

  while (this.$scroller.childNodes.length < n) {
    this.$scroller.addChild(this._requestButton());
  }
};

ButtonRange.prototype._assignButtonList = function (items) {
  var item;

  for (var i = 0; i < items.length; ++i) {
    item = this._getFullFormat(items[i]);

    this._assignButton(this.$scroller.childNodes[i], item);

    this._dict[item.ident] = {
      elt: this.$scroller.childNodes[i],
      data: item
    };
  }
};

ButtonRange.prototype._scrollToSelected = function () {
  if (this._scrollTimeout >= 0) return;
  if (!this.$lastActiveBtn) return;
  var scrollerBound = this.$scroller.getBoundingClientRect();
  if (scrollerBound.width === 0) return;
  var activeBound = this.$lastActiveBtn.getBoundingClientRect();
  var dx, speed;

  if (activeBound.left < scrollerBound.left - 1) {
    dx = activeBound.left - scrollerBound.left;
    if (dx < -500) dx = -500;
    speed = Math.sqrt(-dx * 2 + 4);
    this.$scroller.scrollLeft -= speed;
  } else if (activeBound.right - 1 > scrollerBound.right) {
    dx = activeBound.right - scrollerBound.right;
    if (dx > 500) dx = 500;
    speed = Math.sqrt(dx * 2 + 4);
    this.$scroller.scrollLeft += speed;
  } else {
    return;
  }

  var thisBR = this;
  this._scrollTimeout = setTimeout(function () {
    thisBR._scrollTimeout = -1;

    thisBR._scrollToSelected();
  }, 20);
};

ButtonRange.prototype.nextValue = function (userAction) {
  var currentIndex = this._findActiveIndex();

  var nextIndex;
  var nextValue;

  if (currentIndex < 0) {
    nextIndex = 0;
  } else {
    nextIndex = Math.min(this._items.length - 1, currentIndex + 1);
  }

  if (nextIndex >= 0) {
    nextValue = this._getFullFormat(this._items[nextIndex]).value;
    this.value = nextValue;
    if (userAction) this.notifyChange();
  }
};

ButtonRange.prototype.prevValue = function (userAction) {
  var currentIndex = this._findActiveIndex();

  var prevIndex;
  var prevValue;

  if (currentIndex < 0) {
    prevIndex = 0;
  } else {
    prevIndex = Math.max(0, currentIndex - 1);
  }

  if (prevIndex >= 0 && prevIndex < this._items.length && prevIndex != currentIndex) {
    prevValue = this._getFullFormat(this._items[prevIndex]).value;
    this.value = prevValue;
    if (userAction) this.notifyChange();
  }
};

ButtonRange.prototype._findActiveIndex = function () {
  var item;
  var value = this._value;

  for (var i = 0; i < this._items.length; ++i) {
    item = this._items[i];
    if (item === value || item && item.value === value) return i;
  }

  return -1;
};

ButtonRange.prototype._getFullFormat = function (item) {
  var res = {};

  if (typeof item == 'string' || typeof item == 'number' || typeof item == 'boolean' || item === null || item === undefined) {
    res.ident = item + '';
    res.value = item;
    res.text = item + '';
  } else if (item && typeof item == 'object') {
    res.value = item.value;
    res.ident = res.value + '';
    res.text = item.text;
  }

  return res;
};

ButtonRange.prototype.notifyChange = function () {
  this.emit('change', {
    target: this,
    value: this.value,
    type: 'change'
  }, this);
};

ButtonRange.property = {};
/**
 * @type {ButtonRange}
 */

ButtonRange.property.items = {
  set: function (items) {
    items = items || [];
    this._items = items;

    this._requireButton(items.length);

    this._assignButtonList(items);

    if (items.length > 0) {
      if (!this._dict[this._value + '']) {
        this._value = this._getFullFormat(items[0]).value;
      }
    }

    this.value = this._value;
    this.updateSize();
  },
  get: function () {
    return this._items;
  }
};
ButtonRange.property.value = {
  set: function (value) {
    this._value = value;
    this._lastValue = this._value;

    if (this.$lastActiveBtn) {
      this.$lastActiveBtn.removeClass('as-active');
      this.$lastActiveBtn = null;
    }

    var hodler = this._dict[value + ''];

    if (hodler) {
      hodler.elt.addClass('as-active');
      this.$lastActiveBtn = hodler.elt;
    }

    var activeIndex = this._findActiveIndex();

    this.$prevBtn.disabled = activeIndex === 0;
    this.$nextBtn.disabled = activeIndex === this._items.length - 1;

    this._updateUnderlinePosition();

    this._scrollToSelected();
  },
  get: function () {
    return this._value;
  }
};
ButtonRange.eventHandler = {};

ButtonRange.eventHandler.clickItem = function (item, event) {
  if (this._lastValue != item._data.value) {
    this.value = item._data.value;
    this.notifyChange();
  }
};

ButtonRange.eventHandler.attached = function () {
  if (this.style.width === 'auto') this.autoWidth = true;

  _Dom.default.addToResizeSystem(this.$attachHook);

  this.updateSize();
};

ButtonRange.eventHandler.wheel = function (event) {
  var prevLeft = this.$scroller.scrollLeft;

  if (event.deltaY < 0) {
    this.$scroller.scrollLeft -= 100;
  } else if (event.deltaY > 0) {
    this.$scroller.scrollLeft += 100;
  }

  if (prevLeft !== this.$scroller.scrollLeft) event.preventDefault();
};

_ACore.default.install(ButtonRange);

var _default = ButtonRange;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/Math/int.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/Math/int.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.map = map;
exports.sumArr = sumArr;
exports.radianInRange = radianInRange;
exports.distance = distance;
exports.numberToString = numberToString;
exports.numberAutoFixed = numberAutoFixed;
exports.integerZeroPadding = integerZeroPadding;
exports.harmonicMean = harmonicMean;

/**
 *
 * @param {number} x
 * @param {number} l
 * @param {number} h
 * @param {number} L
 * @param {number} H
 * @returns {number}
 */
function map(x, l, h, L, H) {
  return (x - l) / (h - l) * (H - L) + L;
}

function sumArr(arr) {
  var res = 0;

  for (var i = 0; i < arr.length; ++i) res += arr[i];

  return res;
}

function radianInRange(x, start, end) {
  if (start > end) return radianInRange(x, end, start);
  if (x < start) x += Math.PI * 2 * Math.ceil((start - x) / 2 / Math.PI);
  if (x > end) x -= Math.PI * 2 * Math.ceil((x - end) / 2 / Math.PI);
  return x >= start && x <= end;
}

function distance(x0, y0, x1, y1) {
  var dx = x0 - x1;
  var dy = y0 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}
/**
 *
 * @param {Number} numb
 * @param {Number} floatFixed
 * @param {"."|","} decimalSeparator
 * @param {","|"."} thousandsSeparator
 * @param {Number} decimalPadding
 */


function numberToString(numb, floatFixed, decimalSeparator, thousandsSeparator, decimalPadding) {
  if (floatFixed === undefined || floatFixed === null || typeof floatFixed != "number" || isNaN(floatFixed) || floatFixed < -1) floatFixed = -1;
  if (decimalSeparator === undefined || decimalSeparator === null || decimalSeparator != '.' && decimalSeparator != ',') decimalSeparator = '.';
  if (thousandsSeparator === undefined || thousandsSeparator === null || floatFixed >= 0 && thousandsSeparator == decimalSeparator) thousandsSeparator = undefined;
  if (thousandsSeparator != ',' && thousandsSeparator != '.') thousandsSeparator = undefined;
  if (decimalPadding === undefined || decimalPadding === null || typeof decimalPadding != "number" || isNaN(decimalPadding) || decimalPadding < 0) decimalPadding = 0;
  var text = numb.toString();
  var matched = text.match(/[+-]?([0-9]*)(\.([0-9]*))?(e([+-]?[0-9]+))?/);
  var dec = matched[1] || '';
  var real = matched[3] || '';
  var floatPoint = parseInt(matched[5] || '0');
  var decDigits = dec.split('').map(function (d) {
    return parseInt(d);
  });
  var realDigits = real.split('').map(function (d) {
    return parseInt(d);
  });

  while (floatPoint < 0) {
    if (decDigits.length > 0) {
      realDigits.unshift(decDigits.pop());
    } else {
      realDigits.unshift(0);
    }

    floatPoint++;
  }

  while (floatPoint > 0) {
    if (realDigits.length > 0) {
      decDigits.push(realDigits.unshift());
    } else {
      decDigits.push(0);
    }

    floatPoint++;
  }

  var mem = 0,
      i,
      cValue;

  if (floatFixed > realDigits.length) {
    while (realDigits.length < floatFixed) {
      realDigits.push(0);
    }
  } else if (floatFixed < realDigits.length && floatFixed >= 0) {
    i = floatFixed;
    mem = realDigits[i] >= 5 ? 1 : 0;
    realDigits.splice(floatFixed);
    --i;

    while (mem > 0) {
      if (i >= 0) {
        cValue = realDigits[i] + mem;
        realDigits[i] = cValue % 10;
        mem = Math.floor(cValue / 10);
      } else {
        if (decDigits.length + i < 0) decDigits.unshift(0);
        cValue = decDigits[decDigits.length + i] + mem;
        decDigits[decDigits.length + i] = cValue % 10;
        mem = Math.floor(cValue / 10);
      }

      --i;
    }
  }

  while (decDigits.length < decimalPadding) {
    decDigits.unshift(0);
  }

  var decText = numb < 0 ? '-' : '';
  var breadMod = (decDigits.length + 2) % 3;

  if (thousandsSeparator) {
    for (i = 0; i < decDigits.length; ++i) {
      decText += decDigits[i];

      if (i % 3 == breadMod && i + 1 < decDigits.length) {
        decText += thousandsSeparator;
      }
    }
  } else {
    decText += decDigits.join('');
  }

  var realText = realDigits.length == 0 ? '' : decimalSeparator + realDigits.join('');
  return decText + realText;
}

function numberAutoFixed(x, eDelta) {
  eDelta = eDelta || 10;
  eDelta = Math.round(eDelta);
  var e = parseFloat('1e+' + eDelta);
  return Math.round(x * e) / e;
}
/***
 *
 * @param {number} number
 * @param {number} length
 * @returns {string}
 */


function integerZeroPadding(number, length) {
  var res = number + '';

  while (res.length < length) res = '0' + res;

  return res;
}

function harmonicMean(a, b) {
  return 2 / (1 / a + 1 / b);
}
return module.exports;
};

moduleFactories["node_modules/absol/src/String/stringFormat.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/String/stringFormat.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapToLines = wrapToLines;
exports.nonAccentVietnamese = nonAccentVietnamese;
exports.pascalCaseToCamelCase = pascalCaseToCamelCase;
exports.kebabCaseToCamelCase = kebabCaseToCamelCase;
exports.underScoreToCamelCase = underScoreToCamelCase;
exports.camelCaseToPascalCase = camelCaseToPascalCase;
exports.underScoreToPascalCase = underScoreToPascalCase;
exports.kebabCaseToPascalCase = kebabCaseToPascalCase;
exports.pascalCaseToKebabCase = pascalCaseToKebabCase;
exports.camelCaseToKebabCase = camelCaseToKebabCase;
exports.underScoreToKebabCase = underScoreToKebabCase;
exports.pascalCaseToUnderScore = pascalCaseToUnderScore;
exports.pascalCaseToUpperUnderScore = pascalCaseToUpperUnderScore;
exports.camelCaseToUnderScore = camelCaseToUnderScore;
exports.camelCaseToUpperUnderScore = camelCaseToUpperUnderScore;
exports.kebabCaseToUnderScore = kebabCaseToUnderScore;
exports.kebabCaseToUpperUnderScore = kebabCaseToUpperUnderScore;

/**
 * 
 * @param {String} s 
 * @param {Number} maxLength 
 */
function wrapToLines(s, maxLength) {
  var res = [];
  var currentWord = '';
  var currentLine = '';

  for (var i = 0; i < s.length; ++i) {
    if (s[i].match(/\s/)) {
      if (currentWord.length + currentLine.length >= maxLength) {
        if (currentLine.length > 0) {
          res.push(currentLine.trim());
          currentLine = '';
          currentWord = currentWord.trimLeft() + s[i];
        } else {
          currentLine = currentLine + currentWord;
          res.push(currentLine.trim());
          currentLine = '';
          currentWord = '';
        }
      } else {
        currentLine = currentLine + currentWord;
        currentWord = s[i];
      }
    } else {
      currentWord = currentWord + s[i];
    }
  }

  currentLine = (currentLine + currentWord).trim();
  if (currentLine.length > 0) res.push(currentLine);
  return res;
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function nonAccentVietnamese(s) {
  return s.replace(/à|á|ạ|ả|ã|â|ầ|ấ|ậ|ẩ|ẫ|ă|ằ|ắ|ặ|ẳ|ẵ/g, "a").replace(/À|Á|Ạ|Ả|Ã|Â|Ầ|Ấ|Ậ|Ẩ|Ẫ|Ă|Ằ|Ắ|Ặ|Ẳ|Ẵ/g, "A").replace(/è|é|ẹ|ẻ|ẽ|ê|ề|ế|ệ|ể|ễ/g, "e").replace(/È|É|Ẹ|Ẻ|Ẽ|Ê|Ề|Ế|Ệ|Ể|Ễ/g, "E").replace(/ì|í|ị|ỉ|ĩ/g, "i").replace(/Ì|Í|Ị|Ỉ|Ĩ/g, "I").replace(/ò|ó|ọ|ỏ|õ|ô|ồ|ố|ộ|ổ|ỗ|ơ|ờ|ớ|ợ|ở|ỡ/g, "o").replace(/Ò|Ó|Ọ|Ỏ|Õ|Ô|Ồ|Ố|Ộ|Ổ|Ỗ|Ơ|Ờ|Ớ|Ợ|Ở|Ỡ/g, "O").replace(/ù|ú|ụ|ủ|ũ|ư|ừ|ứ|ự|ử|ữ/g, "u").replace(/Ù|Ú|Ụ|Ủ|Ũ|Ư|Ừ|Ứ|Ự|Ử|Ữ/g, "U").replace(/ỳ|ý|ỵ|ỷ|ỹ/g, "y").replace(/Ỳ|Ý|Ỵ|Ỷ|Ỹ/g, "Y").replace(/đ/g, "d").replace(/Đ/g, "D").replace(/\u0300|\u0301|\u0303|\u0309|\u0323/g, "").replace(/\u02C6|\u0306|\u031B/g, "");
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function pascalCaseToCamelCase(s) {
  return s.substr(0, 1).toLowerCase() + s.substr(1);
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function kebabCaseToCamelCase(s) {
  return s.replace(/-+([^-])/g, function (full, c) {
    return c.toUpperCase();
  });
}
/**
 * 
 * @param {String} s 
 * @returns {String} 
 */


function underScoreToCamelCase(s) {
  return s.replace(/(_+)?([^_]+)/g, function (full, underscore, word) {
    if (underscore) {
      if (word) {
        return word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase();
      } else return '';
    } else {
      return word.toLowerCase();
    }

    ;
  });
}
/**
 * 
 * @param {String} s 
 * @returns {String} 
 */


function camelCaseToPascalCase(s) {
  return s.substr(0, 1).toUpperCase() + s.substr(1);
}
/**
 * 
 * @param {String} s 
 * @returns {String} 
 */


function underScoreToPascalCase(s) {
  return s.replace(/(_+|^)?([^_]+)/g, function (full, underscore, word) {
    return word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase();
  });
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function kebabCaseToPascalCase(s) {
  return s.replace(/(-+|^)([^-])/g, function (full, u, c) {
    return c.toUpperCase();
  });
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function pascalCaseToKebabCase(s) {
  return s.replace(/[A-Z][^A-Z]*/g, function (full, index) {
    if (index == 0) return full.toLowerCase();
    return '-' + full.toLowerCase();
  });
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function camelCaseToKebabCase(s) {
  return s.replace(/(^|[A-Z])[^A-Z]*/g, function (full, index) {
    if (index == 0) return full.toLowerCase();
    return '-' + full.toLowerCase();
  });
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function underScoreToKebabCase(s) {
  return s.replace(/(^|_+)([^_]+)/g, function (full, score, word, index) {
    if (index == 0) return word.toLowerCase();
    return '-' + word.toLowerCase();
  });
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function pascalCaseToUnderScore(s) {
  return s.replace(/[A-Z][^A-Z]*/g, function (full, index) {
    if (index == 0) return full.toLowerCase();
    return '_' + full.toLowerCase();
  });
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function pascalCaseToUpperUnderScore(s) {
  return s.replace(/[A-Z][^A-Z]*/g, function (full, index) {
    if (index == 0) return full.toUpperCase();
    return '_' + full.toUpperCase();
  });
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function camelCaseToUnderScore(s) {
  return s.replace(/(^|[A-Z])[^A-Z]*/g, function (full, index) {
    if (index == 0) return full.toLowerCase();
    return '_' + full.toLowerCase();
  });
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function camelCaseToUpperUnderScore(s) {
  return s.replace(/(^|[A-Z])[^A-Z]*/g, function (full, index) {
    if (index == 0) return full.toUpperCase();
    return '_' + full.toUpperCase();
  });
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function kebabCaseToUnderScore(s) {
  return s.replace(/(-+|^)([^-]+)/g, function (full, u, word, index) {
    if (index == 0) return word.toLowerCase();
    return '_' + word.toLowerCase();
  });
}
/**
 * 
 * @param {String} s
 * @returns {String} 
 */


function kebabCaseToUpperUnderScore(s) {
  return s.replace(/(-+|^)([^-]+)/g, function (full, u, word, index) {
    if (index == 0) return word.toUpperCase();
    return '_' + word.toUpperCase();
  });
}

String.nonAccentVietnamese = nonAccentVietnamese;

String.prototype.nonAccentVietnamese = function () {
  return String.nonAccentVietnamese(this);
};
return module.exports;
};

moduleFactories["node_modules/absol/src/Time/datetime.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/Time/datetime.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ddmmyyyy = ddmmyyyy;
exports.yyymmdd = yyymmdd;
exports.formatDateString = formatDateString;
exports.formartDateString = formartDateString;
exports.parseDateString = parseDateString;
exports.prevDate = prevDate;
exports.nextDate = nextDate;
exports.beginOfHour = beginOfHour;
exports.beginOfDay = beginOfDay;
exports.beginOfWeek = beginOfWeek;
exports.beginOfMonth = beginOfMonth;
exports.beginOfYear = beginOfYear;
exports.compareDate = compareDate;
exports.compareMonth = compareMonth;
exports.compareYear = compareYear;
exports.nextMonth = nextMonth;
exports.prevMonth = prevMonth;
exports.daysInMonth = daysInMonth;
exports.parseDateTime = parseDateTime;
exports.formatDateTime = formatDateTime;
exports.LOCAL_DATE_TIME_FORMAT = exports.LOCAL_DATE_FORMAT = exports.DATE_TIME_TOKEN_RGX = exports.formatTokenRegex = exports.shortMonthNames = exports.monthNames = exports.shortDayNames = exports.dayNames = exports.dateFormatList = exports.dateFormat2LocationList = exports.language2LocalDateFormat = exports.MILLIS_PER_MINUTE = exports.MILLIS_PER_HOUR = exports.MILLIS_PER_DAY = void 0;

var _stringFormat = require("../String/stringFormat");

var _int = require("../Math/int");

var MILLIS_PER_DAY = 24 * 3600000;
exports.MILLIS_PER_DAY = MILLIS_PER_DAY;
var MILLIS_PER_HOUR = 3600000;
exports.MILLIS_PER_HOUR = MILLIS_PER_HOUR;
var MILLIS_PER_MINUTE = 60000;
/**
 *
 * @param {Date} date
 * @returns {String}
 */

exports.MILLIS_PER_MINUTE = MILLIS_PER_MINUTE;

function ddmmyyyy(date) {
  var mm = date.getMonth() + 1; // getMonth() is zero-based

  var dd = date.getDate();
  return [(dd > 9 ? '' : '0') + dd, (mm > 9 ? '' : '0') + mm, date.getFullYear()].join('/');
}

;
var language2LocalDateFormat = {
  "af-ZA": "yyyy/mm/dd",
  "am-ET": "d/m/yyyy",
  "ar-AE": "dd/mm/yyyy",
  "ar-BH": "dd/mm/yyyy",
  "ar-DZ": "dd-mm-yyyy",
  "ar-EG": "dd/mm/yyyy",
  "ar-IQ": "dd/mm/yyyy",
  "ar-JO": "dd/mm/yyyy",
  "ar-KW": "dd/mm/yyyy",
  "ar-LB": "dd/mm/yyyy",
  "ar-LY": "dd/mm/yyyy",
  "ar-MA": "dd-mm-yyyy",
  "ar-OM": "dd/mm/yyyy",
  "ar-QA": "dd/mm/yyyy",
  "ar-SA": "dd/mm/yy",
  "ar-SY": "dd/mm/yyyy",
  "ar-TN": "dd-mm-yyyy",
  "ar-YE": "dd/mm/yyyy",
  "arn-CL": "dd-mm-yyyy",
  "as-IN": "dd-mm-yyyy",
  "az-Cyrl-AZ": "dd.mm.yyyy",
  "az-Latn-AZ": "dd.mm.yyyy",
  "ba-RU": "dd.mm.yy",
  "be-BY": "dd.mm.yyyy",
  "bg-BG": "dd.m.yyyy",
  "bn-BD": "dd-mm-yy",
  "bn-IN": "dd-mm-yy",
  "bo-CN": "yyyy/m/d",
  "br-FR": "dd/mm/yyyy",
  "bs-Cyrl-BA": "d.m.yyyy",
  "bs-Latn-BA": "d.m.yyyy",
  "ca-ES": "dd/mm/yyyy",
  "co-FR": "dd/mm/yyyy",
  "cs-CZ": "d.m.yyyy",
  "cy-GB": "dd/mm/yyyy",
  "da-DK": "dd-mm-yyyy",
  "de-AT": "dd.mm.yyyy",
  "de-CH": "dd.mm.yyyy",
  "de-DE": "dd.mm.yyyy",
  "de-LI": "dd.mm.yyyy",
  "de-LU": "dd.mm.yyyy",
  "dsb-DE": "d. m. yyyy",
  "dv-MV": "dd/mm/yy",
  "el-GR": "d/m/yyyy",
  "en-029": "mm/dd/yyyy",
  "en-AU": "d/mm/yyyy",
  "en-BZ": "dd/mm/yyyy",
  "en-CA": "dd/mm/yyyy",
  "en-GB": "dd/mm/yyyy",
  "en-IE": "dd/mm/yyyy",
  "en-IN": "dd-mm-yyyy",
  "en-JM": "dd/mm/yyyy",
  "en-MY": "d/m/yyyy",
  "en-NZ": "d/mm/yyyy",
  "en-PH": "m/d/yyyy",
  "en-SG": "d/m/yyyy",
  "en-TT": "dd/mm/yyyy",
  "en-US": "m/d/yyyy",
  "en-ZA": "yyyy/mm/dd",
  "en-ZW": "m/d/yyyy",
  "es-AR": "dd/mm/yyyy",
  "es-BO": "dd/mm/yyyy",
  "es-CL": "dd-mm-yyyy",
  "es-CO": "dd/mm/yyyy",
  "es-CR": "dd/mm/yyyy",
  "es-DO": "dd/mm/yyyy",
  "es-EC": "dd/mm/yyyy",
  "es-ES": "dd/mm/yyyy",
  "es-GT": "dd/mm/yyyy",
  "es-HN": "dd/mm/yyyy",
  "es-MX": "dd/mm/yyyy",
  "es-NI": "dd/mm/yyyy",
  "es-PA": "mm/dd/yyyy",
  "es-PE": "dd/mm/yyyy",
  "es-PR": "dd/mm/yyyy",
  "es-PY": "dd/mm/yyyy",
  "es-SV": "dd/mm/yyyy",
  "es-US": "m/d/yyyy",
  "es-UY": "dd/mm/yyyy",
  "es-VE": "dd/mm/yyyy",
  "et-EE": "d.mm.yyyy",
  "eu-ES": "yyyy/mm/dd",
  "fa-IR": "mm/dd/yyyy",
  "fi-FI": "d.m.yyyy",
  "fil-PH": "m/d/yyyy",
  "fo-FO": "dd-mm-yyyy",
  "fr-BE": "d/mm/yyyy",
  "fr-CA": "yyyy-mm-dd",
  "fr-CH": "dd.mm.yyyy",
  "fr-FR": "dd/mm/yyyy",
  "fr-LU": "dd/mm/yyyy",
  "fr-MC": "dd/mm/yyyy",
  "fy-NL": "d-m-yyyy",
  "ga-IE": "dd/mm/yyyy",
  "gd-GB": "dd/mm/yyyy",
  "gl-ES": "dd/mm/yy",
  "gsw-FR": "dd/mm/yyyy",
  "gu-IN": "dd-mm-yy",
  "ha-Latn-NG": "d/m/yyyy",
  "he-IL": "dd/mm/yyyy",
  "hi-IN": "dd-mm-yyyy",
  "hr-BA": "d.m.yyyy.",
  "hr-HR": "d.m.yyyy",
  "hsb-DE": "d. m. yyyy",
  "hu-HU": "yyyy. mm. dd.",
  "hy-AM": "dd.mm.yyyy",
  "id-ID": "dd/mm/yyyy",
  "ig-NG": "d/m/yyyy",
  "ii-CN": "yyyy/m/d",
  "is-IS": "d.m.yyyy",
  "it-CH": "dd.mm.yyyy",
  "it-IT": "dd/mm/yyyy",
  "iu-Cans-CA": "d/m/yyyy",
  "iu-Latn-CA": "d/mm/yyyy",
  "ja-JP": "yyyy/mm/dd",
  "ka-GE": "dd.mm.yyyy",
  "kk-KZ": "dd.mm.yyyy",
  "kl-GL": "dd-mm-yyyy",
  "km-KH": "yyyy-mm-dd",
  "kn-IN": "dd-mm-yy",
  "ko-KR": "yyyy-mm-dd",
  "kok-IN": "dd-mm-yyyy",
  "ky-KG": "dd.mm.yy",
  "lb-LU": "dd/mm/yyyy",
  "lo-LA": "dd/mm/yyyy",
  "lt-LT": "yyyy.mm.dd",
  "lv-LV": "yyyy.mm.dd.",
  "mi-NZ": "dd/mm/yyyy",
  "mk-MK": "dd.mm.yyyy",
  "ml-IN": "dd-mm-yy",
  "mn-MN": "yy.mm.dd",
  "mn-Mong-CN": "yyyy/m/d",
  "moh-CA": "m/d/yyyy",
  "mr-IN": "dd-mm-yyyy",
  "ms-BN": "dd/mm/yyyy",
  "ms-MY": "dd/mm/yyyy",
  "mt-MT": "dd/mm/yyyy",
  "nb-NO": "dd.mm.yyyy",
  "ne-NP": "m/d/yyyy",
  "nl-BE": "d/mm/yyyy",
  "nl-NL": "d-m-yyyy",
  "nn-NO": "dd.mm.yyyy",
  "nso-ZA": "yyyy/mm/dd",
  "oc-FR": "dd/mm/yyyy",
  "or-IN": "dd-mm-yy",
  "pa-IN": "dd-mm-yy",
  "pl-PL": "yyyy-mm-dd",
  "prs-AF": "dd/mm/yy",
  "ps-AF": "dd/mm/yy",
  "pt-BR": "d/m/yyyy",
  "pt-PT": "dd-mm-yyyy",
  "qut-GT": "dd/mm/yyyy",
  "quz-BO": "dd/mm/yyyy",
  "quz-EC": "dd/mm/yyyy",
  "quz-PE": "dd/mm/yyyy",
  "rm-CH": "dd/mm/yyyy",
  "ro-RO": "dd.mm.yyyy",
  "ru-RU": "dd.mm.yyyy",
  "rw-RW": "m/d/yyyy",
  "sa-IN": "dd-mm-yyyy",
  "sah-RU": "mm.dd.yyyy",
  "se-FI": "d.m.yyyy",
  "se-NO": "dd.mm.yyyy",
  "se-SE": "yyyy-mm-dd",
  "si-LK": "yyyy-mm-dd",
  "sk-SK": "d. m. yyyy",
  "sl-SI": "d.m.yyyy",
  "sma-NO": "dd.mm.yyyy",
  "sma-SE": "yyyy-mm-dd",
  "smj-NO": "dd.mm.yyyy",
  "smj-SE": "yyyy-mm-dd",
  "smn-FI": "d.m.yyyy",
  "sms-FI": "d.m.yyyy",
  "sq-AL": "yyyy-mm-dd",
  "sr-Cyrl-BA": "d.m.yyyy",
  "sr-Cyrl-CS": "d.m.yyyy",
  "sr-Cyrl-ME": "d.m.yyyy",
  "sr-Cyrl-RS": "d.m.yyyy",
  "sr-Latn-BA": "d.m.yyyy",
  "sr-Latn-CS": "d.m.yyyy",
  "sr-Latn-ME": "d.m.yyyy",
  "sr-Latn-RS": "d.m.yyyy",
  "sv-FI": "d.m.yyyy",
  "sv-SE": "yyyy-mm-dd",
  "sw-KE": "m/d/yyyy",
  "syr-SY": "dd/mm/yyyy",
  "ta-IN": "dd-mm-yyyy",
  "te-IN": "dd-mm-yy",
  "tg-Cyrl-TJ": "dd.mm.yy",
  "th-TH": "d/m/yyyy",
  "tk-TM": "dd.mm.yy",
  "tn-ZA": "yyyy/mm/dd",
  "tr-TR": "dd.mm.yyyy",
  "tt-RU": "dd.mm.yyyy",
  "tzm-Latn-DZ": "dd-mm-yyyy",
  "ug-CN": "yyyy-m-d",
  "uk-UA": "dd.mm.yyyy",
  "ur-PK": "dd/mm/yyyy",
  "uz-Cyrl-UZ": "dd.mm.yyyy",
  "uz-Latn-UZ": "dd/mm yyyy",
  "vi-VN": "dd/mm/yyyy",
  "wo-SN": "dd/mm/yyyy",
  "xh-ZA": "yyyy/mm/dd",
  "yo-NG": "d/m/yyyy",
  "zh-CN": "yyyy/m/d",
  "zh-HK": "d/m/yyyy",
  "zh-MO": "d/m/yyyy",
  "zh-SG": "d/m/yyyy",
  "zh-TW": "yyyy/m/d",
  "zu-ZA": "yyyy/mm/dd"
};
exports.language2LocalDateFormat = language2LocalDateFormat;
var dateFormat2LocationList = Object.keys(language2LocalDateFormat).reduce(function (ac, cr) {
  ac[language2LocalDateFormat[cr]] = ac[language2LocalDateFormat[cr]] || [];
  ac[language2LocalDateFormat[cr]].push(cr);
  return ac;
}, {});
exports.dateFormat2LocationList = dateFormat2LocationList;
var dateFormatList = Object.keys(dateFormat2LocationList);
/**
 *
 * @param {Date} date
 * @returns {String}
 */

exports.dateFormatList = dateFormatList;

function yyymmdd(date) {
  var mm = date.getMonth() + 1; // getMonth() is zero-based

  var dd = date.getDate();
  return [date.getFullYear(), (mm > 9 ? '' : '0') + mm, (dd > 9 ? '' : '0') + dd].join('/');
}

;
var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
exports.dayNames = dayNames;
var shortDayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
exports.shortDayNames = shortDayNames;
var monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
exports.monthNames = monthNames;
var shortMonthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
exports.shortMonthNames = shortMonthNames;
var formatTokenRegex = /([,.\-\/])|([a-zA-Z0-9]+)/g; //more

exports.formatTokenRegex = formatTokenRegex;
var DATE_TIME_TOKEN_RGX = /([^\s.\/:\-,]+)|([.\/:\-,]+)/i;
/**
 *
 * @param {Date} date
 * @param {String=} format
 * @returns {String}
 */

exports.DATE_TIME_TOKEN_RGX = DATE_TIME_TOKEN_RGX;

function formatDateString(date, format) {
  format = format || 'dd/mm/yyyy';
  var dt = date.getDate();
  var day = date.getDay();
  var month = date.getMonth();
  var year = date.getFullYear();
  return format.replace(formatTokenRegex, function (x) {
    switch (x) {
      case "dddd":
        return dayNames[day];

      case "ddd":
        return shortDayNames[day];

      case "dd":
        return dt < 10 ? '0' + dt : '' + dt;

      case "d":
        return '' + dt;

      case "mmmm":
        return monthNames[month];

      case "mmm":
        return shortMonthNames[month];

      case "mm":
        return month + 1 < 10 ? '0' + (month + 1) : '' + (month + 1);

      case "m":
        return '' + (month + 1);

      case 'yy':
        return (year + '').match(/..$/)[0];

      case 'yyyy':
        return year + '';

      default:
        return x;
    }
  });
}

var LOCAL_DATE_FORMAT = function () {
  var d = new Date(2021, 4, 4);
  var s = d.toLocaleDateString();
  var fm = s.replace(new RegExp(DATE_TIME_TOKEN_RGX.source, 'g'), function (token) {
    switch (token) {
      case '2021':
        return 'yyyy';

      case '5':
        return 'M';

      case '05':
        return 'MM';

      case '4':
        return 'd';

      case '04':
        return 'dd';

      default:
        return token;
    }
  });
  return fm;
}();

exports.LOCAL_DATE_FORMAT = LOCAL_DATE_FORMAT;

var LOCAL_DATE_TIME_FORMAT = function () {
  var d = new Date(2021, 4, 4, 6, 7, 3);
  var s = d.toLocaleString();
  var fm = s.replace(new RegExp(DATE_TIME_TOKEN_RGX.source, 'g'), function (token) {
    switch (token) {
      case '2021':
        return 'yyyy';

      case '5':
        return 'M';

      case '05':
        return 'MM';

      case '4':
        return 'd';

      case '04':
        return 'dd';

      case '06':
        if (new Date(2021, 4, 4, 18, 7, 3).toLocaleString().indexOf(18) >= 0) return 'HH';
        return 'hh';

      case '6':
        return 'h';

      case '07':
        return 'mm';

      case '7':
        return 'm';

      case '03':
        return 'ss';

      case '3':
        return 's';

      case 'AM':
        return 'a';

      default:
        return token;
    }
  });
  return fm;
}();

exports.LOCAL_DATE_TIME_FORMAT = LOCAL_DATE_TIME_FORMAT;

function formartDateString() {
  window.ALogger.warn("spelled incorrectly: formartDateString");
  return formatDateString.apply(null, arguments);
}
/**
 *
 * @param {String} text
 * @param {String} format
 * @returns {Date}
 */


function parseDateString(text, format) {
  text = (0, _stringFormat.nonAccentVietnamese)(text).toLowerCase();
  format = (0, _stringFormat.nonAccentVietnamese)(format).toLowerCase();
  var textTokens = text.match(formatTokenRegex) || [];
  var formatTokens = format.match(formatTokenRegex) || [];
  var year = new Date().getFullYear();
  var month = 0;
  var day = 1;
  var n = Math.min(textTokens.length, formatTokens.length);
  var textToken;
  var formatToken;

  for (var i = 0; i < n; ++i) {
    textToken = textTokens[i];
    formatToken = formatTokens[i];

    switch (formatToken) {
      case "dd":
        day = parseInt(textToken);
        break;

      case "d":
        day = parseInt(textToken);
        break;

      case "mmmm":
        month = monthNames.indexOf(textToken.substr(0, 1).toUpperCase() + textToken.substr(1).toLowerCase());
        break;

      case "mmm":
        month = shortMonthNames.indexOf(textToken.substr(0, 1).toUpperCase() + textToken.substr(1).toLowerCase());
        break;

      case "mm":
        month = parseInt(textToken) - 1;
        break;

      case "m":
        month = parseInt(textToken) - 1;
        break;

      case 'yy':
        year = Math.floor(new Date().getFullYear() / 100) * 100 + parseInt(textToken);
        break;

      case 'yyyy':
        year = parseInt(textToken);
        break;

      default:
        if (textToken !== formatToken) throw new Error('Unexpected token ' + textToken);
    }
  }

  if (isNaN(year)) throw new Error('Invalid year');

  if (isNaN(month) && month !== -1) {
    throw new Error('Invalid month');
  } else {
    month = Math.max(0, Math.min(11, month));
  }

  if (!isNaN(day)) {
    day = Math.max(1, Math.min(31, day));

    if (!isNaN(month)) {
      day = Math.min(daysInMonth(2000, month), day);
      if (!isNaN(year)) day = Math.min(daysInMonth(year, month), day);
    }
  } else {
    throw new Error('Invalid day');
  }

  return new Date(year, month, day);
}
/**
 * @param {Date} date
 * @return {Date}
 */


function prevDate(date) {
  return new Date(date.getTime() - MILLIS_PER_DAY);
}
/**
 * @param {Date} date
 * @return {Date}
 */


function nextDate(date) {
  return new Date(date.getTime() + MILLIS_PER_DAY);
}
/**
 * @param {Date} date
 * @return {Date} date at 00:00
 */


function beginOfHour(date) {
  var res = new Date(date.getTime());
  res.setMilliseconds(0);
  res.setSeconds(0);
  res.setMinutes(0);
  return res;
}
/**
 * @param {Date} date
 * @param {Boolean=} gmt default:false
 * @return {Date} date at 00:00
 */


function beginOfDay(date, gmt) {
  var res = new Date(date.getTime());
  res.setMilliseconds(0);
  res.setSeconds(0);
  res.setMinutes(0);
  if (gmt) res.setUTCHours(0);else res.setHours(0);
  return res;
}

;
/**
 * @param {Date} date
 * @param {Boolean=} gmt default:false
 * @param {number=} begin default:0
 * @return {Date} date at 00:00
 */

function beginOfWeek(date, gmt, begin) {
  begin = begin || 0;
  var res = beginOfDay(date, gmt);

  while ((gmt ? res.getUTCDay() : res.getDay()) !== begin) {
    res = prevDate(res);
  }

  return res;
}

;
/**
 * @param {Date} date
 * @param {Boolean=} gmt default:false
 * @return {Date} date at 00:00 AM
 */

function beginOfMonth(date, gmt) {
  gmt = !!gmt;
  var d = gmt ? date.getUTCDate() : date.getDate();
  var m = gmt ? date.getUTCMonth() : date.getMonth();
  var y = gmt ? date.getUTCFullYear() : date.getFullYear();
  var res = new Date();
  if (gmt) res.setUTCFullYear(y, m, 1);else res.setFullYear(y, m, 1);
  return beginOfDay(res, gmt);
}

;
/**
 * @param {Date} date
 * @param {Boolean=} gmt default:false
 * @return {Date} date at 00:00 AM
 */

function beginOfYear(date, gmt) {
  gmt = !!gmt;
  var d = gmt ? date.getUTCDate() : date.getDate();
  var m = gmt ? date.getUTCMonth() : date.getMonth();
  var y = gmt ? date.getUTCFullYear() : date.getFullYear();
  var res = new Date();
  if (gmt) res.setUTCFullYear(y, 0, 1);else res.setFullYear(y, 0, 1);
  return beginOfDay(res, gmt);
}

;
/**
 * @param {Date} date0
 * @param {Date} date1
 * @param {Boolean=} gmt default:false
 * @return {number}
 */

function compareDate(date0, date1, gmt) {
  var date0 = beginOfDay(date0, !!gmt);
  var date1 = beginOfDay(date1, !!gmt);
  return (date0.getTime() - date1.getTime()) / 86400000;
}
/**
 * @param {Date} date0
 * @param {Date} date1
 * @param {Boolean=} gmt default:false
 * @return {number}
 */


function compareMonth(date0, date1, gmt) {
  gmt = !!gmt;
  var m0 = gmt ? date0.getUTCMonth() : date0.getMonth();
  var y0 = gmt ? date0.getUTCFullYear() : date0.getFullYear();
  var m1 = gmt ? date1.getUTCMonth() : date1.getMonth();
  var y1 = gmt ? date1.getUTCFullYear() : date1.getFullYear();
  return (y0 - y1) * 12 + (m0 - m1);
}
/***
 *
 * @param {Date} date0
 * @param {Date} date1
 * @param {boolean=}gmt
 * @returns {number}
 */


function compareYear(date0, date1, gmt) {
  gmt = !!gmt;
  var y0 = gmt ? date0.getUTCFullYear() : date0.getFullYear();
  var y1 = gmt ? date1.getUTCFullYear() : date1.getFullYear();
  return y0 - y1;
}
/**
 *
 * @param {Date} date
 * @returns {Date}
 */


function nextMonth(date) {
  var m = date.getMonth();
  var y = date.getFullYear();

  if (m == 11) {
    return new Date(y + 1, 0, 1, 0, 0, 0, 0);
  } else {
    return new Date(y, m + 1, 1, 0, 0, 0, 0);
  }
}
/**
 *
 * @param {Date} date
 * @returns {Date}
 */


function prevMonth(date) {
  var m = date.getMonth();
  var y = date.getFullYear();

  if (m == 0) {
    return new Date(y - 1, 11, 1, 0, 0, 0, 0);
  } else {
    return new Date(y, m - 1, 1, 0, 0, 0, 0);
  }
}
/**
 *
 * @param {Number} year
 * @param {Number} month
 * @returns {Number}
 */


function daysInMonth(year, month) {
  var start = new Date(year, month, 1);
  var end = nextMonth(start);
  return compareDate(end, start);
}
/****
 *
 * @param text
 * @param format support d, M, Y, Q
 * @returns {Date}
 */


function parseDateTime(text, format) {
  var tokenMap = {};
  var txtRgx = new RegExp(DATE_TIME_TOKEN_RGX.source, 'g');
  var fmRgx = new RegExp(DATE_TIME_TOKEN_RGX.source, 'g');
  var tkMatched, fmMatched;
  tkMatched = txtRgx.exec(text);
  fmMatched = fmRgx.exec(format);
  var tkText, fmText;

  while (tkMatched && fmMatched) {
    tkText = tkMatched[0];
    fmText = fmMatched[0];

    switch (fmText) {
      case 'd':
      case 'dd':
        tokenMap.day = parseInt(tkText, 10);
        break;

      case 'M':
      case 'MM':
        tokenMap.month = parseInt(tkText, 10) - 1;
        break;

      case 'y':
      case 'yyyy':
        tokenMap.year = parseInt(tkText, 10);
        break;

      case 'h':
      case 'hh':
      case 'H':
      case 'HH':
        tokenMap.hour = parseInt(tkText, 10);
        break;

      case 'm':
      case 'mm':
        tokenMap.minute = parseInt(tkText, 10);
        break;

      case 'a':
        if (tkText === 'AM' || tkText === 'PM') tokenMap.period = tkText;else throw new Error('Invalid period(a):' + tkText);
        break;

      case 'Q':
      case 'QQ':
        tokenMap.month = (parseInt(tkText, 10) - 1) * 3;
        break;

      default:
        if (tkText !== fmText) {
          throw new Error('Unexpected token ' + JSON.stringify(tkText) + ' at ' + tkMatched.index + ', expected ' + fmText);
        }

    }

    tkMatched = txtRgx.exec(text);
    fmMatched = fmRgx.exec(format);
  }

  if (tokenMap.period) {
    if (tokenMap.period === 'AM' && tokenMap.hour === 12) tokenMap.hour = 0;else if (tokenMap.period === "PM" && tokenMap.hour < 12) tokenMap.hour += 12;
  }

  var paramNames = ['year', 'month', 'day', 'hour', 'minute', 'second'];
  var paramShortNames = ['y', 'M', 'd', 'h', 'm', 's'];
  var paramDefaultValues = [new Date().getFullYear(), 0, 1, 0, 0, 0];
  var resParam = paramDefaultValues.slice();
  var paramList = paramNames.reduce(function (ac, cr, i) {
    var sN = paramShortNames[i];

    if (cr in tokenMap) {
      ac += sN;
    }

    return ac;
  }, '');
  var paramName;

  for (var i = 0; i < paramNames.length; ++i) {
    paramName = paramNames[i];
    resParam[i] = tokenMap[paramName] === undefined ? paramDefaultValues[i] : tokenMap[paramName];
  }

  switch (paramList) {
    case 'hm':
      resParam.splice(1, 2, new Date().getMonth(), new Date().getDate());
      break;
  }

  return new Date(resParam[0], resParam[1], resParam[2], resParam[3], resParam[4], resParam[5]);
}

function formatDateTime(date, format) {
  var fmRgx = new RegExp(DATE_TIME_TOKEN_RGX.source, 'g');
  return format.replace(fmRgx, function (s) {
    var res = s;

    switch (s) {
      case 'd':
      case 'dd':
        res = (0, _int.integerZeroPadding)(date.getDate(), s.length);
        break;

      case 'M':
      case 'MM':
        res = (0, _int.integerZeroPadding)(date.getMonth() + 1, s.length);
        break;

      case 'MMM':
        res = shortMonthNames[date.getMonth()];
        break;

      case 'MMMM':
        res = monthNames[date.getMonth()];
        break;

      case 'y':
      case 'yyyy':
        res = (0, _int.integerZeroPadding)(date.getFullYear(), s.length);
        break;

      case 'yy':
        res = (0, _int.integerZeroPadding)(date.getFullYear() % 100, s.length);
        break;

      case 'a':
        res = date.getHours() < 12 ? "AM" : "PM";
        break;

      case "H":
      case 'HH':
        res = (0, _int.integerZeroPadding)(date.getHours(), s.length);
        break;

      case 'h':
      case 'hh':
        res = (0, _int.integerZeroPadding)(1 + (date.getHours() - 1) % 12, s.length);
        break;

      case 'm':
      case 'mm':
        res = (0, _int.integerZeroPadding)(date.getMinutes(), s.length);
        break;

      case 'Q':
      case 'QQ':
        res = (0, _int.integerZeroPadding)(Math.floor(date.getMonth() / 3) + 1, s.length);
        break;
    }

    return res;
  });
}

function test() {
  var y = new Date().getFullYear();
  var M = new Date().getMonth();
  var d = new Date().getDate();
  [['22/12/2021', 'dd/MM/yyyy', new Date(2021, 11, 22)], ['12:55 AM', 'hh:mm a', new Date(y, M, d, 0, 55)], ['12:55 PM', 'hh:mm a', new Date(y, M, d, 12, 55)], ['22-12', 'dd-MM', new Date(y, 11, 22, 0, 0)], ['2020-11', 'yyyy-MM', new Date(2020, 10, 1, 0, 0)], ['11-2020', 'MM-yyyy', new Date(2020, 10, 1, 0, 0)], ['quarter 04, 2020', 'quarter QQ, yyyy', new Date(2020, 9, 1, 0, 0)]].forEach(function (pr) {
    var d = parseDateTime(pr[0], pr[1]);

    if ((d && d.getTime()) === pr[2].getTime()) {
      console.info("Pass ", pr);
    } else {
      console.error("Text fail with ", pr.slice(0, 2), ', expect ', pr[2], ', return ' + d);
    }
  });
  console.log(formatDateTime(new Date(), "Mùa QQ, năm y, H giờ m phút"));
} // setTimeout(test, 100);
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/DomSignal.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/DomSignal.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Dom = _interopRequireDefault(require("./Dom"));

var _EventEmitter = _interopRequireDefault(require("./EventEmitter"));

var _AElement = _interopRequireDefault(require("./AElement"));


/***
 *
 * @extends EventEmitter
 * @param {AElement} attachHookElt
 * @constructor
 */
function DomSignal(attachHookElt) {
  _EventEmitter.default.call(this);

  this.signals = {};
  this.ev_attached = this.ev_attached.bind(this);
  this.$attachhook = attachHookElt || _Dom.default.ShareInstance._('attachhook');
  this.$attachhookParent = attachHookElt && attachHookElt.parentElement || null;
  this.$attachhook.on('attached', this.ev_attached);
}

Object.defineProperties(DomSignal.prototype, Object.getOwnPropertyDescriptors(_EventEmitter.default.prototype));
DomSignal.prototype.constructor = DomSignal;

DomSignal.prototype.execSignal = function () {
  var signals = this.signals;

  if (this.$attachhook) {
    this.$attachhook.remove();
    this.$attachhook.resetState();
  }

  this.signals = {};

  for (var name in signals) {
    this.fire.apply(this, [name].concat(signals[name]));
  }
};

DomSignal.prototype.emit = function (name) {
  this.signals[name] = Array.prototype.slice.call(arguments, 1);

  if (!this.$attachhookParent) {
    this.$attachhookParent = document.body;
  }

  if (!this.$attachhook.parentElement) {
    this.$attachhookParent.appendChild(this.$attachhook);
  }
};

DomSignal.prototype.ev_attached = function () {
  this.execSignal();
};

var _default = DomSignal;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Scroller.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Scroller.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VScroller = VScroller;
exports.HScroller = HScroller;
exports.Scrollbar = Scrollbar;
exports.VScrollbar = VScrollbar;
exports.HScrollbar = HScrollbar;

require("../css/scroller.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _Element = _interopRequireDefault(require("absol/src/HTML5/Element"));

var _int = require("absol/src/Math/int");


var _ = _ACore.default._;
var $ = _ACore.default.$;

_ACore.default.$scrollStyle = function () {
  var element = _('style#vscroller-style');

  element.innerHTML = ['.absol-vscroller-viewport{ margin-right: ' + -17 + 'px;  min-width: calc(100% + ' + 17 + 'px);}', '.absol-hscroller-viewport{ margin-bottom: ' + -17 + 'px;  min-height: calc(100% + ' + 17 + 'px);}'].join('\n');
  document.head.appendChild(element);

  _Dom.default.getScrollSize().then(function (size) {
    element.innerHTML = ['.absol-vscroller-viewport{ margin-right: ' + -size.width + 'px; min-width: calc(100% + ' + size.width + 'px);}', '.absol-hscroller-viewport{ margin-bottom: ' + -size.height + 'px; min-height: calc(100% + ' + size.height + 'px);}'].join('\n');
  });

  return element;
}();

function VScroller() {
  var thisVS = this;
  this.$attachHook = $('attachhook', this);
  this.sync = new Promise(function (rs) {
    thisVS.$attachHook.once('error', function () {
      rs();
    });
  });
  this.$attachHook.on('error', function () {
    thisVS.requestUpdateSize();
  });
  this.$vscrollbar = $('vscrollbar', this).on('scroll', this.eventHandler.scrollScrollbar);
  this.$viewport = $('.absol-vscroller-viewport', this).on('scroll', this.eventHandler.scrollViewport);

  _OOP.default.extends(thisVS.$viewport, {
    removeChild: function () {
      this.super.apply(this, arguments);
      thisVS.requestUpdateSize();
      return thisVS;
    }
  });
}

VScroller.tag = 'vscroller';

VScroller.render = function () {
  return _({
    class: 'absol-vscroller',
    child: ['.absol-vscroller-viewport', {
      class: ['absol-scrollbar-container', 'vertical'],
      child: 'vscrollbar'
    }, 'attachhook']
  });
};

VScroller.prototype.requestUpdateSize = function () {
  // return;
  if (this._isRequestingUpdateSize) return this.sync;
  this._isRequestingUpdateSize = true;
  this.sync = this.sync.then(function () {
    this.$vscrollbar.outerHeight = this.$viewport.clientHeight;
    this.$vscrollbar.innerHeight = this.$viewport.scrollHeight - 2;
    this.$vscrollbar.innerOffset = this.$viewport.scrollTop;

    if (this.$vscrollbar.innerHeight <= this.$vscrollbar.outerHeight) {
      this.$vscrollbar.hidden = true;
      this.addClass('disabled');
    } else {
      this.removeClass('disabled');
      this.$vscrollbar.hidden = false;
    }

    this._isRequestingUpdateSize = false;
  }.bind(this));
  return this.sync;
};

VScroller.prototype.init = function (props) {
  this.super(props);
  this.requestUpdateSize();
};

VScroller.prototype.addChild = function () {
  var res = this.$viewport.addChild.apply(this.$viewport, arguments);
  this.requestUpdateSize();
  return res;
};

VScroller.prototype.clearChild = function () {
  var res = this.$viewport.clearChild.apply(this.$viewport, arguments);
  this.requestUpdateSize();
  return res;
};

VScroller.prototype.addChildBefore = function () {
  var res = this.$viewport.addChildBefore.apply(this.$viewport, arguments);
  this.requestUpdateSize();
  return res;
};

VScroller.prototype.addChildAfter = function () {
  var res = this.$viewport.addChildAfter.apply(this.$viewport, arguments);
  this.requestUpdateSize();
  return res;
};

VScroller.prototype.findChildAfter = function () {
  return this.$viewport.findChildAfter.apply(this.$viewport, arguments);
};

VScroller.prototype.findChildBefore = function () {
  return this.$viewport.findChildBefore.apply(this.$viewport, arguments);
};

VScroller.prototype.removeChild = function () {
  var res = this.$viewport.removeChild.apply(this.$viewport, arguments);
  this.requestUpdateSize();
  return res;
};

VScroller.prototype.scrollInto = function (element, padding, scrollTime, beforFrame, afterFrame) {
  padding = padding || 0;
  scrollTime = scrollTime || 0;
  var frameCount = Math.ceil(scrollTime / 15 + 1);
  var self = this;

  function onFrame() {
    beforFrame && beforFrame();
    var elementBound = element.getBoundingClientRect();
    var viewportBound = self.$viewport.getBoundingClientRect();
    var currentScrollTop = self.$viewport.scrollTop;
    var newScrollTop = currentScrollTop;

    if (elementBound.bottom + padding > viewportBound.bottom) {
      newScrollTop = currentScrollTop + (elementBound.bottom + padding - viewportBound.bottom) / (Math.log(frameCount) + 1);
    }

    if (elementBound.top - padding < viewportBound.top) {
      newScrollTop = currentScrollTop - (viewportBound.top - (elementBound.top - padding)) / (Math.log(frameCount) + 1);
    }

    if (newScrollTop != currentScrollTop) {
      self.$viewport.scrollTop = newScrollTop;
    }

    afterFrame && afterFrame();
    frameCount--;
    if (frameCount > 0) setTimeout(onFrame, 15);
  }

  if (_Element.default.prototype.isDescendantOf.call(element, this.$viewport)) {
    onFrame();
  }
};

VScroller.prototype.scrollBy = function (dy, duration) {
  duration = duration || 0;
  var frameCount = Math.ceil(duration / 20);
  var timeOut = duration / frameCount;
  var i = 0;
  var self = this;
  var start = self.$viewport.scrollTop;
  var end = start + dy;

  function onFrame() {
    self.$viewport.scrollTop = Math.max((0, _int.map)(i, 0, frameCount, start, end), 0);
    ++i;
    if (i <= frameCount) setTimeout(onFrame, timeOut);
  }

  onFrame();
};

VScroller.eventHandler = {};

VScroller.eventHandler.scrollViewport = function (event) {
  this.$vscrollbar.outerHeight = this.$viewport.clientHeight;
  this.$vscrollbar.innerHeight = this.$viewport.scrollHeight;
  this.$vscrollbar.innerOffset = this.$viewport.scrollTop;
};

VScroller.eventHandler.scrollScrollbar = function (event) {
  this.$viewport.scrollTop = this.$vscrollbar.innerOffset;
};

function HScroller() {
  var thisHS = this;
  this.$attachHook = $('attachhook', this).on('error', function () {
    this.requestUpdateSize = this.requestUpdateSize || thisHS.requestUpdateSize.bind(thisHS);

    _Dom.default.addToResizeSystem(this);
  });
  this.sync = new Promise(function (rs, rj) {
    thisHS.$attachHook.once('error', rs);
  });
  this.$hscrollbar = $('hscrollbar', this).on('scroll', this.eventHandler.scrollScrollbar);
  this.$viewport = $('.absol-hscroller-viewport', this).on('scroll', this.eventHandler.scrollViewport);

  _OOP.default.extends(this.$viewport, {
    removeChild: function () {
      this.super.apply(this, arguments);
      thisHS.requestUpdateSize();
      return thisHS;
    }
  });
}

HScroller.tag = 'hscroller';

HScroller.render = function () {
  return _({
    class: 'absol-hscroller',
    child: ['.absol-hscroller-viewport', {
      class: ['absol-scrollbar-container', 'horizontal'],
      child: 'hscrollbar'
    }, 'attachhook']
  });
};

HScroller.eventHandler = {};

HScroller.eventHandler.scrollViewport = function (event) {
  this.$hscrollbar.outerWidth = this.$viewport.clientWidth;
  this.$hscrollbar.innerWidth = this.$viewport.scrollWidth;
  this.$hscrollbar.innerOffset = this.$viewport.scrollLeft;
};

HScroller.eventHandler.scrollScrollbar = function (event) {
  this.$viewport.scrollLeft = this.$hscrollbar.innerOffset;
};

Object.assign(HScroller.prototype, VScroller.prototype);

HScroller.prototype.requestUpdateSize = function () {
  // return;
  if (this._isRequestingUpdateSize) return this.sync;
  this._isRequestingUpdateSize = true;
  this.sync = this.sync.then(function () {
    this.$hscrollbar.outerWidth = this.$viewport.clientWidth;
    this.$hscrollbar.innerWidth = this.$viewport.scrollWidth;
    this.$hscrollbar.innerOffset = this.$viewport.scrollLeft;

    if (this.$hscrollbar.innerWidth <= this.$hscrollbar.outerWidth) {
      this.$hscrollbar.hidden = true;
      this.addClass('disabled');
    } else {
      this.removeClass('disabled');
      this.$hscrollbar.hidden = false;
    }

    this._isRequestingUpdateSize = false;
  }.bind(this));
  return this.sync;
};

HScroller.prototype.scrollInto = function (element) {
  if (_Element.default.prototype.isDescendantOf.call(element, this.$viewport)) {
    var elementBound = element.getBoundingClientRect();
    var viewportBound = this.$viewport.getBoundingClientRect();
    var currentScrollLeft = this.$viewport.scrollLeft;
    var newScrollLeft = currentScrollLeft;

    if (elementBound.right > viewportBound.right) {
      newScrollLeft = currentScrollLeft + (elementBound.right - viewportBound.right);
    }

    if (elementBound.left < viewportBound.left) {
      newScrollLeft = currentScrollLeft - (viewportBound.left - elementBound.left);
    }

    if (newScrollLeft != currentScrollLeft) {
      this.$viewport.scrollLeft = newScrollLeft;
    }
  }
};

function Scrollbar() {
  var thisSB = this;
  this.$button = $('.absol-scrollbar-button', this);
  this.on('active', function () {
    if (!thisSB.$forceModal) thisSB.$forceModal = _('.absol-scrollbar-force-modal');
    thisSB.$forceModal.addTo(document.body);
  }).on('deactive', function () {
    setTimeout(function () {
      thisSB.$forceModal.remove();
    }, 30);
  });
}

Scrollbar.tag = 'scrollbar';

Scrollbar.render = function () {
  return _({
    class: ['absol-scrollbar'],
    extendEvent: ['scroll', 'active', 'deactive'],
    child: '.absol-scrollbar-button'
  });
};

Scrollbar.property = {};
Scrollbar.property.hidden = {
  set: function (value) {
    value = !!value;

    if (value != this._hidden) {
      this._hidden = value;
      if (value) this.addClass('absol-hidden');else this.removeClass('absol-hidden');
    }
  },
  get: function () {
    return this.containsClass('absol-hidden');
  }
};

function VScrollbar() {
  var thisVS = this;
  var top0, innerOffset0;

  var pointerMoveEventHandler = function (event) {
    event.preventDefault();
    var dy = event.clientY - top0;
    var newInnerOffset = innerOffset0 + dy * (thisVS.innerHeight / thisVS.outerHeight) * (thisVS.outerHeight / thisVS.getBoundingClientRect().height);
    if (newInnerOffset + thisVS.outerHeight > thisVS.innerHeight) newInnerOffset = thisVS.innerHeight - thisVS.outerHeight;
    if (newInnerOffset < 0) newInnerOffset = 0;
    thisVS.innerOffset = newInnerOffset; //todo

    event.innerOffset = newInnerOffset;
    thisVS.emit('scroll', event);
  };

  var finishEventHandler = function (event) {
    var body = $(document.body);
    body.off('pointerleave', finishEventHandler);
    body.off('pointerup', finishEventHandler);
    body.off('pointermove', pointerMoveEventHandler);
    thisVS.removeClass('absol-active');
    thisVS.emit('deactive', {
      type: 'deactive',
      originEvent: event,
      tagert: thisVS
    });
  };

  var pointerDownEventHandler = function (event) {
    var boundRes = thisVS.getBoundingClientRect();
    var boundButton = thisVS.$button.getBoundingClientRect();
    top0 = event.clientY;

    if (event.target == thisVS.$button) {
      innerOffset0 = thisVS.innerOffset;
    } else {
      var newInnerOffset = (0, _int.map)(top0 - boundButton.height / 2 - boundRes.top, 0, boundRes.height, 0, thisVS.innerHeight);
      if (newInnerOffset + thisVS.outerHeight > thisVS.innerHeight) newInnerOffset = thisVS.innerHeight - thisVS.outerHeight;
      if (newInnerOffset < 0) newInnerOffset = 0;
      thisVS.innerOffset = newInnerOffset; //todo

      event.innerOffset = newInnerOffset;
      innerOffset0 = newInnerOffset;
      thisVS.emit('scroll', event);
    }

    var body = $(document.body);
    body.on('pointerleave', finishEventHandler);
    body.on('pointerup', finishEventHandler);
    body.on('pointermove', pointerMoveEventHandler);
    thisVS.addClass('absol-active');
    thisVS.emit('active', {
      type: 'active',
      originEvent: event,
      tagert: thisVS
    });
  };

  this.on('pointerdown', pointerDownEventHandler, true);
}

VScrollbar.tag = 'vscrollbar';

VScrollbar.render = function () {
  return _({
    tag: 'scrollbar',
    class: 'absol-vscrollbar'
  }, true);
};

VScrollbar.prototype.updateValue = function () {
  this.$button.addStyle('height', Math.min(this.outerHeight / this.innerHeight, 1) * 100 + '%');
  this.$button.addStyle('top', this.innerOffset / this.innerHeight * 100 + '%');
};

VScrollbar.property = {
  innerOffset: {
    set: function (value) {
      value = value || 0;

      if (this._innerOffset != value) {
        this._innerOffset = value;
        this.updateValue();
      }
    },
    get: function () {
      return this._innerOffset || 0;
    }
  },
  innerHeight: {
    set: function (value) {
      value = value || 1;
      value = Math.max(value, 1);

      if (this._innerHeight != value) {
        this._innerHeight = value;
        this.updateValue();
      }
    },
    get: function () {
      return this._innerHeight || 1;
    }
  },
  outerHeight: {
    set: function (value) {
      value = value || 0;
      value = Math.max(value, 0);

      if (this._outerHeight != value) {
        this._outerHeight = value;
        this.updateValue();
      }
    },
    get: function () {
      return this._outerHeight || 0;
    }
  }
};

function HScrollbar() {
  var thisHS = this;
  var left0, innerOffset0;

  var pointerMoveEventHandler = function (event) {
    event.preventDefault();
    var dy = event.clientX - left0;
    var newInnerOffset = innerOffset0 + dy * (thisHS.innerWidth / thisHS.outerWidth) * (thisHS.outerWidth / thisHS.getBoundingClientRect().width);
    if (newInnerOffset + thisHS.outerWidth > thisHS.innerWidth) newInnerOffset = thisHS.innerWidth - thisHS.outerWidth;
    if (newInnerOffset < 0) newInnerOffset = 0;
    thisHS.innerOffset = newInnerOffset; //todo

    event.innerOffset = newInnerOffset;
    thisHS.emit('scroll', event);
  };

  var finishEventHandler = function (event) {
    var body = $(document.body);
    body.off('pointerleave', finishEventHandler);
    body.off('pointerup', finishEventHandler);
    body.off('pointermove', pointerMoveEventHandler);
    thisHS.removeClass('absol-active');
    thisHS.emit('deactive', {
      type: 'deactive',
      originEvent: event,
      tagert: thisHS
    });
  };

  var pointerDownEventHandler = function (event) {
    var boundRes = thisHS.getBoundingClientRect();
    var boundButton = thisHS.$button.getBoundingClientRect();
    left0 = event.clientX;

    if (event.target == thisHS.$button) {
      innerOffset0 = thisHS.innerOffset;
    } else {
      var newInnerOffset = (0, _int.map)(left0 - boundButton.width / 2 - boundRes.left, 0, boundRes.width, 0, thisHS.innerWidth);
      if (newInnerOffset + thisHS.outerWidth > thisHS.innerWidth) newInnerOffset = thisHS.innerWidth - thisHS.outerWidth;
      if (newInnerOffset < 0) newInnerOffset = 0;
      thisHS.innerOffset = newInnerOffset; //todo

      event.innerOffset = newInnerOffset;
      innerOffset0 = newInnerOffset;
      thisHS.emit('scroll', event);
    }

    var body = $(document.body);
    body.on('pointerleave', finishEventHandler);
    body.on('pointerup', finishEventHandler);
    body.on('pointermove', pointerMoveEventHandler);
    thisHS.addClass('absol-active');
    thisHS.emit('active', {
      type: 'deactive',
      originEvent: event,
      tagert: thisHS
    });
  };

  this.on('pointerdown', pointerDownEventHandler, true);
}

HScrollbar.tag = 'hscrollbar';

HScrollbar.render = function () {
  return _({
    tag: 'scrollbar',
    class: 'absol-hscrollbar'
  }, true);
};

HScrollbar.prototype.updateValue = function () {
  this.$button.addStyle('width', Math.min(this.outerWidth / this.innerWidth, 1) * 100 + '%');
  this.$button.addStyle('left', this.innerOffset / this.innerWidth * 100 + '%');
};

HScrollbar.property = {
  innerOffset: {
    set: function (value) {
      value = value || 0;

      if (this._innerOffset != value) {
        this._innerOffset = value;
        this.updateValue();
      }
    },
    get: function () {
      return this._innerOffset || 0;
    }
  },
  innerWidth: {
    set: function (value) {
      value = value || 1;
      value = Math.max(value, 1);

      if (this._innerWidth != value) {
        this._innerWidth = value;
        this.updateValue();
      }
    },
    get: function () {
      return this._innerWidth || 1;
    }
  },
  outerWidth: {
    set: function (value) {
      value = value || 0;
      value = Math.max(value, 0);

      if (this._outerWidth != value) {
        this._outerWidth = value;
        this.updateValue();
      }
    },
    get: function () {
      return this._outerWidth || 0;
    }
  }
};

_ACore.default.install([VScrollbar, HScrollbar, Scrollbar, VScroller, HScroller]);
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/ChromeCalendar.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/ChromeCalendar.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/chromecalendar.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var datetime = _interopRequireWildcard(require("absol/src/Time/datetime"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _Scroller = require("./Scroller");

var _DomSignal = _interopRequireDefault(require("absol/src/HTML5/DomSignal"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));




var _ = _ACore.default._;
var $ = _ACore.default.$;
/**
 * @extends AElement
 * @constructor
 */

function ChromeCalendar() {
  var thisCal = this;
  this._level = "day";
  this.$years = $('.absol-chrome-calendar-years', this);

  this._fillYearList(this.$years);

  this.$title = $('.absol-chrome-calendar-title', this).on('click', this.eventHandler.clickTitle);
  this.$titleTime = $('.title-time', this.$title);
  this.$instance = $('.absol-chrome-calendar-instance', this);
  this.$era = $('.absol-chrome-calendar-era', this).on('scroll', this.eventHandler.eraScroll).on('click', this.eventHandler.clickEra);

  this._fillEra();

  this.$month = $('.absol-chrome-calendar-month', this);
  this._min = new Date(1890, 0, 1);
  this._max = new Date(2090, 0, 1);
  this._selectedDates = [datetime.beginOfDay(new Date())];
  this._viewDate = new Date();
  this.$prevBtn = $('.absol-chrome-calendar-header-buttons > button.prev-btn', this).on('click', this.eventHandler.clickPrev);
  this.$todayBtn = $('.absol-chrome-calendar-header-buttons > button.today-btn', this).on('click', this.eventHandler.clickToday);
  this.$nextBtn = $('.absol-chrome-calendar-header-buttons > button.next-btn', this).on('click', this.eventHandler.clickNext);
  /***
   *
   * @type {VScroller}
   */

  this.$yearScroller = $('vscroller.absol-chrome-calendar-years', this);
  this.$yearItems = [];
  $('.absol-chrome-calendar-year', this.$yearScroller, function (e) {
    thisCal.$yearItems.push(e);
  });
  this.$attachHook = _('attachhook').addTo(this);
  this.domSignal = new _DomSignal.default(this.$attachHook).on('level_change', this.eventHandler.levelChange).on('request_update_buttons', this._updateButtons.bind(this)).on('request_update_month', this._updateMonth.bind(this, this.$month)).on('request_update_open_year', this._updateOpenYear.bind(this)).on('request_update_disabled_year_in_era', this._updateDisabledYearInEra.bind(this)).on('request_update_picked_years', this._updatePickedYears.bind(this));
  this.sync = new Promise(function (rs) {
    thisCal.$attachHook.on('attached', rs);
  });
  this.domSignal.emit('level_change');
  this.sync.then('attached', function () {
    thisCal.$yearScroller.requestUpdateSize();
    thisCal.expandYear(thisCal._viewDate.getFullYear());

    thisCal._updateYearInEra();
  });

  _OOP.default.drillProperty(this, this, 'minLimitDate', 'min');

  _OOP.default.drillProperty(this, this, 'minDateLimit', 'min');

  _OOP.default.drillProperty(this, this, 'maxLimitDate', 'max');

  _OOP.default.drillProperty(this, this, 'maxDateLimit', 'max');
}

ChromeCalendar.tag = 'ChromeCalendar'.toLowerCase();

ChromeCalendar.render = function () {
  return _({
    class: ['absol-chrome-calendar', 'as-level-day'],
    extendEvent: 'pick',
    child: [{
      class: 'absol-chrome-calendar-header',
      child: [{
        class: 'absol-chrome-calendar-title',
        child: [{
          tag: 'span',
          class: 'title-time',
          child: {
            text: 'Septemper, 2019'
          }
        }]
      }, {
        class: 'absol-chrome-calendar-header-buttons',
        child: [{
          tag: 'button',
          class: 'prev-btn',
          child: 'span.mdi.mdi-menu-left',
          attr: {
            title: 'Previous Month'
          }
        }, {
          tag: 'button',
          class: 'today-btn',
          child: 'span.mdi.mdi-circle-medium',
          attr: {
            title: 'Today'
          }
        }, {
          tag: 'button',
          class: 'next-btn',
          child: 'span.mdi.mdi-menu-right',
          attr: {
            title: 'Next Month'
          }
        }]
      }]
    }, {
      class: 'absol-chrome-calendar-instance',
      child: [{
        class: 'absol-chrome-calendar-dayofweek',
        child: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'].map(function (text) {
          return {
            child: {
              text: text
            }
          };
        })
      }, {
        class: 'absol-chrome-calendar-month',
        child: Array(6).fill(0).map(function (u, i) {
          return {
            class: 'absol-chrome-calendar-week-in-mounth',
            child: Array(7).fill(0).map(function (v, j) {
              return {
                child: {
                  text: i * 7 + j + ''
                }
              };
            })
          };
        })
      }, {
        tag: 'vscroller',
        class: 'absol-chrome-calendar-years',
        child: {}
      }, {
        class: "absol-chrome-calendar-era"
      }]
    }]
  });
};
/**
 * @param {Date} date
 * @returns {Boolean}
 */


ChromeCalendar.prototype._isSelectedDate = function (date) {
  for (var i = 0; i < this._selectedDates.length; ++i) {
    if ((0, datetime.compareDate)(date, this._selectedDates[i]) === 0) return true;
  }

  return false;
};
/**
 * @param {Date} date
 * @returns {Boolean}
 */


ChromeCalendar.prototype._isSelectedMonth = function (date) {
  for (var i = 0; i < this._selectedDates.length; ++i) {
    if ((0, datetime.compareMonth)(date, this._selectedDates[i]) === 0) return true;
  }

  return false;
};
/**
 * @param {Date} date
 * @returns {Boolean}
 */


ChromeCalendar.prototype._isSelectedYear = function (date) {
  for (var i = 0; i < this._selectedDates.length; ++i) {
    if (date.getFullYear() === this._selectedDates[i].getFullYear()) return true;
  }

  return false;
};

ChromeCalendar.prototype._dayCmpLimit = function (date) {
  if ((0, datetime.compareDate)(date, this._min) < 0) return -1;
  if ((0, datetime.compareDate)(date, this._max) > 0) return 1;
  return 0;
};

ChromeCalendar.prototype._monthCmpLimit = function (date) {
  var startOfMonth = (0, datetime.beginOfMonth)(date);
  var endOfMonth = (0, datetime.nextMonth)(date);
  var minMil = Math.max(startOfMonth.getTime(), this._min.getTime());
  var maxMil = Math.min(endOfMonth.getTime(), (0, datetime.nextDate)(this._max).getTime());
  if (minMil < maxMil) return 0;
  return this._dayCmpLimit(date);
};

ChromeCalendar.prototype._yearCmpLimit = function (date) {
  var startOfYear = (0, datetime.beginOfYear)(date);
  var endOfYear = new Date(date.getFullYear() + 1, 0, 1);
  var minMil = Math.max(startOfYear.getTime(), this._min.getTime());
  var maxMil = Math.min(endOfYear.getTime(), (0, datetime.nextDate)(this._max).getTime());
  if (minMil < maxMil) return 0;
  return this._dayCmpLimit(date);
};
/***
 *
 * @param {Date} date
 * @param event
 */


ChromeCalendar.prototype.pickDate = function (date, event) {
  date = (0, datetime.beginOfDay)(date);
  this._selectedDates = [date];

  this._updateMonth(this.$month);

  if (this.$lastOpenYearItem) this.$lastOpenYearItem.$months.updateActiveMonth();
  this.emit('pick', {
    type: 'pick',
    value: date,
    isTrusted: event && event.isTrusted,
    originEvent: event,
    selectedDates: this.selectedDates
  });
};
/***
 *
 * @param {Date} date
 * @param event
 */


ChromeCalendar.prototype.pickMonth = function (date, event) {
  date = (0, datetime.beginOfMonth)(date);
  this._selectedDates = [date];
  if (this.$lastOpenYearItem) this.$lastOpenYearItem.$months.updateActiveMonth();
  this.emit('pick', {
    type: 'pick',
    value: date,
    isTrusted: event && event.isTrusted,
    originEvent: event,
    selectedDates: this.selectedDates
  });
};

ChromeCalendar.prototype._updatePickedYears = function () {
  var yearElt;
  var self = this;

  while (this.$lastPickYears && this.$lastPickYears.length > 0) {
    yearElt = this.$lastPickYears.pop();
    yearElt.removeClass('absol-chrome-calendar-selected');
  }

  this.$lastPickYears = this._selectedDates.map(function (date) {
    var yearElt = self._yearInAre(date.getFullYear());

    yearElt.addClass('absol-chrome-calendar-selected');
    return yearElt;
  });
};

ChromeCalendar.prototype.pickYear = function (year, event) {
  var date = new Date(year, 0, 1, 0, 0, 0, 0);
  this._selectedDates = [date];
  this.domSignal.emit('request_update_picked_years');
  this.scrollIntoDecade(Math.floor(year / 10) * 10, true);
  this.emit('pick', {
    type: 'pick',
    value: date,
    isTrusted: event && event.isTrusted,
    originEvent: event
  });
};
/**
 * @param {Element} monthElt
 * @param {Date} date
 */


ChromeCalendar.prototype._fillMonth = function (monthElt, date) {
  var self = this;

  if (monthElt.$cells === undefined) {
    //for faster, attach event to element 
    monthElt.$cells = [];
    $('.absol-chrome-calendar-week-in-mounth > div', this.$month, function (elt) {
      monthElt.$cells.push(elt);
      elt.on('click', function (event) {
        self.pickDate(this.__date__, event);

        if (elt.containsClass('absol-chrome-calendar-not-in-month')) {
          if (this.__date__.getDate() < 15) {
            self.viewNexMonth();
          } else {
            self.viewPrevMonth();
          }
        }
      });
    });
  }

  var currentDate = datetime.beginOfWeek(datetime.beginOfMonth(date));
  var d;
  var cell;

  for (var i = 0; i < monthElt.$cells.length; ++i) {
    cell = monthElt.$cells[i];
    d = currentDate.getDate();
    cell.innerHTML = '' + d;
    cell.__date__ = datetime.beginOfDay(currentDate);
    currentDate = datetime.nextDate(currentDate);
  }
};

ChromeCalendar.prototype._updateMonth = function (monthElt) {
  if (!monthElt.$cells) return; // days weren't filled

  var now = new Date();

  var viewM = this._viewDate.getMonth();

  var m;
  var cell;
  var currentDate;

  for (var i = 0; i < monthElt.$cells.length; ++i) {
    cell = monthElt.$cells[i];
    currentDate = cell.__date__;
    m = currentDate.getMonth();
    if (m != viewM) cell.addClass('absol-chrome-calendar-not-in-month');else cell.removeClass('absol-chrome-calendar-not-in-month');
    if (datetime.compareDate(currentDate, now) == 0) cell.addClass('absol-chrome-calendar-today');else cell.removeClass('absol-chrome-calendar-today');
    if (this._isSelectedDate(currentDate)) cell.addClass('absol-chrome-calendar-selected');else cell.removeClass('absol-chrome-calendar-selected');

    if (datetime.compareDate(this._min, currentDate) > 0 || datetime.compareDate(currentDate, this._max) > 0) {
      cell.addClass('absol-chrome-calendar-date-disabled');
    } else {
      cell.removeClass('absol-chrome-calendar-date-disabled');
    }
  }
};

ChromeCalendar.prototype._fillYearList = function (ctn) {
  var thisCal = this;

  _({
    child: Array(200).fill(0).map(function (u, i) {
      return {
        class: 'absol-chrome-calendar-year',
        child: [{
          class: 'absol-chrome-calendar-year-head',
          child: {
            text: i + 1890 + ''
          }
        }],
        props: {
          __year__: i + 1890
        },
        on: {
          click: function () {
            thisCal.expandYear(this.__year__);
          }
        }
      };
    })
  }).addTo(ctn);
};

ChromeCalendar.prototype._fillEra = function () {
  var now = new Date();
  var cYear = now.getFullYear();
  var rows = Array(50).fill(0).map(function (u, i) {
    return _({
      class: 'absol-chrome-calendar-era-row',
      child: Array(4).fill(0).map(function (u1, j) {
        var classList = ['absol-chrome-calendar-era-year'];
        var year = 1890 + i * 4 + j;

        if (cYear === year) {
          classList.push('absol-chrome-calendar-today');
        }

        return {
          class: classList,
          child: {
            text: year + ''
          },
          props: {
            __year__: year
          }
        };
      })
    });
  });
  this.$era.addChild(rows);
};

ChromeCalendar.prototype.viewNexMonth = function () {
  var self = this;
  this.sync = this.sync.then(function () {
    return new Promise(function (rs) {
      var oldBound = self.$month.getBoundingClientRect();
      var oldMonth = self.$month.cloneNode(true);
      var instanceBound = self.$instance.getBoundingClientRect();

      if (self.$lastAnimationCtn) {
        self.$lastAnimationCtn.removeClass('new').addClass('old');
      }

      var oldMonthCnt = _({
        class: ['absol-chrome-calendar-month-animation-container', 'old'],
        style: {
          top: oldBound.top - instanceBound.top + 'px',
          height: oldBound.height + 'px',
          width: oldBound.width + 'px'
        },
        child: oldMonth
      }).addTo(self.$instance);

      self._viewDate = datetime.nextMonth(self._viewDate);
      self.viewMonth();
      var newMonth = self.$month.cloneNode(true);
      var overlap = 0;
      var j = 41;

      while (j >= 0 && self.$month.$cells[j].containsClass('absol-chrome-calendar-not-in-month')) {
        overlap += oldBound.height / 6;
        j -= 7;
      }

      var newMonthCtn = _({
        class: ['absol-chrome-calendar-month-animation-container', 'new'],
        style: {
          top: oldBound.top + oldBound.height - instanceBound.top - overlap + 'px',
          height: oldBound.height + 'px',
          width: oldBound.width + 'px'
        },
        child: newMonth
      }).addTo(self.$instance);

      self.$lastAnimationCtn = newMonthCtn;
      setTimeout(function () {
        oldMonthCnt.addStyle('top', oldBound.top - oldBound.height + overlap - instanceBound.top + 'px');
        newMonthCtn.addStyle('top', oldBound.top - instanceBound.top + 'px');
      }, 20);
      setTimeout(function () {
        self.$lastAnimationCtn = undefined;
        oldMonthCnt.remove();
        newMonthCtn.remove();
      }, 220);
      setTimeout(rs, 22);
    });
  });
  return this.sync;
};

ChromeCalendar.prototype.viewPrevMonth = function () {
  var self = this;
  this.sync = this.sync.then(function () {
    return new Promise(function (rs) {
      var oldBound = self.$month.getBoundingClientRect();
      var oldMonth = self.$month.cloneNode(true);
      var instanceBound = self.$instance.getBoundingClientRect();

      if (self.$lastAnimationCtn) {
        self.$lastAnimationCtn.removeClass('new').addClass('old');
      }

      var oldMonthCnt = _({
        class: ['absol-chrome-calendar-month-animation-container', 'old'],
        style: {
          top: oldBound.top - instanceBound.top + 'px',
          height: oldBound.height + 'px',
          width: oldBound.width + 'px'
        },
        child: oldMonth
      }).addTo(self.$instance);

      self._viewDate = datetime.prevMonth(self._viewDate);
      self.viewMonth();
      var newMonth = self.$month.cloneNode(true);
      var overlap = 0;
      var j = 0;

      while (j < 42 && self.$month.$cells[j].containsClass('absol-chrome-calendar-not-in-month')) {
        overlap += oldBound.height / 6;
        j += 7;
      }

      var newMonthCtn = _({
        class: ['absol-chrome-calendar-month-animation-container', 'new'],
        style: {
          top: oldBound.top - oldBound.height + overlap - instanceBound.top + 'px',
          height: oldBound.height + 'px',
          width: oldBound.width + 'px'
        },
        child: newMonth
      }).addTo(self.$instance);

      self.$lastAnimationCtn = newMonthCtn;
      setTimeout(function () {
        oldMonthCnt.addStyle('top', oldBound.top + oldBound.height - overlap - instanceBound.top + 'px');
        newMonthCtn.addStyle('top', oldBound.top - instanceBound.top + 'px');
      }, 20);
      setTimeout(function () {
        self.$lastAnimationCtn = undefined;
        oldMonthCnt.remove();
        newMonthCtn.remove();
      }, 220);
      setTimeout(rs, 22);
    });
  });
  return this.sync;
};

ChromeCalendar.prototype.viewToday = function () {
  this._viewDate = new Date();

  switch (this._level) {
    case "day":
      this.viewMonth();
      break;

    case "month":
      break;

    case "year":
      this.viewEra(true);
      break;
  }
};

ChromeCalendar.prototype.viewMonth = function () {
  this._updateButtons();

  this.removeClass('view-year').removeClass('view-era').addClass('view-month');

  this._fillMonth(this.$month, this._viewDate);

  this._updateMonth(this.$month);

  this.$titleTime.innerHTML = datetime.formatDateString(this._viewDate, 'mmmm, yyyy');
};

ChromeCalendar.prototype.viewYear = function () {
  this.removeClass('view-month').removeClass('view-era').addClass('view-year');
  this.expandYear(this._viewDate.getFullYear());
  this.$yearScroller.requestUpdateSize();
};

ChromeCalendar.prototype.viewEra = function (animation) {
  this.removeClass('view-month').removeClass('view-year').addClass('view-era');
  this.scrollIntoDecade(Math.floor(this._viewDate.getFullYear() / 10) * 10, animation);
};

ChromeCalendar.prototype.viewNextDecade = function (animation) {
  this._viewDate = new Date(Math.min(2080, Math.floor(this._viewDate.getFullYear() / 10) * 10 + 10), 0, 1);
  this._viewDate = new Date(Math.min(this._viewDate.getTime(), (0, datetime.prevDate)(this._max).getTime()));
  this.viewEra(animation);
};

ChromeCalendar.prototype.viewPrevDecade = function (animation) {
  this._viewDate = new Date(Math.max(1890, Math.floor(this._viewDate.getFullYear() / 10) * 10 - 10), 0, 1);
  this._viewDate = new Date(Math.max(this._viewDate.getTime(), this._min.getTime()));
  this.viewEra(animation);
};

ChromeCalendar.prototype.expandYear = function (year) {
  if (this._level === 'month') {
    this._viewDate = new Date(year, 0, 1);
    this.$titleTime.innerHTML = (0, datetime.formatDateString)(this._viewDate, 'mmmm, yyyy');
    this.domSignal.emit('request_update_buttons');
  }

  var fontSize = this.getFontSize();
  var self = this;
  var lastItemElt = this.$lastOpenYearItem;
  var itemElt = this.$yearItems[year - 1890];
  var lastYear = 100000000;

  if (lastItemElt && lastItemElt.__year__ !== year) {
    lastYear = lastItemElt.__year__;
    lastItemElt.addClass('start-closing');
    setTimeout(function () {
      lastItemElt.removeClass('start-closing').addClass('closing');
    }, 0);
    setTimeout(function () {
      lastItemElt.removeClass('closing');
      lastItemElt.$months.remove();
      lastItemElt.$months = undefined;
    }, 100);
  }

  if (lastItemElt !== itemElt) {
    if (!itemElt.$months) {
      itemElt.$months = this._createMonths(year).addTo(itemElt);
      itemElt.addClass('start-opening');
      setTimeout(function () {
        itemElt.removeClass('start-opening').addClass('opening');
      }, 1);
      setTimeout(function () {
        itemElt.removeClass('opening');
      }, 100);
    }
  }

  var dy = itemElt.getBoundingClientRect().top - self.$yearScroller.getBoundingClientRect().top - fontSize * 0.45;

  if (itemElt.__year__ > lastYear) {
    dy -= 6 * fontSize;
  }

  self.$yearScroller.scrollBy(dy, 100);
  this.$lastOpenYearItem = itemElt;
  itemElt.$months.updateActiveMonth();
};

ChromeCalendar.prototype.scrollIntoDecade = function (startYear, animation) {
  if (!this.isDescendantOf(document.body)) {
    return this.sync.then(this.scrollIntoDecade.bind(this));
  }

  var thisCal = this;
  return new Promise(function (resolve) {
    var eraBound = thisCal.$era.getBoundingClientRect();
    var rowIdx = Math.floor((startYear - 1890) / 4);

    if (thisCal._decadeScrollTimeout > 0) {
      clearTimeout(thisCal._decadeScrollTimeout);
      thisCal._decadeScrollTimeout = -1;
    }

    if (thisCal.scrollIntoDecadeResolve) {
      thisCal.scrollIntoDecadeResolve();
      thisCal.scrollIntoDecadeResolve = null;
    }

    thisCal.scrollIntoDecadeResolve = resolve;
    var t0 = new Date().getTime();
    var t1 = t0 + 250;
    var y0 = thisCal.$era.scrollTop;
    var y1 = rowIdx * eraBound.height / 4;

    if (animation) {
      thisCal._decadeScrollTimeout = setTimeout(function tick() {
        var tc = new Date().getTime();
        var yc = Math.min(1, Math.pow((tc - t0) / (t1 - t0), 2)) * (y1 - y0) + y0;
        thisCal.$era.scrollTop = yc;

        if (tc < t1) {
          thisCal._decadeScrollTimeout = setTimeout(tick, 30);
        } else {
          thisCal._decadeScrollTimeout = -1;
          thisCal.scrollIntoDecadeResolve = null;
          resolve();
        }
      }, 30);
    } else {
      thisCal.$era.scrollTop = y1;
    }
  });
};

ChromeCalendar.prototype._updateButtons_day = function () {
  if (this._monthCmpLimit((0, datetime.prevMonth)(this._viewDate)) < 0) {
    this.$prevBtn.addClass('absol-chrome-calendar-button-disabled');
  } else {
    this.$prevBtn.removeClass('absol-chrome-calendar-button-disabled');
  }

  if (this._monthCmpLimit((0, datetime.nextMonth)(this._viewDate)) > 0) {
    this.$nextBtn.addClass('absol-chrome-calendar-button-disabled');
  } else {
    this.$nextBtn.removeClass('absol-chrome-calendar-button-disabled');
  }

  var now = new Date();

  if (this._monthCmpLimit(now) === 0) {
    this.$todayBtn.removeClass('absol-chrome-calendar-button-disabled');
  } else {
    this.$todayBtn.addClass('absol-chrome-calendar-button-disabled');
  }
};

ChromeCalendar.prototype._updateButtons_year = function () {
  if (!this._viewDate) return;
  var year = Math.floor(this._viewDate.getFullYear() / 10) * 10;

  if (this._yearCmpLimit(new Date(year - 1, 0, 1)) < 0) {
    this.$prevBtn.addClass('absol-chrome-calendar-button-disabled');
  } else {
    this.$prevBtn.removeClass('absol-chrome-calendar-button-disabled');
  }

  if (this._yearCmpLimit(new Date(year + 10, 0, 1)) > 0) {
    this.$nextBtn.addClass('absol-chrome-calendar-button-disabled');
  } else {
    this.$nextBtn.removeClass('absol-chrome-calendar-button-disabled');
  }

  var now = new Date();

  if (this._yearCmpLimit(now) === 0) {
    this.$todayBtn.removeClass('absol-chrome-calendar-button-disabled');
  } else {
    this.$todayBtn.addClass('absol-chrome-calendar-button-disabled');
  }
};

ChromeCalendar.prototype._updateButtons_month = function () {
  if (this._yearCmpLimit(new Date(this._viewDate.getFullYear() + 1, 0, 1)) > 0) {
    this.$nextBtn.addClass('absol-chrome-calendar-button-disabled');
  } else {
    this.$nextBtn.removeClass('absol-chrome-calendar-button-disabled');
  }

  if (this._yearCmpLimit(new Date(this._viewDate.getFullYear() - 1, 0, 1)) < 0) {
    this.$prevBtn.addClass('absol-chrome-calendar-button-disabled');
  } else {
    this.$prevBtn.removeClass('absol-chrome-calendar-button-disabled');
  }
};

ChromeCalendar.prototype._updateButtons = function () {
  var fName = '_updateButtons_' + this._level;
  this[fName] && this[fName]();
};

ChromeCalendar.prototype._createMonths = function (year) {
  var now = new Date();
  var self = this;

  var res = _({
    class: 'absol-chrome-calendar-year-mounths',
    child: Array(3).fill('').map(function (u, i) {
      return {
        class: 'absol-chrome-calendar-year-row-months',
        child: Array(4).fill(0).map(function (v, j) {
          var date = new Date(year, i * 4 + j, 1, 0, 0, 0, 0, 0);
          return {
            class: ['absol-chrome-calendar-year-month'].concat(year == now.getFullYear() && now.getMonth() == i * 4 + j ? ['absol-chrome-calendar-today'] : []).concat(self._isSelectedMonth(date) ? ['absol-chrome-calendar-selected'] : []),
            child: {
              text: datetime.monthNames[i * 4 + j].substr(0, 3)
            },
            on: {
              click: function () {}
            },
            props: {
              __date__: date
            }
          };
        })
      };
    }),
    on: {
      click: this.eventHandler.clickMonthsInYear
    }
  });

  res.$monthList = [];
  $('.absol-chrome-calendar-year-month', res, function (e) {
    res.$monthList.push(e);
  });

  res.updateActiveMonth = function () {
    res.$monthList.forEach(function (e) {
      now = new Date();

      if (datetime.compareMonth(e.__date__, now) == 0) {
        e.addClass('absol-chrome-calendar-today');
      } else {
        e.removeClass('absol-chrome-calendar-today');
      }

      if (self._isSelectedMonth(e.__date__)) {
        e.addClass('absol-chrome-calendar-selected');
      } else {
        e.removeClass('absol-chrome-calendar-selected');
      }

      var beginOfMonth = datetime.beginOfMonth(e.__date__);
      var endOfMonth = datetime.prevDate(datetime.nextMonth(e.__date__));

      if (datetime.compareDate(self._min, endOfMonth) > 0 || datetime.compareDate(beginOfMonth, self._max) > 0) {
        e.addClass('absol-chrome-calendar-date-disabled');
      } else {
        e.removeClass('absol-chrome-calendar-date-disabled');
      }
    });
  };

  return res;
};

ChromeCalendar.prototype._yearInAre = function (year) {
  var d = year - 1890;
  var rowIdx = Math.floor(d / 4);
  var colIdx = d % 4;
  return this.$era.childNodes[rowIdx] && this.$era.childNodes[rowIdx].childNodes[colIdx];
};

ChromeCalendar.prototype._clearYearInAre = function (startYear) {
  var cellElt;

  for (var i = 0; i < 10; ++i) {
    cellElt = this._yearInAre(startYear + i);
    if (cellElt) cellElt.removeClass('absol-chrome-calendar-in-decade');
  }
};

ChromeCalendar.prototype._activeYearInAre = function (startYear) {
  var cellElt;

  for (var i = 0; i < 10; ++i) {
    cellElt = this._yearInAre(startYear + i);
    if (cellElt) cellElt.addClass('absol-chrome-calendar-in-decade');
  }
};

ChromeCalendar.prototype._updateYearInEra = function () {
  var eraBound = this.$era.getBoundingClientRect();
  var startYear = 1890 + 4 * Math.ceil((this.$era.scrollTop - eraBound.height / 16) * 4 / eraBound.height);
  var startDecade = Math.floor(startYear / 10) * 10;
  if (startDecade + 10 - startYear < 8) startDecade += 10;

  if (this._lastStartDecade !== startDecade) {
    if (this._lastStartDecade > 0) {
      this._clearYearInAre(this._lastStartDecade);
    }

    this._lastStartDecade = startDecade;

    this._activeYearInAre(startDecade);

    if (this._level === 'year') {
      this.$titleTime.innerHTML = startDecade + '-' + (startDecade + 10);

      if (!this._decadeScrollTimeout || this._decadeScrollTimeout < 0) {
        if (this._yearCmpLimit(new Date(startDecade, 0, 1)) === 0) this._viewDate = new Date(startDecade, 0, 1);
      }
    }

    this.domSignal.emit('request_update_buttons');
  }
};

ChromeCalendar.prototype._updateDisabledYearInEra = function () {
  var self = this;
  Array.prototype.forEach.call(this.$era.childNodes, function (rowElt) {
    Array.prototype.forEach.call(rowElt.childNodes, function (cellElt) {
      if (cellElt.__year__) {
        if (self._yearCmpLimit(new Date(cellElt.__year__, 0, 1)) === 0) {
          cellElt.removeClass('absol-chrome-calendar-date-disabled');
        } else {
          cellElt.addClass('absol-chrome-calendar-date-disabled');
        }
      }
    });
  });
};

ChromeCalendar.prototype._updateOpenYear = function () {
  if (this.$lastOpenYearItem) {
    this.$lastOpenYearItem.$months.updateActiveMonth();
  }
};

ChromeCalendar.property = {};
ChromeCalendar.property.selectedDates = {
  set: function (value) {
    value = value || [];
    if (value instanceof Date) value = [value];
    this._selectedDates = value;
    this._viewDate = this._selectedDates[0] || new Date();
    this.domSignal.emit('level_change');
    if (this._level === 'year') this.domSignal.emit('request_update_picked_years');
  },
  get: function () {
    return this._selectedDates;
  }
};
ChromeCalendar.property.min = {
  set: function (value) {
    if (!value) value = new Date(1890, 0, 1);
    if (typeof value == 'number') value = new Date(value);
    value = (0, datetime.beginOfDay)(value);
    value = new Date(Math.max(new Date(1890, 0, 1).getTime(), value.getTime()));
    this._min = value;
    this.domSignal.emit('request_update_buttons');
    this.domSignal.emit('request_update_month');
    this.domSignal.emit('request_update_open_year');
    this.domSignal.emit('request_update_disabled_year_in_era');
  },
  get: function () {
    return this._min;
  }
}; //include maxLimitDate

ChromeCalendar.property.max = {
  set: function (value) {
    if (!value) value = new Date(2090, 0, 1);
    if (typeof value == 'number') value = new Date(value);
    if (value.getTime() > (0, datetime.beginOfDay)(value).getTime()) value = (0, datetime.nextDate)((0, datetime.beginOfDay)(value));
    value = new Date(Math.min(new Date(2090, 0, 1).getTime(), value.getTime()));
    this._max = value;
    this.domSignal.emit('request_update_buttons');
    this.domSignal.emit('request_update_month');
    this.domSignal.emit('request_update_open_year');
    this.domSignal.emit('request_update_disabled_year_in_era');
  },
  get: function () {
    return this._max;
  }
};
ChromeCalendar.property.multiSelect = {
  set: function (value) {
    throw new Error('Not support yet!');
    var lastValue = this.multiSelect;
    value = !!value;

    if (lastValue != value) {
      if (value) {
        this.addClass('multi-select');
      } else {
        this.removeClass('multi-select');
      }

      this._updateMonth(this.$month);
    }
  },
  get: function () {
    return this.containsClass('multi-select');
  }
};
ChromeCalendar.property.level = {
  set: function (value) {
    value = (value || '') + '';
    value = value.toLowerCase();
    if (['day', 'month', 'year'].indexOf(value) < 0) value = 'day';
    if (this._level === value) return;
    this.removeClass('as-level-' + this._level);
    this._level = value;
    this.addClass('as-level-' + this._level);
    this.domSignal.emit('level_change');
    if (this._level === 'year') this.domSignal.emit('request_update_picked_years');
  },
  get: function () {
    return this._level;
  }
};
ChromeCalendar.property.viewDate = {
  set: function (date) {
    this._viewDate = date;
    this.domSignal.emit('level_change');
  },
  get: function () {
    return this._viewDate;
  }
};
ChromeCalendar.eventHandler = {};

ChromeCalendar.eventHandler.eraScroll = function () {
  this._updateYearInEra();
};

ChromeCalendar.eventHandler.clickEra = function (event) {
  var yearElt = event.target;
  var year = yearElt.__year__;
  if (typeof year !== "number") return;
  this.pickYear(year, event);
};

ChromeCalendar.eventHandler.clickPrev = function () {
  switch (this._level) {
    case "day":
      this.viewPrevMonth();
      break;

    case "month":
      this.expandYear(Math.min(this._max.getFullYear(), this._viewDate.getFullYear() - 1));
      break;

    case "year":
      if (!this._decadeScrollTimeout || this._decadeScrollTimeout < 0) this.viewPrevDecade(true);
      break;
  }
};

ChromeCalendar.eventHandler.clickNext = function () {
  switch (this._level) {
    case "day":
      this.viewNexMonth();
      break;

    case "month":
      this.expandYear(Math.max((0, datetime.prevDate)(this._min).getFullYear(), this._viewDate.getFullYear() + 1));
      break;

    case "year":
      if (!this._decadeScrollTimeout || this._decadeScrollTimeout < 0) this.viewNextDecade(true);
      break;
  }
};

ChromeCalendar.eventHandler.clickToday = function (event) {
  this.viewToday();

  switch (this._level) {
    case "day":
      this.pickDate(new Date());
      break;

    case "month":
      this.expandYear(new Date().getFullYear());
      this.pickMonth((0, datetime.beginOfMonth)(new Date()), event);
      break;

    case "year":
      this.pickYear(new Date().getFullYear());
      this._viewDate = new Date(new Date().getFullYear(), 0, 1);
      this.viewEra(true);
      break;
  }
};

ChromeCalendar.eventHandler.clickTitle = function (event) {
  switch (this._level) {
    case "day":
      this.viewYear();
      break;

    case "month":
      break;

    case "year":
      break;
  }
};

ChromeCalendar.eventHandler.clickMonthsInYear = function (event) {
  var monthElt = event.target;
  var date = monthElt.__date__;
  if (!date) return;

  switch (this._level) {
    case "day":
      this._viewDate = date;
      this.viewMonth();
      break;

    case "month":
      this.pickMonth(date, event);
      break;

    case "year":
      break;
  }
};

ChromeCalendar.eventHandler.levelChange = function () {
  switch (this._level) {
    case "day":
      this.viewMonth();
      break;

    case "month":
      this.viewYear();
      break;

    case "year":
      this.viewEra();
      break;
  }
};

_ACore.default.install(ChromeCalendar);

ChromeCalendar._session = Math.random() * 10000000000 >> 0;
ChromeCalendar._listener = undefined;

ChromeCalendar.showWhenClick = function (element, calendarProps, anchor, calendarPickListener, darkTheme) {
  var res = {
    calendarProps: Object.assign({
      maxDateLimit: null,
      minDateLimit: null
    }, calendarProps),
    anchor: anchor,
    currentSession: undefined,
    element: element,
    calendarPickListener: calendarPickListener,
    darkTheme: darkTheme,
    setDateValue: function (value) {
      if (this.currentSession == ChromeCalendar._session) {
        ChromeCalendar.$calendar.selectedDates = [value];
      }
    },
    cancel: function () {}
  };

  var clickHandler = function () {
    if (ChromeCalendar._session == res.currentSession) return;
    res.currentSession = ChromeCalendar.show(res.element, res.calendarProps, res.anchor, res.calendarPickListener, res.darkTheme);

    var finish = function (event) {
      if (event && event.target && _EventEmitter.default.hitElement(ChromeCalendar.$calendar, event)) return;
      document.body.removeEventListener('click', finish, false);
      ChromeCalendar.close(res.currentSession);
      ChromeCalendar.$calendar.off('pick', finish);
      res.currentSession = undefined;

      res.cancel = function () {};
    };

    setTimeout(function () {
      document.body.addEventListener('click', finish, false);
      ChromeCalendar.$calendar.on('pick', finish);
      res.cancel = finish;
    }, 10);
  };

  res.remove = function () {
    element.removeEventListener('click', clickHandler, false);
  };

  element.addEventListener('click', clickHandler, false);
  return res;
};

ChromeCalendar.show = function (element, calendarProps, anchor, calendarPickListener, darkTheme) {
  ChromeCalendar._session = Math.random() * 10000000000 >> 0;

  function exec() {
    if (!ChromeCalendar.$ctn) {
      ChromeCalendar.$ctn = _('.absol-context-hinge-fixed-container');
      ChromeCalendar.$follower = _('follower').addTo(ChromeCalendar.$ctn);
      ChromeCalendar.$calendar = _('chromecalendar').on('pick', function (event) {
        if (typeof ChromeCalendar._listener == 'function') {
          ChromeCalendar._listener(event.value);
        }
      }).addTo(ChromeCalendar.$follower);
    }

    ChromeCalendar.$ctn.addTo(document.body); // only one value need

    if (calendarProps instanceof Date) calendarProps = {
      selectedDates: [calendarProps]
    };
    if (calendarProps instanceof Array) calendarProps = {
      selectedDates: calendarProps
    };
    Object.assign(ChromeCalendar.$calendar, calendarProps);
    if (darkTheme) ChromeCalendar.$ctn.addClass('dark');else ChromeCalendar.$ctn.removeClass('dark');
    ChromeCalendar.$follower.followTarget = element;
    ChromeCalendar.$follower.anchor = anchor;
    ChromeCalendar.$calendar.addStyle('visibility', 'hidden'); //for prevent size change blink

    ChromeCalendar._listener = calendarPickListener;
    setTimeout(function () {
      ChromeCalendar.$follower.updatePosition();
      ChromeCalendar.$calendar.removeStyle('visibility');
    }, 2);
  }

  if (document.body) exec();else _Dom.default.documentReady.then(exec);
  return ChromeCalendar._session;
};

ChromeCalendar.close = function (session) {
  if (session !== true && session != ChromeCalendar._session) return;

  function exec() {
    ChromeCalendar.followTarget = undefined;
    ChromeCalendar._listener = undefined;
    ChromeCalendar.$ctn.remove();
  }

  if (document.body) exec();else _Dom.default.documentReady.then(exec);
};

var _default = ChromeCalendar;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/CalendarInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/CalendarInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OldCalendarInput = OldCalendarInput;
exports.default = void 0;

require("../css/calendarinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _datetime = require("absol/src/Time/datetime");

var _ChromeCalendar = _interopRequireDefault(require("./ChromeCalendar"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/**
 * @extends AElement
 * @constructor
 */

function CalendarInput() {
  var thisCI = this;
  this.$input = $('input', this);
  this._value = null;
  this._quickOption = _ChromeCalendar.default.showWhenClick(this, {
    minLimitDate: this.minLimitDate || this.minDateLimit,
    maxLimitDate: this.maxLimitDate || this.maxDateLimit,
    selectedDates: [new Date()]
  }, 'auto', function (value) {
    thisCI._value = value;
    thisCI.$input.value = thisCI.formatDateString(value);
    thisCI._quickOption.calendarProps.selectedDates = [value]; //change new option

    thisCI.emit('change', {
      target: thisCI,
      value: value
    }, thisCI);
  });

  _OOP.default.drillProperty(this, this._quickOption.calendarProps, {
    minLimitDate: 'minLimitDate',
    maxLimitDate: 'maxLimitDate',
    minDateLimit: 'minLimitDate',
    maxDateLimit: 'maxLimitDate'
  });
}

CalendarInput.tag = 'CalendarInput'.toLowerCase();

CalendarInput.render = function () {
  return _({
    extendEvent: ['change'],
    class: 'absol-calendar-input',
    child: 'input[type="text"][readonly="true"][value="dd/mm/yyyy"]'
  });
};

CalendarInput.property = {};
CalendarInput.property.value = {
  set: function (value) {
    if (value === null || value === undefined) {
      this.$input.value = this.formatDateString(value);
      this._quickOption.calendarProps.selectedDates = [];
      this._value = value;
      this._quickOption.calendarProps.selectedDates = [new Date()];
    } else {
      if (typeof value == 'number') value = new Date(value);
      this._value = value;
      this.$input.value = this.formatDateString(value);
      this._quickOption.calendarProps.selectedDates = [value];
    }
  },
  get: function () {
    return this._value;
  }
};
CalendarInput.property.disabled = {
  set: function (value) {
    this.$input.disabled = !!value;

    if (value) {
      this.addClass('absol-disabled');
    } else {
      this.removeClass('absol-disabled');
    }
  },
  get: function () {
    return this.$input.disabled;
  }
};
CalendarInput.attribute = {
  disabled: {
    set: function (value) {
      this.$input.attr('disabled', value);
      if (this.$input.disabled) this.addClass('absol-disabled');
    },
    get: function () {
      return this.$input.attr('disabled');
    },
    remove: function () {
      this.$input.attr('disabled', undefined);
      this.removeClass('absol-disabled');
    }
  }
};
CalendarInput.property.dateToString = {
  set: function (value) {
    this._dateToString = value;
    this.$input.value = this.formatDateString(this.value);
  },
  get: function () {
    return this._dateToString;
  }
};

CalendarInput.prototype.formatDateString = function (date) {
  if (!date) {
    return {
      'undefined': 'dd/mm/yyyy',
      'function': '--/--/--',
      'object': 'dd/mm/yyyy',
      'string': typeof this.dateToString
    }[typeof this.dateToString] || '--/--/--';
  }

  if (!this.dateToString) {
    return (0, _datetime.formatDateString)(date);
  } else if (typeof this.dateToString == 'string') {
    return (0, _datetime.formatDateString)(date, this.dateToString);
  } else if (typeof this.dateToString == 'function') {
    return this.dateToString(date);
  }
};

_ACore.default.install(CalendarInput);

function OldCalendarInput() {}

OldCalendarInput.tag = 'calendar-input';

OldCalendarInput.render = function (data) {
  return _({
    tag: 'calendarinput',
    extendEvent: 'changed',
    props: data,
    on: {
      change: function (ev) {
        this.emit('changed', ev.value);
      }
    }
  });
};

_ACore.default.install(OldCalendarInput);

var _default = CalendarInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/CheckBoxInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/CheckBoxInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/checkboxinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

var tickIcon = _(['<svg class="as-checkbox-input-check-icon" width="18px" height="18px" version="1.1" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg" >', ' <g transform="translate(0 -279)">', '  <path class="bound" d="m3 279.69h12c1.3434 0.0111 2.3298 1.5259 2.3131 2.4775v11.836c0.05005 0.89373-1.1834 2.2964-2.3131 2.3131h-12c-0.82692 0.0166-2.3131-1.1834-2.3131-2.3131v-12.237c0.0022374-1.171 0.3775-2.0759 2.3131-2.0759z" style="stroke-linejoin:round; stroke-width: 1"/>', '  <path class="tick" d="m3.1656 288.66c-0.10159 0.0612-0.11743 0.12506-0.12993 0.18899l3.7473 4.3467c0.066638 0.0459 0.11813 0.0263 0.16832 1e-3 0 0 1.7699-4.2166 4.7251-7.4568 1.4783-1.6208 3.2406-3.3659 3.2406-3.3659 0.0054-0.14125-0.10946-0.15807-0.1754-0.22551 0 0-2.5832 1.6364-4.7524 3.8336-1.8697 1.8939-3.6666 4.4016-3.6666 4.4016z"/>', ' </g>', '</svg>'].join(''));
/***
 * @extends AElement
 * @constructor
 */


function CheckboxInput() {
  this.$input = $('input', this).on('change', this.notifyChange.bind(this));
  this.checked = false;
  this.disabled = false;
  this.on('click', this.eventHandler.click);
  this.onchange = null;
}

CheckboxInput.tag = "CheckboxInput".toLowerCase();

CheckboxInput.render = function (data) {
  return _({
    tag: 'label',
    extendEvent: 'change',
    class: 'as-checkbox-input',
    child: [{
      elt: data && data.$input,
      tag: 'input',
      class: 'as-checkbox-input-value',
      attr: {
        type: 'checkbox'
      }
    }, tickIcon.cloneNode(true)]
  });
};
/***
 * as normal, change event will be fired when checkbox change by system
 */


CheckboxInput.prototype.notifyChange = function () {
  var event = {
    checked: this.checked
  };
  this.emit('change', event, this);
};

CheckboxInput.prototype._updateCheckedClass = function () {
  if (this.checked) {
    this.addClass('as-checked');
  } else {
    this.removeClass('as-checked');
  }
};

CheckboxInput.property = {};
CheckboxInput.property.disabled = {
  set: function (value) {
    if (value) {
      this.addClass('as-disabled');
    } else {
      this.removeClass('as-disabled');
    }

    this.$input.disabled = !!value;
  },
  get: function () {
    return this.$input.disabled;
  }
};
/***
 *
 * @type {CheckboxInput}
 */

CheckboxInput.property.checked = {
  set: function (value) {
    this.$input.checked = !!value;

    this._updateCheckedClass();
  },
  get: function () {
    return this.$input.checked;
  }
};
CheckboxInput.attribute = {
  checked: {
    set: function (value) {
      if (value === 'false' || value === null) {
        this.checked = false;
      } else {
        this.checked = true;
      }
    },
    get: function () {
      return this.checked ? 'true' : 'false';
    },
    remove: function () {
      this.checked = false;
    }
  },
  disabled: {
    set: function (value) {
      if (value === 'false' || value === null) {
        this.disabled = false;
      } else {
        this.disabled = true;
      }
    },
    get: function () {
      return this.disabled ? 'true' : 'false';
    },
    remove: function () {
      this.disabled = false;
    }
  }
};
/***
 *
 * @type {CheckboxInput}
 */

CheckboxInput.eventHandler = {};

CheckboxInput.eventHandler.click = function () {
  this._updateCheckedClass();
};

_ACore.default.install(CheckboxInput);

CheckboxInput.autoReplace = function () {
  var placeHolders = Array.prototype.slice.call(document.getElementsByTagName(this.tag));
  var ph;
  var attOfPH;
  var attrs;
  var style;
  var classList;
  var attNode;
  var attrName, attrValue;
  var props;

  for (var i = 0; i < placeHolders.length; ++i) {
    ph = placeHolders[i];
    attOfPH = ph.attributes;
    classList = [];
    style = {};
    attrs = {};
    props = {};

    for (var j = 0; j < attOfPH.length; ++j) {
      attNode = attOfPH[j];
      attrName = attNode.nodeName;
      attrValue = attNode.nodeValue;

      if (attrName == 'style') {
        attrValue.trim().split(';').reduce(function (style, prop) {
          var p = prop.split(':');

          if (p.length == 2) {
            style[p[0].trim()] = p[1].trim();
          }

          return style;
        }, style);
      } else if (attrName == 'class') {
        classList = attrValue.trim().split(/\s+/);
      } else if (attrName == 'onchange') {
        props.onchange = new Function('event', 'sender', attrValue);
      } else {
        attrs[attrName] = attrValue;
      }
    }

    var newElt = _({
      tag: this.tag,
      attr: attrs,
      class: classList,
      style: style,
      props: props
    });

    $(ph).selfReplace(newElt);
  }
};

CheckboxInput.initAfterLoad = function () {
  _Dom.default.documentReady.then(function () {
    CheckboxInput.autoReplace();
  });
};

var _default = CheckboxInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/CheckBox.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/CheckBox.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/checkbox.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _CheckBoxInput = _interopRequireDefault(require("./CheckBoxInput"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
var $$ = _ACore.default.$$;
/***
 * @extends AElement
 * @constructor
 */

function CheckBox() {
  this.defineEvent('change');
  /***
   *
   * @type {CheckboxInput}
   */

  this.$input = $('checkboxinput', this).on('change', this.notifyChange.bind(this));
  this.$labels = $$('span', this);
  this.on('click', this.eventHandler.click);

  _OOP.default.drillProperty(this, this.$input, ['checked']);
}

CheckBox.tag = 'checkbox';

CheckBox.render = function () {
  return _({
    class: ['absol-checkbox', 'as-no-label'],
    child: [{
      tag: 'span',
      class: ['absol-checkbox-label', 'as-left'],
      child: {
        text: ''
      }
    }, 'checkboxinput', {
      tag: 'span',
      class: ['absol-checkbox-label', 'as-right'],
      child: {
        text: ''
      }
    }]
  });
};

CheckBox.prototype.notifyChange = function () {
  this.emit('change', {
    type: 'change',
    checked: this.checked,
    target: this
  }, this);
}; //v, labelText, checked


CheckBox.attribute = {
  checked: {
    set: function (value) {
      if (value === 'false' || value == null) {
        this.checked = false;
      } else {
        this.checked = true;
      }
    },
    get: function () {
      return this.checked ? 'true' : 'false';
    },
    remove: function () {
      this.checked = false;
    }
  },
  disabled: {
    set: function (value) {
      if (value === 'false' || value === null) {
        this.disabled = false;
      } else {
        this.disabled = true;
      }
    },
    get: function () {
      return this.disabled ? 'true' : 'false';
    },
    remove: function () {
      this.disabled = false;
    }
  }
};
CheckBox.property = {};
CheckBox.property.text = {
  get: function () {
    return this._text;
  },
  set: function (value) {
    value = value || '';

    if (value.length === 0) {
      this.addClass('as-no-label');
    } else {
      this.removeClass('as-no-label');
    }

    this._text = value;
    this.$labels[0].firstChild.data = value;
    this.$labels[1].firstChild.data = value;
  }
};
CheckBox.property.disabled = {
  get: function () {
    return this.$input.disabled;
  },
  set: function (value) {
    value = !!value;
    this.$input.disabled = value;

    if (value) {
      this.addClass('as-disabled');
    } else {
      this.removeClass('as-disabled');
    }
  }
};
/***
 *
 * @type {{}|CheckBox}
 */

CheckBox.eventHandler = {};

CheckBox.eventHandler.click = function (event) {
  if (!_EventEmitter.default.hitElement(this.$input, event)) {
    this.$input.click();
  }
};

_ACore.default.install(CheckBox);

var _default = CheckBox;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/CheckboxButton.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/CheckboxButton.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/checkboxbutton.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _CheckBoxInput = _interopRequireDefault(require("./CheckBoxInput"));


_ACore.default.install('checkboxbutton', _CheckBoxInput.default);

var _default = _CheckBoxInput.default;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/ChromeTimePicker.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/ChromeTimePicker.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireWildcard(require("../ACore"));

require("../css/chrometimepicker.css");

var _DomSignal = _interopRequireDefault(require("absol/src/HTML5/DomSignal"));

var _datetime = require("absol/src/Time/datetime");




/***
 * @extends AElement
 * @constructor
 */
function ChromeTimePicker() {
  this._hour = 0;
  this._minute = 0;
  this.$lists = (0, _ACore.$$)('.as-chrome-time-picker-list', this);
  this.$hourList = this.$lists[0];
  this.$hourList.on('scroll', this.eventHandler.hourScroll).on('click', this.eventHandler.clickHourList);
  this.$hour24List = this.$lists[1];
  this.$hour24List.on('scroll', this.eventHandler.hour24Scroll).on('click', this.eventHandler.clickHour24List);
  this.$minList = this.$lists[2];
  this.$minList.on('scroll', this.eventHandler.minScroll).on('click', this.eventHandler.clickMinList);
  this.$attachhook = (0, _ACore._)('attachhook').addTo(this);
  this.domSignal = new _DomSignal.default(this.$attachhook).on('request_scroll_into_selected', this._scrollIntoSelected.bind(this));
  this.$amBtn = (0, _ACore.$)('.as-chrome-time-picker-btn[data-value="AM"]', this).on('click', this.eventHandler.clickAM);
  this.$pmBtn = (0, _ACore.$)('.as-chrome-time-picker-btn[data-value="PM"]', this).on('click', this.eventHandler.clickPM);
  this.scrollIntoSelected();
  this.hour = 0;
  this.minute = 0;
  this.s24 = false;
  (0, _ACore.$$)('.as-chrome-time-picker-scroller', this).forEach(this._makeScroller.bind(this));
}

ChromeTimePicker.tag = 'ChromeTimePicker'.toLowerCase();

ChromeTimePicker.render = function () {
  return (0, _ACore._)({
    class: 'as-chrome-time-picker',
    extendEvent: ['change'],
    child: [{
      class: ['as-chrome-time-picker-scroller', 'as-chrome-time-picker-scroller-h12'],
      child: [{
        tag: 'button',
        class: 'as-chrome-time-picker-scroller-up',
        child: 'span.mdi.mdi-chevron-up'
      }, {
        tag: 'button',
        class: 'as-chrome-time-picker-scroller-down',
        child: 'span.mdi.mdi-chevron-down'
      }, {
        class: ['as-chrome-time-picker-viewport', 'as-chrome-time-picker-h12'],
        child: {
          class: 'as-chrome-time-picker-list',
          child: Array(36).fill(0).map(function (u, i) {
            return {
              tag: 'button',
              class: 'as-chrome-time-picker-btn',
              child: {
                tag: 'span',
                child: {
                  text: i % 12 + 1 + ''
                }
              },
              props: {
                __hour__: i % 12 + 1
              }
            };
          })
        }
      }]
    }, {
      class: ['as-chrome-time-picker-scroller', 'as-chrome-time-picker-scroller-h24'],
      child: [{
        tag: 'button',
        class: 'as-chrome-time-picker-scroller-up',
        child: 'span.mdi.mdi-chevron-up'
      }, {
        tag: 'button',
        class: 'as-chrome-time-picker-scroller-down',
        child: 'span.mdi.mdi-chevron-down'
      }, {
        class: ['as-chrome-time-picker-viewport', 'as-chrome-time-picker-h24'],
        child: {
          class: 'as-chrome-time-picker-list',
          child: Array(24 * 3).fill(0).map(function (u, i) {
            return {
              tag: 'button',
              class: 'as-chrome-time-picker-btn',
              child: {
                tag: 'span',
                child: {
                  text: i % 24 + ''
                }
              },
              props: {
                __hour__: i % 24
              }
            };
          })
        }
      }]
    }, {
      class: 'as-chrome-time-picker-scroller',
      child: [{
        tag: 'button',
        class: 'as-chrome-time-picker-scroller-up',
        child: 'span.mdi.mdi-chevron-up'
      }, {
        tag: 'button',
        class: 'as-chrome-time-picker-scroller-down',
        child: 'span.mdi.mdi-chevron-down'
      }, {
        class: 'as-chrome-time-picker-viewport',
        child: {
          class: 'as-chrome-time-picker-list',
          child: Array(180).fill(0).map(function (u, i) {
            return {
              tag: 'button',
              class: 'as-chrome-time-picker-btn',
              child: {
                tag: 'span',
                child: {
                  text: i % 60 + ''
                }
              },
              props: {
                __min__: i % 60
              }
            };
          })
        }
      }]
    }, {
      class: ['as-chrome-time-picker-viewport', 'as-chrome-time-picker-period'],
      child: ['AM', 'PM'].map(function (u) {
        return {
          tag: 'button',
          class: 'as-chrome-time-picker-btn',
          attr: {
            'data-value': u
          },
          child: {
            tag: 'span',
            child: {
              text: u
            }
          },
          props: {
            __APM__: u
          }
        };
      })
    }]
  });
};

ChromeTimePicker.prototype._makeScroller = function (rootElt) {
  var upBtn = (0, _ACore.$)('.as-chrome-time-picker-scroller-up', rootElt);
  var downBtn = (0, _ACore.$)('.as-chrome-time-picker-scroller-down', rootElt);
  var listElt = (0, _ACore.$)('.as-chrome-time-picker-list', rootElt);
  var delta = 0;

  function tick() {
    if (delta === 0) return;
    listElt.scrollTop += delta;
    requestAnimationFrame(tick);
  }

  function cancel() {
    delta = 0;
    document.body.removeEventListener('mouseup', cancel);
    document.body.removeEventListener('mouseleave', cancel);
  }

  upBtn.on('mousedown', function () {
    delta = 5;
    document.body.addEventListener('mouseup', cancel);
    document.body.addEventListener('mouseleave', cancel);
    tick();
  });
  downBtn.on('mousedown', function () {
    delta = -5;
    document.body.addEventListener('mouseup', cancel);
    document.body.addEventListener('mouseleave', cancel);
    tick();
  });
};

ChromeTimePicker.prototype.scrollIntoSelected = function () {
  this.domSignal.emit('request_scroll_into_selected');
};

ChromeTimePicker.prototype._scrollIntoSelected = function () {
  var hour = this._hour;
  this.$hour24List.scrollTop = (hour + 24) * 28;
  hour = this._hour % 12;
  if (hour === 0) hour = 12;
  this.$hourList.scrollTop = (hour + 11) * 28;
  this.$minList.scrollTop = (this._minute + 60) * 28;
};

ChromeTimePicker.prototype.notifyChange = function (event) {
  this.emit('change', {
    type: 'change',
    originEvent: event,
    dayOffset: this.dayOffset,
    hour: this.hour,
    minute: this.minute,
    target: this
  }, this);
};

ChromeTimePicker.property = {};
ChromeTimePicker.property.hour = {
  set: function (value) {
    value = value % 24 || 0;
    var prevVal = this._hour;
    this.$hour24List.childNodes[prevVal].removeClass('as-selected');
    this.$hour24List.childNodes[prevVal + 24].removeClass('as-selected');
    this.$hour24List.childNodes[prevVal + 48].removeClass('as-selected');
    prevVal = this._hour % 12;
    if (prevVal === 0) prevVal = 12;
    this.$hourList.childNodes[prevVal - 1].removeClass('as-selected');
    this.$hourList.childNodes[prevVal - 1 + 12].removeClass('as-selected');
    this.$hourList.childNodes[prevVal - 1 + 24].removeClass('as-selected');
    this._hour = value;
    prevVal = this._hour;
    this.$hour24List.childNodes[prevVal].addClass('as-selected');
    this.$hour24List.childNodes[prevVal + 24].addClass('as-selected');
    this.$hour24List.childNodes[prevVal + 48].addClass('as-selected');
    prevVal = this._hour % 12;
    if (prevVal === 0) prevVal = 12;
    this.$hourList.childNodes[prevVal - 1].addClass('as-selected');
    this.$hourList.childNodes[prevVal - 1 + 12].addClass('as-selected');
    this.$hourList.childNodes[prevVal - 1 + 24].addClass('as-selected');

    if (this._hour >= 12) {
      this.$pmBtn.addClass('as-selected');
      this.$amBtn.removeClass('as-selected');
    } else {
      this.$amBtn.addClass('as-selected');
      this.$pmBtn.removeClass('as-selected');
    }
  },
  get: function () {
    return this._hour;
  }
};
ChromeTimePicker.property.minute = {
  set: function (value) {
    value = value % 60 || 0;
    var prevVal = this._minute;
    this.$minList.childNodes[prevVal].removeClass('as-selected');
    this.$minList.childNodes[prevVal + 60].removeClass('as-selected');
    this.$minList.childNodes[prevVal + 120].removeClass('as-selected');
    this._minute = value;
    prevVal = this._minute;
    this.$minList.childNodes[prevVal].addClass('as-selected');
    this.$minList.childNodes[prevVal + 60].addClass('as-selected');
    this.$minList.childNodes[prevVal + 120].addClass('as-selected');
  },
  get: function () {
    return this._minute;
  }
};
ChromeTimePicker.property.dayOffset = {
  set: function (value) {
    value = value || 0;
    if (value.getTime) value = value.getTime() - (0, _datetime.beginOfDay)(value).getTime();else {
      value = value % _datetime.MILLIS_PER_DAY;
    }
    this.hour = Math.floor(value / _datetime.MILLIS_PER_HOUR);
    this.minute = Math.floor(value % _datetime.MILLIS_PER_HOUR / _datetime.MILLIS_PER_MINUTE);
    this.domSignal.emit('request_scroll_into_selected');
  },
  get: function () {
    return this._hour * _datetime.MILLIS_PER_HOUR + this._minute * _datetime.MILLIS_PER_MINUTE;
  }
};
ChromeTimePicker.property.s24 = {
  set: function (value) {
    if (value) {
      this.addClass('as-24h-clock');
    } else {
      this.removeClass('as-24h-clock');
    }
  },
  get: function () {
    return this.containsClass('as-24h-clock');
  }
};
ChromeTimePicker.eventHandler = {};

ChromeTimePicker.eventHandler.hourScroll = function () {
  var y = this.$hourList.scrollTop;
  var dy = 0;
  if (y < 28 * 12) dy = 28 * 12;else if (y > 28 * 24) {
    dy = -28 * 12;
  }

  if (dy !== 0) {
    this.$hourList.scrollTop += dy;
  }
};

ChromeTimePicker.eventHandler.hour24Scroll = function () {
  var y = this.$hour24List.scrollTop;
  var dy = 0;
  if (y < 28 * 24) dy = 28 * 24;else if (y > 28 * 48) {
    dy = -28 * 24;
  }

  if (dy !== 0) {
    this.$hour24List.scrollTop += dy;
  }
};

ChromeTimePicker.eventHandler.minScroll = function () {
  var y = this.$minList.scrollTop;
  var dy = 0;
  if (y < 28 * 60) dy = 28 * 60;else if (y > 28 * 120) {
    dy = -28 * 60;
  }

  if (dy !== 0) {
    this.$minList.scrollTop += dy;
  }
};

ChromeTimePicker.eventHandler.clickHourList = function (event) {
  var hour;
  if ('__hour__' in event.target) hour = event.target.__hour__;
  if ('__hour__' in event.target.parentElement) hour = event.target.parentElement.__hour__;

  if (hour !== undefined) {
    if (this.hour >= 12) {
      this.hour = hour === 12 ? hour : hour + 12;
    } else {
      this.hour = hour === 12 ? 0 : hour;
    }

    if ((hour - 1 + 12) * 28 < this.$hourList.scrollTop) {
      this.$hourList.scrollTop = (hour - 1 + 12) * 28;
    } else if ((hour - 1 + 13) * 28 > this.$hourList.scrollTop + this.$hourList.clientHeight) {
      this.$hourList.scrollTop = (hour - 1 + 13) * 28 - this.$hourList.clientHeight;
    }

    this.notifyChange(event);
  }
};

ChromeTimePicker.eventHandler.clickHour24List = function (event) {
  var hour;
  if ('__hour__' in event.target) hour = event.target.__hour__;
  if ('__hour__' in event.target.parentElement) hour = event.target.parentElement.__hour__;

  if (hour !== undefined) {
    this.hour = hour;

    if ((hour + 24) * 28 < this.$hourList.scrollTop) {
      this.$hourList.scrollTop = (hour + 24) * 28;
    } else if ((hour + 24) * 28 > this.$hourList.scrollTop + this.$hourList.clientHeight) {
      this.$hourList.scrollTop = (hour + 24) * 28 - this.$hourList.clientHeight;
    }

    this.notifyChange(event);
  }
};

ChromeTimePicker.eventHandler.clickMinList = function (event) {
  var min;
  if ('__min__' in event.target) min = event.target.__min__;
  if ('__min__' in event.target.parentElement) min = event.target.parentElement.__min__;

  if (min !== undefined) {
    this.minute = min;

    if ((min + 60) * 28 < this.$minList.scrollTop) {
      this.$minList.scrollTop = (min + 60) * 28;
    } else if ((min + 61) * 28 > this.$minList.scrollTop + this.$minList.clientHeight) {
      this.$minList.scrollTop = (min + 61) * 28 - this.$minList.clientHeight;
    }

    this.notifyChange(event);
  }
};

ChromeTimePicker.eventHandler.clickPM = function (event) {
  if (this.hour < 12) this.hour += 12;
  this.notifyChange(event);
};

ChromeTimePicker.eventHandler.clickAM = function (event) {
  if (this.hour >= 12) this.hour -= 12;
  this.notifyChange(event);
};

_ACore.default.install(ChromeTimePicker);

var _default = ChromeTimePicker;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/Svg.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/Svg.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.svgToRasterImageUrl = svgToRasterImageUrl;
exports.svgToExportedString = svgToExportedString;
exports.default = void 0;

var _Dom = _interopRequireWildcard(require("./Dom"));

var _ElementNS = _interopRequireDefault(require("./ElementNS"));

var _Element = _interopRequireDefault(require("./Element"));




var sattachhookCreator = function () {
  var res = Svg.ShareInstance._('<image  class="absol-attachhook" style="display:none"  href=""/>');

  res.defineEvent('attached');
  res.on('error', function (event) {
    if (!this._attached && this.isDescendantOf(document.body)) {
      this._attached = true;
      this.emit('attached', event, this);
    }
  });
  res._attached = false;
  Object.defineProperty(res, 'attached', {
    get: function () {
      return this._attached;
    }
  });

  res.resetState = function () {
    this._attached = false;
    this.src = '';
  };

  return res;
};
/***
 * @extends Dom
 * @param option
 * @constructor
 */


function Svg(option) {
  _Dom.default.call(this, option);

  this.defaultTag = 'g';
  this.svgNS = "http://www.w3.org/2000/svg";
  Object.defineProperties(this.creator, {
    sattachhook: {
      set: function () {//do nothing
      },
      get: function () {
        return sattachhookCreator;
      }
    }
  });
  delete this.buidDom;
  this.buildSvg = this.create.bind(this);
}

Object.defineProperties(Svg.prototype, Object.getOwnPropertyDescriptors(_Dom.default.prototype));

Svg.prototype.fromCode = function (code) {
  code = code.trim();
  var receptacle = document.createElement('div');
  var element;
  var prototypes;

  if (code.startsWith('<svg')) {
    receptacle.innerHTML = code;
    element = receptacle.childNodes[0];
    prototypes = Object.getOwnPropertyDescriptors(_Element.default.prototype);
    Object.defineProperties(element, prototypes);

    _Element.default.call(element);
  } else {
    var svgfragment = '<svg  version="1.1" xmlns="http://www.w3.org/2000/svg">' + code + '</svg>';
    receptacle.innerHTML = '' + svgfragment;
    element = receptacle.childNodes[0].childNodes[0];
    prototypes = Object.getOwnPropertyDescriptors(_ElementNS.default.prototype);
    Object.defineProperties(element, prototypes);

    _ElementNS.default.call(element);
  }

  return element;
};

Svg.prototype.makeNewElement = function (tagName) {
  return document.createElementNS(this.svgNS, tagName);
};

Svg.ShareInstance = new Svg();

Svg.svgToCanvas = function (element) {
  if (typeof element == 'string') {
    element = _Dom.default.ShareInstance.$(element);
  }

  if (element && element.tagName == 'svg') {
    var cssTexts = {};

    var depthClone = function (originElt) {
      var newElt = originElt.cloneNode(); //no deep

      if (!originElt.getAttributeNS) return newElt; //is text node

      var cssRules = _Element.default.prototype.getCSSRules.call(originElt);

      var cssKey = cssRules.reduce(function (ac, rule) {
        for (var i = 0; i < rule.style.length; ++i) {
          ac[rule.style[i]] = true;
        }

        return ac;
      }, {});

      for (var key in cssKey) {
        newElt.style[key] = _Element.default.prototype.getComputedStyleValue.call(originElt, key);
      }

      var children = Array.prototype.map.call(originElt.childNodes, depthClone);

      for (var i = 0; i < children.length; ++i) {
        newElt.appendChild(children[i]);
      }

      return newElt;
    };

    var cloneElement = depthClone(element);

    var renderSpace = _Dom.default.ShareInstance._({
      style: {
        // opacity:0,
        zIndex: -1000,
        position: 'fixed',
        top: 0,
        bottom: 0
      }
    }).addTo(document.body);

    renderSpace.addChild(cloneElement);
    var svgCode = renderSpace.innerHTML;
    renderSpace.clearChild();
    var mBlob = new Blob([svgCode], {
      type: "image/svg+xml;charset=utf-8"
    });
    var src = (URL || webkitURL).createObjectURL(mBlob);

    var image = _Dom.default.ShareInstance._('img');

    image.attr('src', src).addTo(renderSpace);
    var canvas = document.createElement("canvas");
    renderSpace.addChild(canvas);
    return _Dom.default.waitImageLoaded(image).then(function () {
      canvas.width = image.width;
      canvas.height = image.height;
      var context = canvas.getContext("2d");
      context.drawImage(image, 0, 0);
      renderSpace.selfRemove();
      return canvas;
    });
  } else {
    throw new Error('Element must be svg');
  }
};

function svgToRasterImageUrl(element) {
  return Svg.svgToCanvas(element).then(function (canvas) {
    return canvas.toDataURL();
  });
}

Svg.svgToRasterImageUrl = svgToRasterImageUrl;

function svgToExportedString(element) {
  if (typeof element == 'string') {
    element = _Dom.default.ShareInstance.$(element);
  }

  if (element && element.tagName == 'svg') {
    var depthClone = function (originElt) {
      var newElt = originElt.cloneNode(); //no deep

      if (!originElt.getAttributeNS) return newElt; //is text node

      var cssRules = _Element.default.prototype.getCSSRules.call(originElt);

      var cssKey = cssRules.reduce(function (ac, rule) {
        for (var i = 0; i < rule.style.length; ++i) {
          ac[rule.style[i]] = true;
        }

        return ac;
      }, {});

      for (var key in cssKey) {
        newElt.style[key] = _Element.default.prototype.getComputedStyleValue.call(originElt, key);
      }

      var children = Array.prototype.map.call(originElt.childNodes, depthClone);

      for (var i = 0; i < children.length; ++i) {
        newElt.appendChild(children[i]);
      }

      return newElt;
    };

    var cloneElement = depthClone(element);

    var renderSpace = _Dom.default.ShareInstance._({
      style: {
        // opacity:0,
        zIndex: -1000,
        position: 'fixed',
        top: 0,
        bottom: 0
      }
    }).addTo(document.body);

    renderSpace.addChild(cloneElement);
    var svgCode = renderSpace.innerHTML;
    renderSpace.selfRemove();
    return svgCode;
  } else {
    throw new Error('Element must be svg');
  }
}

;
Svg.svgToExportedString = svgToExportedString;

function svgToSvgUrl(element) {
  var svg = svgToExportedString(element);
  svg = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n' + svg;
  var blob = new Blob([svg], {
    type: 'image/svg+xml'
  });
  var url = URL.createObjectURL(blob);
  return url;
}

Svg.svgToSvgUrl = svgToSvgUrl;

_Dom.default.printElement = function (option) {
  var _ = _Dom.default.ShareInstance._;
  var $ = _Dom.default.ShareInstance.$;
  option = option || {};

  if (typeof option == 'string') {
    option = {
      elt: _Dom.default.ShareInstance.$(option)
    };
  } else if (typeof option.elt == 'string') {
    option.elt = $(option.elt);
  } else if (_Dom.default.isDomNode(option)) {
    option = {
      elt: option
    };
  }

  if (_Dom.default.isDomNode(option.elt)) {
    function afterCloneCb(originElt, newElt) {
      if (!newElt.tagName) return;
      var tagName = newElt.tagName.toLowerCase();
      if (newElt.getBBox && tagName !== 'svg') return;
      var url, img;
      var needCopyStyle = option.computeStyle;
      if (!newElt.tagName) console.log(newElt.nodeType, newElt);

      if (tagName === 'canvas' || tagName === 'svg') {
        if (tagName === "canvas") {
          url = originElt.toDataURL();
        } else {
          url = svgToSvgUrl(originElt);
        }

        img = _({
          tag: 'img',
          props: {
            src: url
          }
        });
        $(newElt).selfReplace(img);
        newElt = img;
        needCopyStyle = true;
      } else if (tagName === 'script') {
        newElt.remove();
      } else if (tagName === 'img') {
        newElt.setAttribute('src', originElt.src);
      }

      if (needCopyStyle) {
        (0, _Dom.copyStyleRule)(originElt, newElt);
      }

      return newElt;
    }

    var newElt = (0, _Dom.depthClone)(option.elt, afterCloneCb);

    var renderSpace = _({
      style: {
        position: 'fixed',
        top: '0',
        left: '0',
        right: '0',
        bottom: '0',
        overflow: 'auto',
        zIndex: '10',
        opacity: '0',
        visibility: 'hidden'
      }
    });

    $('link', document.head, function (elt) {
      renderSpace.addChild(elt.cloneNode(false));
    });

    if (!option.computeStyle) {
      $('style', document.head, function (elt) {
        if (elt == _Dom.default.$printStyle) return;
        renderSpace.addChild(elt.cloneNode(true));
      });
    }

    renderSpace.addChild(newElt);
    var eltCode = renderSpace.innerHTML;
    renderSpace.clearChild();
    option.title = option.title || ($('title', document.head) || {
      innerHTML: 'absol.js'
    }).innerHTML;
    var htmlCode = ['<ht' + 'ml>', ' <h' + 'ead><title>' + option.title + '</title><meta charset="UTF-8">', '<style>', option.overideStyle ? 'html, body{width:initial !important; height:initial !important; overflow: initial !important; overflow-x: initial !important;overflow-y: initial !important;  }' : '', '@media print {', //still not work
    '    body{', '      -webkit-print-color-adjust: exact;', '       color-adjust: exact;', '    } ', '    div, tr, td, table{', '    }', '  }', 'div, table, tr, td{', '    page-break-inside: initial;', '    page-break-before: avoid;', '    page-break-after: avoid;', '}', option.extendCss || '', '</style>', '</he' + 'ad>', '<bod' + 'y>', eltCode, '<scr' + 'ipt>' + (option.extendScript || '') + '</scri' + 'pt>', //browser parse  script tag fail
    '<scr' + 'ipt>setTimeout(function(){ window.print();},1000);</scri' + 'pt>', //browser parse  script tag fail
    '</bod' + 'y>', '</ht' + 'ml>'].join('\n');
    var blob = new Blob([htmlCode], {
      type: 'text/html; charset=UTF-8'
    });
    renderSpace.addTo(document.body);

    var iframe = _('iframe').attr('src', URL.createObjectURL(blob)).addStyle({
      width: '100%',
      height: '100%'
    }).addTo(renderSpace);

    return new Promise(function (rs, rj) {
      function waitLoad() {
        if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.body) {
          if (typeof option.onLoad == 'function') option.onLoad();
          iframe.contentWindow.focus();
          setTimeout(function () {
            function waitFocusBack() {
              if (!document.hasFocus || document.hasFocus()) {
                renderSpace.remove();
                if (typeof option.onFinish == 'function') option.onFinish();
                rs();
              } else {
                setTimeout(waitFocusBack, 300);
              }
            }

            waitFocusBack();
          }, 4000);
        } else setTimeout(waitLoad, 1000);
      }

      waitLoad();
    });
  } else {
    throw new Error('Invalid param!');
  }
};

var _default = Svg;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/CircleSectionLabel.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/CircleSectionLabel.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/circlesectionlabel.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Svg = _interopRequireDefault(require("absol/src/HTML5/Svg"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
var _g = _Svg.default.ShareInstance._;
var $g = _Svg.default.ShareInstance.$;
var Design = {
  circleHeight: 218 - 36,
  borderWidth: 36,
  textBoxHeight: 146,
  textHeight: 48,
  indexHeight: 54,
  textBoxPaddingLeft: 80,
  indexArrowRadius: (172 - 18) / 2,
  indexArrowStrokeWidth: 18,
  indexArrowStartAngle: -Math.PI / 6,
  indexArrowEndAngle: -7 * Math.PI / 12
};
var StyleSheet = {
  '.as-circle-section-label-text': {
    height: Design.textBoxHeight / Design.textHeight + 'em',
    'padding-left': Design.textBoxPaddingLeft / Design.textHeight + 'em',
    'line-height': Design.textBoxHeight / Design.textHeight + 'em'
  },
  '.as-circle-section-label-index': {
    'font-size': Design.indexHeight / Design.textHeight + 'em',
    height: (Design.circleHeight + Design.borderWidth) / Design.indexHeight + 'em',
    'line-height': (Design.circleHeight + Design.borderWidth) / Design.indexHeight + 'em',
    width: (Design.circleHeight + Design.borderWidth) / Design.indexHeight + 'em'
  }
};

_({
  tag: 'style',
  id: 'circle-section-label-style',
  props: {
    innerHTML: Object.keys(StyleSheet).map(function (key) {
      var style = StyleSheet[key];
      return key + ' {\n' + Object.keys(style).map(function (propName) {
        return propName + ': ' + style[propName] + ';';
      }).join('\n') + '}';
    }).join('\n')
  }
}).addTo(document.head);
/**
 * @extends AElement
 * @constructor
 */


function CircleSectionLabel() {
  this._ident = (Math.random() + '').replace(/[^0-9]/g, '_');
  this.$background = $('.as-circle-section-label-background', this);
  this.$index = $('.as-circle-section-label-index', this);
  this.$text = $('.as-circle-section-label-text', this);
  this.$attachhook = _('attachhook').addTo(this).on('error', function () {
    _Dom.default.addToResizeSystem(this);

    this.requestUpdateSize();
  });
  this.$attachhook.requestUpdateSize = this.redrawBackground.bind(this);
  this.$svg = _g({
    tag: 'svg',
    attr: {
      width: '0',
      height: '0'
    },
    child: [{
      tag: 'defs',
      child: [{
        tag: 'marker',
        id: 'marker_' + this._ident,
        attr: {
          markerWidth: "4",
          markerHeight: "4",
          refX: "0",
          refY: "1",
          orient: "auto",
          markerUnits: "strokeWidth",
          viewBox: "0 0 4 4"
        },
        child: {
          tag: 'path',
          class: 'as-circle-section-label-arrow-marker-path',
          attr: {
            d: 'M0,0 L0,2 L2,1 z'
          }
        }
      }]
    }, 'rect.as-circle-section-label-text-box', 'circle.as-circle-section-label-index-box', 'path.as-circle-section-label-arrow']
  }).addTo(this.$background);
  this.$indexBox = $g('circle.as-circle-section-label-index-box', this.$svg);
  this.$textBox = $g('rect.as-circle-section-label-text-box', this.$svg); // this.$marker = $g('defs marker', this.$svg);
  // this.$markerPath = $g(' path', this.$marker);

  this.$arrow = $g('path.as-circle-section-label-arrow', this.$svg).attr({
    'marker-end': "url(" + '#marker_' + this._ident + ")"
  });
}

;

CircleSectionLabel.prototype.redrawBackground = function () {
  var indexBound = this.$index.getBoundingClientRect();
  var textBound = this.$text.getBoundingClientRect();
  var cHeight = indexBound.height;
  var cWidth = textBound.right - indexBound.left;
  this.$svg.attr({
    height: cHeight + '',
    width: cWidth + '',
    viewBox: [0, 0, cWidth, cHeight].join(' ')
  });
  var borderWidth = cHeight * Design.borderWidth / (Design.circleHeight + Design.borderWidth);
  var radius = cHeight * Design.circleHeight / (Design.circleHeight + Design.borderWidth) / 2;
  var x0 = indexBound.width / 2;
  var y0 = cHeight / 2;
  this.$indexBox.attr({
    r: radius + '',
    cx: x0,
    cy: y0
  }).addStyle({
    strokeWidth: borderWidth + ''
  });
  var textBoxHeight = textBound.height;
  this.$textBox.attr({
    x: x0 / 2,
    y: (cHeight - textBoxHeight) / 2,
    width: cWidth - x0 - 1,
    height: textBoxHeight,
    rx: textBoxHeight / 2,
    ry: textBoxHeight / 2
  });
  var arrowRadius = cHeight * Design.indexArrowRadius / (Design.circleHeight + Design.borderWidth);
  this.$arrow.attr({
    d: ['M', x0 + arrowRadius * Math.cos(Design.indexArrowStartAngle), y0 + arrowRadius * Math.sin(Design.indexArrowStartAngle), 'A', arrowRadius, arrowRadius, 0, 1, 1, x0 + arrowRadius * Math.cos(Design.indexArrowEndAngle), y0 + arrowRadius * Math.sin(Design.indexArrowEndAngle)].join(' ')
  }).addStyle('stroke-width', cHeight * Design.indexArrowStrokeWidth / (Design.circleHeight + Design.borderWidth));
};

CircleSectionLabel.tag = 'CircleSectionLabel'.toLowerCase();

CircleSectionLabel.render = function () {
  return _({
    class: 'as-circle-section-label',
    child: [{
      class: 'as-circle-section-label-background'
    }, '.as-circle-section-label-index', '.as-circle-section-label-text']
  });
};

CircleSectionLabel.property = {};
CircleSectionLabel.property.index = {
  set: function (value) {
    this._index = value;
    this.$index.clearChild().addChild(_({
      text: value + ''
    }));
  },
  get: function () {
    return this._index;
  }
};
CircleSectionLabel.property.text = {
  set: function (value) {
    this._text = value;
    this.$text.clearChild().addChild(_({
      text: value + ''
    }));
  },
  get: function () {
    return this._text;
  }
};

_ACore.default.install(CircleSectionLabel);

var _default = CircleSectionLabel;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Follower.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Follower.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/follower.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _Rectangle = _interopRequireDefault(require("absol/src/Math/Rectangle"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function Follower() {
  this.$attachhook = _('attachhook', this).addTo(this).on('attached', function () {
    this.requestUpdateSize();

    _Dom.default.addToResizeSystem(this);
  });
  this.$attachhook.requestUpdateSize = this.updatePosition.bind(this);
  this.$followTarget = undefined;
  this.$scrollTrackElts = [];
  this._scrollTrackEventHandler = undefined;
  this._anchor = Follower.ANCHOR_PRIORITY;
  this.defineEvent(['updateposition', 'preupdateposition']);
}

Follower.tag = 'Follower'.toLowerCase();

Follower.render = function () {
  return _('.absol-follower');
};

Follower.prototype.clearChild = function () {
  var children = Array.prototype.slice.call(this.children);
  var attachhookElt = this.$attachhook;
  children.forEach(function (elt) {
    if (elt != attachhookElt) elt.remove();
  });
}; //Todo: remove child, find child....

/**
 * X = $target.x + F[anchor_index][0] * $target.width + F[anchor_index][1] * $content.width
 * Y = $target.y + F[anchor_index][2] * $target.height + F[anchor_index][3] * $content.height
 */


Follower.ANCHOR_FACTORS = [[1, 0, 0, 0], //0
[0, 0, 1, 0], //1
[1, -1, 1, 0], //2
[0, -1, 0, 0], //3
[0, -1, 1, -1], //4
[1, -1, 0, -1], //5
[0, 0, 0, -1], //6
[1, 0, 1, -1], //7
[1, 0, 0.5, -0.5], //8
[0.5, -0.5, 1, 0], //9
[0, -1, 0.5, -0.5], //10
[0.5, -0.5, 0, -1], //11
[1, 0, 1, 0], //12
[0, -1, 1, 0], //13
[0, -1, 0, -1], //14
[1, 0, 0, -1] //15
];
Follower.ANCHOR_PRIORITY = [1, 6, 2, 5, 0, 7, 3, 4, 9, 11, 8, 10, 12, 15, 13, 14];

Follower.prototype.updatePosition = function () {
  if (!this.$followTarget) return;
  this.emit('preupdateposition', {
    target: this
  }, this);
  var targetBound = this.$followTarget.getBoundingClientRect();

  var screenSize = _Dom.default.getScreenSize();

  var outRect = new _Rectangle.default(0, 0, screenSize.width, screenSize.height);
  var bound = this.getBoundingClientRect();
  var x = 0;
  var y = 0;
  var score;
  var anchors = this._lastAnchor === undefined ? this.anchor : [this._lastAnchor].concat(this.anchor);
  var factor;
  var bestX,
      bestY,
      bestScore = -100000;
  var newContentRect;
  var bestAnchor;

  for (var i = 0; i < anchors.length; ++i) {
    factor = Follower.ANCHOR_FACTORS[anchors[i]];
    x = targetBound.left + factor[0] * targetBound.width + factor[1] * bound.width;
    y = targetBound.top + factor[2] * targetBound.height + factor[3] * bound.height;
    newContentRect = new _Rectangle.default(x, y, bound.width, bound.height);
    score = newContentRect.collapsedSquare(outRect);

    if (score - 10 > bestScore) {
      bestAnchor = anchors[i];
      bestScore = score;
      bestX = x;
      bestY = y;
    }
  }

  if (this._lastAnchor !== bestAnchor) {
    this.removeClass('as-anchor-' + this._lastAnchor);
    this._lastAnchor = bestAnchor;
    this.addClass('as-anchor-' + this._lastAnchor);
  }

  this.addStyle({
    left: bestX + 'px',
    top: bestY + 'px'
  });
  this.emit('updateposition', {
    target: this
  }, this);
};

Follower.prototype.refollow = function () {
  if (!this.$followTarget) return;
  this.updatePosition();
  this.addClass('following');
  if (this._scrollTrackEventHandler) this.unfollow();
  this._scrollTrackEventHandler = this.updatePosition.bind(this);
  this.$scrollTrackElts = [];
  var trackElt = this.$followTarget;

  while (trackElt) {
    if (trackElt.addEventListener) trackElt.addEventListener('scroll', this._scrollTrackEventHandler, false);else trackElt.attachEvent('onscroll', this._scrollTrackEventHandler, false);
    this.$scrollTrackElts.push(trackElt);
    trackElt = trackElt.parentElement;
  }

  if (document.addEventListener) {
    document.addEventListener('scroll', this._scrollTrackEventHandler, false);
  } else {
    document.attachEvent('onscroll', this._scrollTrackEventHandler, false);
  }

  this.$scrollTrackElts.push(document);
};

Follower.prototype.unfollow = function () {
  if (!this._scrollTrackEventHandler) return; // nothing to do

  this.removeClass('following');
  var trackElt;

  for (var i = 0; i < this.$scrollTrackElts.length; ++i) {
    trackElt = this.$scrollTrackElts[i];
    if (trackElt.removeEventListener) trackElt.removeEventListener('scroll', this._scrollTrackEventHandler, false);else trackElt.dettachEvent('onscroll', this._scrollTrackEventHandler, false);
  }

  this.$scrollTrackElts = [];
  this._scrollTrackEventHandler = undefined;
};

Follower.property = {};
Follower.property.followTarget = {
  set: function (elt) {
    if (elt === null || elt === undefined || !elt) {
      this.unfollow();
      this.$followTarget = undefined;
      return;
    } else if (typeof elt == 'string') {
      elt = $(elt) || document.getElementById(elt);
    }

    if (_Dom.default.isDomNode(elt)) {
      this.$followTarget = elt;
      this._lastAncho = undefined;
      this.refollow();
    } else throw new Error("Invalid element");
  },
  get: function () {
    return this.$followTarget;
  }
};
Follower.property.anchor = {
  set: function (value) {
    value = value || Follower.ANCHOR_PRIORITY;
    if (value == 'auto') value = Follower.ANCHOR_PRIORITY;
    if (typeof value == null) value = [value];
    if (!(value instanceof Array)) throw new Error('Invalid anchor ' + value);
    value = value.map(function (x) {
      x = Math.floor(x);

      if (x >= 0 && x < Follower.ANCHOR_FACTORS.length) {
        return x;
      } else throw new Error("Invalid anchor: " + x);
    });
    this._anchor = value;
    this._lastAnchor = undefined;
    this.updatePosition();
  },
  get: function () {
    return this._anchor;
  }
};

_ACore.default.install(Follower);

var _default = Follower;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Menu.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Menu.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuButton = MenuButton;
exports.Dropdown = Dropdown;
exports.Dropright = Dropright;
exports.VMenuLine = VMenuLine;
exports.VMenuItem = VMenuItem;
exports.VMenu = VMenu;
exports.HMenuItem = HMenuItem;
exports.HMenu = HMenu;
exports.VRootMenu = VRootMenu;

require("../css/menu.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireWildcard(require("absol/src/HTML5/Dom"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _Follower = _interopRequireDefault(require("./Follower"));




var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function MenuButton() {
  this.$text = $('.absol-vmenu-button-text', this);
  this.$key = $('.absol-vmenu-button-key', this);
  this.$arrow = $('.absol-vmenu-arrow', this);
  this.$iconCtn = $('.absol-vmenu-button-ext-icon-container', this);

  _OOP.default.drillProperty(this, this.$text, 'text', 'innerHTML');

  _OOP.default.drillProperty(this, this.$key, 'key', 'innerHTML');
}

MenuButton.tag = 'menubutton';

MenuButton.render = function () {
  return _({
    tag: 'button',
    class: 'absol-vmenu-button',
    child: [{
      class: 'absol-vmenu-button-ext-icon-container',
      child: 'img.absol-vmenu-button-icon'
    }, '.absol-vmenu-button-text', '.absol-vmenu-button-key', {
      class: 'absol-vmenu-arrow-container',
      child: 'span.absol-vmenu-arrow'
    }]
  });
};

MenuButton.property = {};
MenuButton.property.extendClasses = {
  set: function (value) {
    var self = this;
    this.extendClasses.forEach(function (className) {
      self.removeClass(className);
    });
    this._extendClass = [];
    if (!value) return;

    if (typeof value == 'string') {
      value = value.split(/\s+/).filter(function (c) {
        return c.length > 0;
      });
    }

    if (value instanceof Array) {
      this._extendClass = value;

      this._extendClass.forEach(function (className) {
        self.addClass(className);
      });
    } else {
      throw new Error('Invalid extendClasses');
    }
  },
  get: function () {
    return this._extendClass || [];
  }
};
MenuButton.property.icon = {
  set: function (value) {
    this.$iconCtn.clearChild();
    this._icon = value;

    if (value) {
      _(value).addTo(this.$iconCtn);
    }
  },
  get: function () {
    return this._icon;
  }
};
MenuButton.property.iconSrc = {
  set: function (value) {
    if (value) this.icon = {
      tag: 'img',
      props: {
        src: value
      }
    };else this.icon = value;
  },
  get: function () {
    return this.icon && this.icon.props && this.icon.props.src;
  }
};
MenuButton.property.extendStyle = {
  set: function (value) {
    this.removeStyle(this._extendStyle || {});
    this._extendStyle = value || {};
    this.addStyle(this.extendStyle);
  },
  get: function () {
    return this._extendStyle || {};
  }
};

_ACore.default.install(MenuButton);
/***
 *
 * @extends Follower
 * @constructor
 */


function Dropdown() {
  this.$container = $('.absol-dropdown-content', this);
  this.$container.followTarget = this;
  this.$container.anchor = [1, 2, 6, 5];
}

Dropdown.tag = 'dropdown';

Dropdown.render = function () {
  return _({
    class: ['absol-drop-hidden', 'absol-dropdown'],
    child: 'follower.absol-dropdown-content.as-bscroller'
  });
};

Dropdown.property = {};
Dropdown.property.show = {
  set: function (value) {
    if (value) {
      this.removeClass('absol-drop-hidden');

      if (this.$container.lastChild && this.$container.lastChild.$items) {
        this.$container.lastChild.$items.forEach(function (itemElt) {
          if (itemElt.autoFixParrentSize) {
            itemElt.autoFixParrentSize();
          }
        });
      }

      var aPst = this.findAvailablePosition();

      if (aPst.crampedHeight) {
        this.removeClass('overlap-top');
        this.$container.followTarget = null;
        this.$container.addStyle({
          'max-height': aPst.maxHeight + 'px'
        });
        this.$container.refollow();
        this.$container.updatePosition();
        this.$container.addStyle('top', this.getBoundingClientRect().top + aPst.posTop + 'px');
      } else {
        this.$container.removeStyle('max-height').removeStyle('top');
        this.$container.refollow();
        this.$container.updatePosition();
      }
    } else {
      this.addClass('absol-drop-hidden');
    }
  },
  get: function () {
    return !this.containsClass('absol-drop-hidden');
  }
};

Dropdown.prototype.findAvailablePosition = function () {
  var outBound = _Dom.default.traceOutBoundingClientRect(document.body);

  var containerBound = this.$container.getBoundingClientRect();
  var bound = this.getBoundingClientRect();
  var distTop = bound.top - outBound.top;
  var distLeft = bound.left - outBound.left;
  var distRight = -bound.right + outBound.right;
  var distBottom = -bound.bottom + outBound.bottom;
  var result = {};
  if (distLeft >= containerBound.width) result.left = true;
  if (distTop >= containerBound.height) result.top = true;
  if (distRight >= containerBound.width) result.right = true;
  if (distBottom >= containerBound.height) result.bottom = true;
  if (distRight + bound.width >= containerBound.width) result.overlapRight = true;
  if (distLeft + bound.width >= containerBound.width) result.overlapLeft = true;
  if (distBottom + bound.height >= containerBound.height) result.overlapBottom = true;
  if (distTop + bound.height >= containerBound.height) result.overlapTop = true;

  if (!result.overlapTop && !result.overlapBottom) {
    result.crampedHeight = true;
    result.maxHeight = outBound.height - 20;
    result.posTop = distBottom - Math.min(containerBound.height, result.maxHeight) + bound.height - 10;
  }

  return result;
};

Dropdown.prototype.addChild = function (child) {
  if (child instanceof Array) {
    for (var i = 0; i < child.length; ++i) this.addChild(child[i]);
  } else {
    if (!this.$trigger) {
      this.super(child);
      this.$trigger = child;
    } else {
      this.$container.addChild(child);
    }
  }
};

Dropdown.prototype.clearChild = function () {
  if (this.$trigger) {
    this.$trigger.selfRemove();
    this.$trigger = undefined;
  }

  this.$container.clearChild();
};

Dropdown.prototype.init = function (props) {
  props = props || {};
  Object.assign(this, props);
};

function Dropright() {
  this.$container = $('.absol-dropright-content', this);
  this.$container.followTarget = this;
  this.$container.anchor = [0, 3, 7, 4];
}

Dropright.tag = 'dropright';

Dropright.render = function () {
  return _({
    class: ['absol-drop-hidden', 'absol-dropright'],
    child: 'follower.absol-dropright-content.as-bscroller',
    data: {
      $trigger: undefined,
      $content: undefined,
      _isShow: false
    }
  });
};

Object.assign(Dropright.prototype, Dropdown.prototype); //is the same

Dropright.prototype.addChild = Dropdown.prototype.addChild;
Dropright.prototype.clearChild = Dropdown.prototype.clearChild;
Dropright.property = Object.assign({}, Dropdown.property);

function VMenuLine() {
  return _('<div class="absol-vmenu-line"><div></div></div>');
}

VMenuLine.tag = 'VMenuLine'.toLowerCase();

function VMenuItem() {
  var thisVM = this;
  this.sync = new Promise(function (rs) {
    _('attachhook').addTo(thisVM).on('error', function () {
      this.remove();
      rs();
    });
  });
  this.$dropper = $('dropright', this);
  this.$vmenu = $('vmenu', this);
  this.$button = $('menubutton', this);
  this.$text = thisVM.$button.$text;
  this.$key = thisVM.$button.$key;
  this.$arrow = thisVM.$button.$arrow;
  this.$iconCtn = thisVM.$button.$iconCtn;

  _OOP.default.drillProperty(this, this.$button, ['text', 'extendClasses', 'extendStyle', 'key', 'icon', 'iconSrc']);

  _OOP.default.drillProperty(this, this.$vmenu, ['activeTab']);

  this.eventHandler = _OOP.default.bindFunctions(this, VMenuItem.eventHandler);
  this.$vmenu.on('press', this.eventHandler.pressItem, true);
  this.$button.on('click', this.eventHandler.clickButton, true);
  this.$button.on('mouseenter', this.eventHandler.enterButton, true);
  this._textMarginRight = 0;
}

VMenuItem.tag = 'VMenuItem'.toLowerCase();

VMenuItem.render = function () {
  return _({
    tag: 'dropright',
    extendEvent: ['press', 'enter'],
    child: ['menubutton', {
      tag: 'vmenu'
    }]
  });
};

VMenuItem.prototype.init = function (props) {
  Object.assign(this, props || {});
  this.sync = this.sync.then(this.autoFixParrentSize.bind(this));
};

VMenuItem.prototype.autoFixParrentSize = function () {
  var parentWidth = this.$dropper.getBoundingClientRect().width; // dropper is fixed parent content size

  if (!parentWidth) return;
  var buttonWidth = this.$button.getBoundingClientRect().width;
  var fontSize = this.$text.getFontSize();
  this._textMarginRight = parentWidth - buttonWidth + this._textMarginRight;
  this.$text.addStyle('margin-right', this._textMarginRight / fontSize + 'em');
};

VMenuItem.eventHandler = {};

VMenuItem.eventHandler.enterButton = function (event) {
  event.menuItem = this;

  var newEvent = _EventEmitter.default.copyEvent(event);

  this.emit('enter', newEvent, this);
};

VMenuItem.eventHandler.pressItem = function (event) {
  var newEvent = _EventEmitter.default.copyEvent(event, {
    target: this
  });

  this.emit('press', newEvent, this);
};

VMenuItem.eventHandler.clickButton = function (event) {
  event.menuDontHide = this.items && this.items.length > 0;
  event.menuItem = this;
  event.vmenuItem = this;

  var newEvent = _EventEmitter.default.copyEvent(event, {
    target: this
  });

  this.emit('press', newEvent, this);
};

VMenuItem.property = {};
VMenuItem.property.items = {
  set: function (items) {
    items = items || [];

    if (items.length > 0) {
      this.$arrow.addClass(['mdi', 'mdi-chevron-right']);
    } else {
      this.$arrow.removeClass(['mdi', 'mdi-chevron-right']);
    }

    this.$vmenu.items = items;
  },
  get: function () {
    return this.$vmenu.items;
  }
};
VMenuItem.property.disable = {
  set: function (value) {
    if (value) {
      this.addClass('absol-menu-item-disable');
    } else {
      this.removeClass('absol-menu-item-disable');
    }
  },
  get: function () {
    return this.containsClass('absol-menu-item-disable');
  }
};

function VMenu() {
  var thisVM = this;
  this.sync = new Promise(function (rs) {
    _('attachhook').addTo(thisVM).on('error', function () {
      this.remove();
      rs();
    });
  });
}

VMenu.tag = 'vmenu';

VMenu.render = function () {
  return _({
    class: 'absol-vmenu',
    extendEvent: 'press'
  });
};

VMenu.property = {};
VMenu.property.activeTab = {
  set: function (tabIndex) {
    this._activeTab = tabIndex;

    if (this.$items) {
      for (var i = 0; i < this.$items.length; ++i) {
        var item = this.$items[i];
        item.show = i == tabIndex && !item.disable;
        item.activeTab = -1;

        if (i == tabIndex && !item.disable) {
          item.$button && item.items && item.items.length > 0 && item.$button.addClass('absol-vmenu-button-hover');
        } else {
          item.$button && item.$button.removeClass('absol-vmenu-button-hover');
        }
      }
    }
  },
  get: function () {
    return this._activeTab;
  }
};
VMenu.property.extendStyle = {
  set: function (value) {
    this.removeStyle(this._extendStyle || {});
    this._extendStyle = value || {};
    this.addStyle(this.extendStyle);
  },
  get: function () {
    return this._extendStyle || {};
  }
};
VMenu.property.extendClasses = {
  set: function (value) {
    var self = this;
    this.extendClasses.forEach(function (className) {
      self.removeClass(className);
    });
    this._extendClass = [];
    if (!value) return;

    if (typeof value == 'string') {
      value = value.split(/\s+/).filter(function (c) {
        return c.length > 0;
      });
    }

    if (value instanceof Array) {
      this._extendClass = value;

      this._extendClass.forEach(function (className) {
        self.addClass(className);
      });
    } else {
      throw new Error('Invalid extendClasses');
    }
  },
  get: function () {
    return this._extendClass || [];
  }
};
VMenu.eventHandler = {};

VMenu.eventHandler.enterItem = function (event) {
  var tabIndex = event.menuItem._tabIndex;
  this.activeTab = tabIndex;
};

VMenu.eventHandler.pressItem = function (event) {
  this.emit('press', _EventEmitter.default.copyEvent(event, {
    target: this
  }), this);
};

VMenu.property.items = {
  set: function (items) {
    this._childFromItems(items || []);
  },
  get: function () {
    return this.$items;
  }
};

VMenu.prototype.init = function (props) {
  Object.assign(this, props || {});
};

VMenu.prototype._childFromItems = function (items) {
  this.clearChild();
  this.$items = items.map(function (item, index) {
    var itemElt;

    if (typeof item === 'string' && (item.substr(0, 1) === '-' || item.substr(0, 1) === '=')) {
      itemElt = _('vmenuline');
    } else if ((0, _Dom.isDomNode)(item)) {
      itemElt = item;
    } else if (item.child || item.class || item.tag || item.style || typeof item === 'string') {
      itemElt = _(item);
    } else {
      itemElt = _({
        tag: 'vmenuitem',
        props: Object.assign({
          _tabIndex: index
        }, item),
        on: {
          enter: {
            callback: this.eventHandler.enterItem,
            cap: true
          },
          press: {
            callback: this.eventHandler.pressItem,
            cap: true
          }
        }
      });
    }

    this.addChild(itemElt);
    return itemElt;
  }.bind(this)); //todo
};

function HMenuItem() {
  this.$vmenu = $('vmenu', this);
  this.$dropDown = this;
  this.$button = $('button.absol-hmenu-button', this);

  _OOP.default.drillProperty(this, this.$button, 'text', 'innerHTML');

  _OOP.default.drillProperty(this, this.$vmenu, 'items');

  _OOP.default.drillProperty(this, this.$vmenu, 'activeTab');

  this.$button.on('click', this.eventHandler.clickButton);
  this.$button.on('mouseenter', this.eventHandler.enterButton, true);
  this.$vmenu.on('press', this.eventHandler.pressItem, true); //property show not need because dropdown is itself

  return this;
}

HMenuItem.tag = 'HMenuItem'.toLowerCase();

HMenuItem.render = function () {
  return _({
    tag: 'dropdown',
    extendEvent: ['press', 'enter'],
    child: ['button.absol-hmenu-button', 'vmenu']
  });
};

HMenuItem.eventHandler = {};

HMenuItem.eventHandler.clickButton = function (event) {
  event.menuItem = this;
  event.hmenuItem = this;
  this.emit('press', _EventEmitter.default.copyEvent(event, {
    target: this
  }), this);
};

HMenuItem.eventHandler.enterButton = function (event) {
  event.menuItem = this;
  this.emit('enter', _EventEmitter.default.copyEvent(event, {
    target: this
  }), this);
};

HMenuItem.eventHandler.pressItem = function (event) {
  this.emit('press', _EventEmitter.default.copyEvent(event, {
    target: this
  }), this);
};

HMenuItem.prototype = {};
HMenuItem.prototype.disable = VMenuItem.prototype.disable;

HMenuItem.prototype.init = function (props) {
  props = props || {};
  Object.assign(this, props);
};
/***
 * @extends AElement
 * @constructor
 */


function HMenu() {}

HMenu.tag = 'hmenu';

HMenu.render = function () {
  return _({
    class: 'absol-hmenu',
    extendEvent: ['press', 'enter', 'activetab', 'cancel']
  });
};

HMenu.eventHandler = {};

HMenu.eventHandler.pressItem = function (event) {
  /**
   * this.activeTab can be undefined
   * undefine >= 0 => false
   * undefine < 0 => false
   */
  if (event.menuItem.items && event.menuItem.items.length > 0 && !(this.activeTab >= 0)) {
    this.activeTab = event.menuItem._tabIndex;
  } else {
    event.isLeaf = !event.menuItem.items || !event.menuItem.items.length;
    this.emit('press', event, this);
  }
};

HMenu.eventHandler.enterItem = function (event) {
  if (this.activeTab >= 0) {
    this.activeTab = event.menuItem._tabIndex;
  }
};

HMenu.eventHandler.clickSomewhere = function (event) {
  if (_EventEmitter.default.hitElement(this, event)) return;
  this.activeTab = -1;
  window.removeEventListener('blur', this.eventHandler.clickSomewhere);
};

HMenu.prototype._childFromItems = function (items) {
  this.clearChild();
  this.$items = items.map(function (item, index) {
    var res = _({
      tag: 'hmenuitem',
      props: Object.assign({
        _tabIndex: index
      }, item),
      on: {
        press: {
          callback: this.eventHandler.pressItem,
          cap: true
        },
        enter: {
          callback: this.eventHandler.enterItem,
          cap: true
        }
      }
    });

    this.addChild(res);
    return res;
  }.bind(this));
};

HMenu.prototype.init = function (props) {
  Object.assign(this, props || {});
};

HMenu.property = {};
HMenu.property.items = {
  set: function (items) {
    this._childFromItems(items || []);
  },
  get: function () {
    return this.$items;
  }
};
HMenu.property.activeTab = {
  set: function (tabIndex) {
    var lastValue = this._activeTab;
    this._activeTab = tabIndex;

    for (var i = 0; i < this.$items.length; ++i) {
      var item = this.$items[i];
      item.show = i == tabIndex && !item.disable;
      item.activeTab = -1;

      if (i == tabIndex && !item.disable) {
        item.$button && item.items && item.items.length > 0 && item.$button.addClass('absol-hmenu-button-hover');
      } else {
        item.$button && item.$button.removeClass('absol-hmenu-button-hover');
      }
    }

    if (!(lastValue >= 0) && this._activeTab >= 0) {
      setTimeout(function () {
        $(document.body).on('click', this.eventHandler.clickSomewhere, false);
        window.addEventListener('blur', this.eventHandler.clickSomewhere);
      }.bind(this), 100);
    } else if (lastValue >= 0 && !(this._activeTab >= 0)) {
      $(document.body).off('click', this.eventHandler.clickSomewhere, false);
    }

    if (lastValue >= 0) {
      if (tabIndex >= 0 && tabIndex != lastValue) {
        this.emit('activetab', {
          type: 'activetab',
          tabIndex: tabIndex,
          target: this
        }, this);
      } else if (!(tabIndex >= 0)) {
        this.emit('cancel', {
          type: 'cancel',
          lastActiveIndex: lastValue,
          target: this
        }, this);
      }
    } else {
      if (tabIndex >= 0) {
        this.emit('activetab', {
          type: 'activetab',
          tabIndex: tabIndex,
          target: this
        }, this);
      }
    }
  },
  get: function () {
    return this._activeTab;
  }
};
/***
 * @extends AElement
 * @constructor
 */

function VRootMenu() {
  this._items = [];
  this.items = [];
}

VRootMenu.tag = 'VRootMenu'.toLowerCase();

VRootMenu.render = function () {
  return _({
    class: ['as-v-root-menu', 'as-bscroller'],
    extendEvent: ['press', 'enter', 'activetab', 'cancel']
  });
};

VRootMenu.prototype._childFromItems = function (items) {
  var thisM = this;
  this.clearChild();
  this.$items = items.map(function (item, i) {
    var itemElt;

    if (typeof item === 'string' && (item.substr(0, 1) === '-' || item.substr(0, 1) === '=')) {
      itemElt = _('vmenuline');
    } else if ((0, _Dom.isDomNode)(item)) {
      itemElt = item;
    } else if (item.child || item.class || item.tag || item.style || typeof item === 'string') {
      itemElt = _(item);
    } else {
      itemElt = _({
        tag: 'vmenuitem',
        props: item,
        on: {
          enter: thisM.eventHandler.enterItem,
          press: thisM.eventHandler.pressItem
        }
      });
    }

    itemElt._tabIndex = i;
    thisM.addChild(itemElt);
    return itemElt;
  });
};

VRootMenu.property = Object.assign({}, HMenu.property);
VRootMenu.eventHandler = Object.assign({}, HMenu.eventHandler);

_ACore.default.install([HMenu, VMenuItem, VMenu, Dropright, VMenuLine, Dropdown, HMenuItem, VRootMenu]);
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/ContextMenu.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/ContextMenu.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContextCaptor = ContextCaptor;
exports.default = void 0;

require("../css/contextmenu.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _Vec = _interopRequireDefault(require("absol/src/Math/Vec2"));

require("./Menu");

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _BoardTable = _interopRequireDefault(require("./BoardTable"));

var _utils = require("./utils");

var _BrowserDetector = _interopRequireDefault(require("absol/src/Detector/BrowserDetector"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
var supportContextEvent = false;
var isMobile = _BrowserDetector.default.isMobile;
/**
 * @extends AElement
 * @constructor
 */

function ContextCaptor() {
  this.attachedElt = null;
  this.$textarea = $('textarea', this).on('contextmenu', this.eventHandler.contextmenu, true);
  this._ss = 0;
  this._isTouch = false;
  /**
   this._target = null;
   * @type {Vec2}
   */

  this._posStart = null;
  /**
   * @type {Vec2}
   */

  this._posCurrent = null;
  this._touchId = -100;
  this._longPressTimeout = -1;
  this._removeTimeout = -1;
  this._fireContextMenuTimeout = -1;
  this.$target = null;
  this._pointerSession = 0;
  this._lastContextSession = 0;
  this.mousedownEvent = null;
  this.sync = Promise.resolve();
}

;

ContextCaptor.prototype.attachTo = function (elt) {
  if (this.attachedElt) {
    this.attachedElt.removeEventListener('mousedown', this.eventHandler.mousedown);
    this.attachedElt.removeEventListener('touchstart', this.eventHandler.mousedown);
    this.attachedElt = null;
  }

  this.attachedElt = elt;

  if (this.attachedElt) {
    this.attachedElt.addEventListener('mousedown', this.eventHandler.mousedown);
    this.attachedElt.addEventListener('touchstart', this.eventHandler.mousedown);
  }

  return this;
};

ContextCaptor.tag = 'ContextCaptor'.toLowerCase();

ContextCaptor.render = function () {
  return _({
    class: ['absol-context-menu-anchor'],
    extendEvent: 'requestcontextmenu',
    child: ['textarea']
  });
};

ContextCaptor.prototype.showContextMenu = function (x, y, props, onSelectItems) {
  var self = this;

  var anchor = _('.as-context-menu-ctn.absol-context-menu-anchor' + (isMobile ? '.as-anchor-modal' : '')).addTo(document.body);

  var finish = function (event) {
    document.body.off('click', finish).off('touchcancel', finish).off('touchend', finish).off('contextmenu', finish);
    self.off('requestcontextmenu', finish);
    setTimeout(function () {
      anchor.selfRemove(); //
    }, 10);
  };

  var vmenu = _({
    tag: 'vmenu',
    props: props,
    on: {
      press: onSelectItems || function () {}
    }
  }).addTo(anchor);

  setTimeout(function () {
    if (!isMobile) {
      var screenSize = _Dom.default.getScreenSize();

      var menuBound = vmenu.getBoundingClientRect();

      if (x + menuBound.width > screenSize.width - 17) {
        x -= menuBound.width;
      }

      if (y + menuBound.height > screenSize.height - 17) {
        y -= menuBound.height;
      }

      anchor.addStyle({
        left: x + 'px',
        top: y + 'px'
      });
    }

    anchor.addClass('absol-active');
  }, 30);
  setTimeout(function () {
    $(document.body).on('click', finish).on('contextmenu', finish);
    self.on('requestcontextmenu', finish);
  }, 10);
};

ContextCaptor.prototype._checkNeedHandle = function (target) {
  var current = target;
  var needHandle = false;

  while (current && !needHandle && !current.classList.contains('as-system-context-menu')) {
    if (current.isSupportedEvent && current.isSupportedEvent('contextmenu')) needHandle = true;
    current = current.parentElement;
  }

  return needHandle;
};

ContextCaptor.prototype._fireContextMenuEvent = function () {
  if (this._lastContextSession >= this._pointerSession) return false; // prevent fire multi-times in a pointer session

  var showed = false;
  this._lastContextSession = this._pointerSession;
  var baseEventData = {
    clientX: this._posCurrent.x,
    clientY: this._posCurrent.y,
    target: this.$target
  };
  this.emit('requestcontextmenu', baseEventData, this);
  var self = this;
  var propagation = true;
  var localEvent = Object.assign({
    clientX: this._posCurrent.x,
    clientY: this._posCurrent.y,
    target: this.$target,
    showContextMenu: function (props, onSelectItems) {
      showed = true;
      self.sync = self.sync.then(function () {
        return new Promise(function (rs) {
          setTimeout(function () {
            self.showContextMenu(self._posCurrent.x, self._posCurrent.y, props, onSelectItems);
            rs();
          }, 30);
        });
      });
    },
    stopPropagation: function () {
      propagation = false;
    }
  }, baseEventData);
  Object.defineProperty(localEvent, 'selectedText', {
    get: function () {
      return (0, _utils.getSelectionText)();
    }
  });
  var current = this.$target;

  while (current && propagation) {
    if (current.isSupportedEvent && current.isSupportedEvent('contextmenu')) {
      current.emit('contextmenu', localEvent, current, this);
    }

    current = current.parentElement;
  }

  return showed;
};
/**
 * @type {ContextCaptor}
 */


ContextCaptor.eventHandler = {};

ContextCaptor.eventHandler.mousedown = function (event) {
  if (this._touchId != -100) return;
  this._pointerSession++;
  var target;
  var isTouch;
  var touchId;
  var posCurrent;
  var pointer;

  if (event.type == 'touchstart') {
    isTouch = true;
    pointer = event.changedTouches[0];
    touchId = pointer.identifier;
  } else {
    isTouch = false;
    touchId = -1;
    pointer = event;
  }

  target = pointer.target;
  posCurrent = new _Vec.default(pointer.clientX, pointer.clientY);

  if (isTouch) {
    var dragzone = _BoardTable.default.prototype._findDragZone(target);

    if (dragzone) return;
    var thisCT = this;
    this._longPressTimeout = setTimeout(function () {
      if (!thisCT._checkNeedHandle(target)) return;

      if (thisCT._removeTimeout > 0) {
        clearTimeout(thisCT._removeTimeout);
        thisCT._removeTimeout = -1;
      }

      thisCT._ss++;
      thisCT.moveTo(thisCT._posCurrent);
      thisCT.active(true);
      thisCT._longPressTimeout = -1;

      if (thisCT._fireContextMenuTimeout >= 0) {
        clearTimeout(thisCT._fireContextMenuTimeout);
      } // show if device not support contextmenu event (after 700ms)


      thisCT._fireContextMenuTimeout = setTimeout(function () {
        if (!supportContextEvent) {
          thisCT._fireContextMenuEvent();
        }
      }, 300);
    }, 400);
    this.$target = target;
    this._isTouch = isTouch;
    this._touchId = touchId;
    this._posCurrent = posCurrent;
    this._posStart = posCurrent;
    $(document.body).on('touchmove', thisCT.eventHandler.mousemove).on('touchend', thisCT.eventHandler.mousefinish).on('touchcancel', thisCT.eventHandler.mousefinish);
  } else {
    if (_EventEmitter.default.isMouseRight(event) && this._checkNeedHandle(target)) {
      if (this._removeTimeout > 0) {
        clearTimeout(this._removeTimeout);
        this._removeTimeout = -1;
      }

      this.$target = target;
      this._isTouch = isTouch;
      this._posCurrent = posCurrent;
      this._posStart = posCurrent;
      this._touchId = touchId;
      this._ss++;
      this.moveTo(this._posCurrent);
      this.active(true);
      $(document.body).on('mousemove', this.eventHandler.mousemove).on('mouseup', this.eventHandler.mousefinish).on('mouseleave', this.eventHandler.mousefinish);
    }
  }
};
/**
 * @param {Vec2} pos
 */


ContextCaptor.prototype.moveTo = function (pos) {
  this.addStyle({
    left: pos.x - 80 + 'px',
    top: pos.y - 80 + 'px'
  });
};

ContextCaptor.prototype.active = function (flag) {
  if (flag) this.addClass('absol-active');else this.removeClass('absol-active');
};

ContextCaptor.eventHandler.mousemove = function (event) {
  var isTouch = this._isTouch;
  var touchId;
  var pointer;
  var posCurrent;

  if (isTouch) {
    pointer = event.changedTouches[0];
    touchId = pointer.identifier;
  } else {
    isTouch = false;
    touchId = -1;
    pointer = event;
  }

  if (touchId != this._touchId) return;
  posCurrent = new _Vec.default(pointer.clientX, pointer.clientY);
  this._posCurrent = posCurrent;

  if (isTouch) {
    if (this._posStart.sub(posCurrent).abs() > 10) this.eventHandler.mousefinish(event);
  }

  this.moveTo(posCurrent);
};

ContextCaptor.eventHandler.mousefinish = function (event) {
  var isTouch = this._isTouch;
  var touchId;
  var pointer;

  if (isTouch) {
    pointer = event.changedTouches[0];
    touchId = pointer.identifier;
  } else {
    isTouch = false;
    touchId = -1;
    pointer = event;
  }

  if (touchId != this._touchId) return;

  if (isTouch) {
    $(document.body).off('touchmove', this.eventHandler.mousemove).off('touchend', this.eventHandler.mousefinish).off('touchcancel', this.eventHandler.mousefinish);

    if (this._longPressTimeout > 0) {
      clearTimeout(this._longPressTimeout);
      this._longPressTimeout = -1;
    }
  } else {
    $(document.body).off('mousemove', this.eventHandler.mousemove).off('mouseup', this.eventHandler.mousefinish).off('mouseleave', this.eventHandler.mousefinish);
  }

  this._touchId = -100;

  if (this._fireContextMenuTimeout >= 0) {
    clearTimeout(this._fireContextMenuTimeout);
  }

  var thisCT = this;
  this._removeTimeout = setTimeout(function () {
    thisCT.active(false);
    thisCT._removeTimeout = -1;
  }, 1);
};

ContextCaptor.eventHandler.contextmenu = function (event) {
  supportContextEvent = true;
  event.preventDefault();

  this._fireContextMenuEvent();
};

ContextCaptor.auto = function () {
  if (ContextCaptor.$elt) return;
  ContextCaptor.$elt = _('contextcaptor');

  _Dom.default.documentReady.then(function () {
    ContextCaptor.$elt.addTo(document.body);
    ContextCaptor.$elt.attachTo(document.body);
  });
};

_ACore.default.install(ContextCaptor);

var _default = ContextCaptor;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/CountdownClock.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/CountdownClock.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

var _Element = _interopRequireDefault(require("absol/src/HTML5/Element"));

require("../css/countdownclock.css");

var _ResizeSystem = _interopRequireDefault(require("absol/src/HTML5/ResizeSystem"));

var _int = require("absol/src/Math/int");


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function CountdownClock() {
  var thisC = this;
  this.$attachhook = _('attachhook').addTo(this).on('attached', function () {
    _ResizeSystem.default.add(this);

    this.requestUpdateSize();

    if (thisC.autoStart) {
      thisC.start();
    }
  });
  this.$attachhook.requestUpdateSize = this._updateBorder.bind(this);
  this._tick = this._tick.bind(this);
  this.$border = $(".as-countdown-clock-border", this);
  this.$min = $(".as-countdown-clock-min", this);
  this.$sec = $(".as-countdown-clock-sec", this);
  this._prevText = -1;
  this._startTime = new Date().getTime();
  this._totalSecond = 60;
  this._remainSecond = 0;
  this.totalSecond = 60;
  this.remainSecond = 0;
  this._intvId = -1;
}

CountdownClock.tag = 'CountdownClock'.toLowerCase();

CountdownClock.render = function () {
  return _({
    extendEvent: ['finish', 'update'],
    class: 'as-countdown-clock',
    child: [{
      class: 'as-countdown-clock-text',
      child: [{
        tag: 'span',
        class: 'as-countdown-clock-min',
        child: {
          text: 0
        }
      }, {
        text: ':'
      }, {
        tag: 'span',
        class: 'as-countdown-clock-sec',
        child: {
          text: '60'
        }
      }]
    }, {
      class: 'as-countdown-clock-border-wrapper',
      child: {
        class: 'as-countdown-clock-border'
      }
    }]
  });
};

CountdownClock.prototype._makePolygon = function (end) {
  var n = Math.ceil(Math.max(end / 0.2, 2));
  var fan = Array(n).fill(0).map(function (u, i) {
    var angle = -Math.PI / 2 + end * i / n;
    return [(0, _int.numberAutoFixed)(50 + 60 * Math.cos(angle), 5) + '%', (0, _int.numberAutoFixed)(50 + 60 * Math.sin(angle), 5) + '%'].join(' ');
  });
  fan.push('50% 50%');
  return 'polygon(' + fan.join(', ') + ')';
};

CountdownClock.prototype._setBorderValue = function (val) {
  if (val >= 1 || !isFinite(val)) {
    this.$border.removeStyle("clip-path");
    return;
  }

  var bound = this.$border.getBoundingClientRect();
  var angle = val * Math.PI * 2;
  this.$border.addStyle("-webkit-clip-path", this._makePolygon(angle));
  this.$border.addStyle("clip-path", this._makePolygon(angle));
};

CountdownClock.prototype._updateBorder = function () {
  this._setBorderValue(this._remainSecond / Math.max(0.001, this._totalSecond));
};

CountdownClock.prototype._updateText = function () {
  if (this._prevText === this.remainSecond) return;
  var remainSecond = this.remainSecond;
  var min = Math.floor(remainSecond / 60);
  var sec = remainSecond % 60;
  this.$sec.innerHTML = (sec < 10 ? "0" : "") + sec;
  this.$min.innerHTML = min;
};

CountdownClock.prototype._tick = function () {
  var now = new Date().getTime();
  var prevSec = this.remainSecond;
  this.remainSecond = Math.max(0, Math.ceil(this.totalSecond - (now - this._startTime) / 1000));

  if (prevSec !== this.remainSecond) {
    this._updateText();

    this.emit('update', {
      target: this,
      type: 'update'
    }, this);

    if (this.remainSecond === 0) {
      clearInterval(this._intvId);
      this._intvId = -1;
      this.emit('finish', {
        target: this,
        type: 'finish'
      }, this);
    }
  }
};

CountdownClock.prototype.start = function () {
  if (this.remainSecond == 0) this.remainSecond = this.totalSecond;
  this._startTime = new Date().getTime() - (this.totalSecond - this.remainSecond) * 1000;
  this.resume();
};

CountdownClock.prototype.resume = function () {
  if (this._intvId > 0) return;
  this._intvId = setInterval(this._tick, 200);
};

CountdownClock.prototype.pause = function () {
  if (this._intvId > 0) {
    clearInterval(this._intvId);
    this._intvId = -1;
  }
};

CountdownClock.prototype.stop = function () {
  this.pause();
  this.remainSecond = 0;
};

CountdownClock.prototype.reset = function () {
  this.remainSecond = this.totalSecond;
  this._startTime = new Date().getTime();
};

CountdownClock.property = {};
CountdownClock.property.totalSecond = {
  set: function (value) {
    if (!(value >= 0)) {
      value = 0;
    }

    this._totalSecond = value;

    this._updateBorder();
  },
  get: function () {
    return this._totalSecond;
  }
};
CountdownClock.property.remainSecond = {
  set: function (value) {
    if (!(value >= 0)) {
      value = 0;
    }

    this._remainSecond = value;

    this._updateBorder();

    this._updateText();
  },
  get: function () {
    return this._remainSecond;
  }
};

_ACore.default.install(CountdownClock);

var _default = CountdownClock;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/ExpTree.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/ExpTree.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExpNode = ExpNode;
exports.ExpTree = ExpTree;
exports.ExpGroup = ExpGroup;
exports.default = void 0;

require("../css/exptree.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _utils = require("./utils");

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _EventEmitter = _interopRequireWildcard(require("absol/src/HTML5/EventEmitter"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));




var _ = _ACore.default._;
var $ = _ACore.default.$;

_ACore.default.install('toggler-ico', function () {
  var res = _('<svg class="toggler-ico" width="14" height="14" version="1.1" viewBox="0 0 3.7042 3.7042" xmlns="http://www.w3.org/2000/svg" >' + '    <rect style="fill: transparent; stroke: none" x="0" y="0" width="3.7042" height="3.7042"></rect>' + '    <g transform="translate(0 -293.3)" class="toggle-close">' + '        <path d="m0.52917 293.82v2.6458l2.6458-1.3229z" />' + '    </g>' + '    <g transform="translate(0 -293.3)" class="toggle-open">' + '        <path d="m3.175 294.09-2.6458 2.1167h2.6458z"/>' + '    </g>' + '</svg>');

  return res;
});

_ACore.default.install('remove-ico', function () {
  return _('<svg class="remove-ico" width="24" height="24" viewBox="0 0 24 24">\
                <rect style="fill: transparent; stroke: none" x="0" y="0" width="24" height="24"></rect>\
                <path class="close" d="M3,16.74L7.76,12L3,7.26L7.26,3L12,7.76L16.74,3L21,7.26L16.24,12L21,16.74L16.74,21L12,16.24L7.26,21L3,16.74" />\
                <circle class="modified" cx="12" cy="12" r="10" />\
            </svg>');
});
/***
 * @extends AElement
 * @constructor
 */


function ExpNode() {
  var thisEN = this;
  this.$level = $('.absol-exp-node-level', this);
  this.$removeIcon = $('remove-ico', this).on('click', function (event) {
    thisEN.emit('pressremove', {
      target: thisEN,
      type: 'pressremove'
    }, this);
  });
  this.on('keydown', this.eventHandler.buttonKeydown);
  this.$toggleIcon = $('toggler-ico', this).on('click', function (event) {
    thisEN.emit('presstoggle', (0, _EventEmitter.copyEvent)(event, {
      target: thisEN,
      type: 'pressremove'
    }), this);
  });
  this.on('click', function (event) {
    if (!_EventEmitter.default.hitElement(thisEN.$removeIcon, event) && !_EventEmitter.default.hitElement(thisEN.$toggleIcon, event)) thisEN.emit('press', (0, _EventEmitter.copyEvent)(event, {
      target: thisEN,
      type: 'press'
    }), this);
  });
  this.$iconCtn = $('div.absol-exp-node-ext-icon', this);
  this.$extIcon = $('img.absol-exp-node-ext-icon', this);
  this.$name = $('span.absol-exp-node-name', this);
  this.$desc = $('span.absol-exp-node-desc', this);
  (0, _utils.contenteditableTextOnly)(this.$name, function (text) {
    return text.replace(/[\\\/\|\?\:\<\>\*\r\n]/, '').trim();
  });

  _OOP.default.drillProperty(thisEN, thisEN.$extIcon, 'extSrc', 'src');

  this._level = 0;
  this.__isExpNode__ = true;
  return thisEN;
}

ExpNode.tag = 'expnode';

ExpNode.render = function () {
  return _({
    tag: 'button',
    extendEvent: ['pressremove', 'press', 'presstoggle'],
    class: 'absol-exp-node',
    child: ['.absol-exp-node-level', 'remove-ico', 'toggler-ico', 'img.absol-exp-node-ext-icon', 'div.absol-exp-node-ext-icon', 'span.absol-exp-node-name', 'span.absol-exp-node-desc']
  });
};

ExpNode.property = {};
ExpNode.property.icon = {
  set: function (value) {
    if (this.$iconP) {
      this.$iconP.remove();
      this.$iconP = undefined;
    }

    if (value && value != null) {
      var newE;

      if (!_Dom.default.isDomNode(value)) {
        newE = _(value);
      }

      this.$iconP = newE;
      this.$iconCtn.addChild(newE);
      this._icon = value;
    } else {
      this._icon = undefined;
    }
  },
  get: function () {
    return this._icon;
  }
};
ExpNode.property.level = {
  set: function (value) {
    value = value || 0;

    if (value != this.level) {
      this._level = value || 0;
      this.$level.innerHTML = '&nbsp;'.repeat(this._level * 6);
    }
  },
  get: function () {
    return this._level || 0;
  }
};
ExpNode.property.name = {
  set: function (value) {
    this._name = value + '';
    this.$name.clearChild();
    if (this.name && this.name.length > 0) this.$name.addChild(_({
      text: this._name
    }));
  },
  get: function () {
    return this._name || '';
  }
};
ExpNode.property.desc = {
  set: function (value) {
    this._desc = value + '';
    this.$desc.clearChild();
    this.$desc.addChild(_({
      text: this._desc
    }));
  },
  get: function () {
    return this._desc || '';
  }
};
ExpNode.property.status = {
  set: function (value) {
    this.removeClass('status-open').removeClass('status-close').removeClass('status-modified').removeClass('status-removable');

    if (!value || value == 'none') {//todo
    } else if (value == 'close') {
      this.addClass('status-close');
    } else if (value == 'open') {
      this.addClass('status-open');
    } else if (value == 'removable') {
      this.addClass('status-removable');
    } else if (value == 'modified') {
      this.addClass('status-modified');
    } else {
      throw new Error('Invalid status ' + value);
    }

    this._status = value;
  },
  get: function () {
    return this._status;
  }
};
ExpNode.property.active = {
  set: function (value) {
    if (value) {
      this.addClass('as-active');
      this.addClass('active');
    } else {
      this.removeClass('as-active');
      this.removeClass('active');
    }
  },
  get: function () {
    return this.containsClass('as-active');
  }
};

ExpNode.prototype.rename = function (resolveCallback, rejectCallback) {
  var self = this;
  var span = this.$name;
  var lastName = span.innerHTML;
  span.attr('contenteditable', 'true');
  span.focus();
  document.execCommand('selectAll', false, null);

  function keydowEventHandle(event) {
    var key = event.key;

    if (key == 'Enter') {
      event.preventDefault();
      span.blur();
      span.attr('contenteditable', undefined);
    } else if (key == "ESC") {
      event.preventDefault();
      span.innerHTML = lastName;
      span.blur();
      span.attr('contenteditable', undefined);
    }
  }

  function blurEventHandle(event) {
    finish();
    var curentName = span.innerHTML.replace(/[\\\/\|\?\:\<\>\*\r\n]/, '').trim();

    if (curentName == lastName) {
      rejectCallback && rejectCallback();
    } else {
      if (curentName.length == 0) {
        span.innerHTML = lastName;
        rejectCallback && rejectCallback();
      } else {
        var res = resolveCallback && resolveCallback(curentName);

        if (res === false) {
          span.innerHTML = lastName;
        } else if (res && res.then) {
          res.then(function (result) {
            if (result === false) {
              span.innerHTML = lastName; //faile
            } else {//success
              }
          }, function () {
            //reject value
            span.innerHTML = lastName;
          });
        } else {//success
        }
      }
    }
  }

  function finish() {
    span.off('keydown', keydowEventHandle);
    span.off('blur', blurEventHandle);
    $(document.body).once('click', function () {
      setTimeout(function () {
        span.attr('contenteditable', undefined);
      }, 2);
    });
  }

  span.on('keydown', keydowEventHandle);
  span.on('blur', blurEventHandle);
};

ExpNode.prototype.findNodeBefore = function () {
  var tree = this.parentElement;
  var root;
  var prevTree;
  var res = null;

  if (tree.__isExpTree__) {
    root = tree.getRoot();
    root.visitRecursive(function (cTree) {
      if (cTree === tree) {
        res = prevTree;
      }

      prevTree = cTree;
    });
  }

  return res && res.getNode();
};

ExpNode.prototype.findNodeAfter = function () {
  var tree = this.parentElement;
  var root;
  var prevTree;
  var res = null;

  if (tree.__isExpTree__) {
    root = tree.getRoot();
    root.visitRecursive(function (cTree) {
      if (prevTree === tree) {
        res = cTree;
      }

      prevTree = cTree;
    });
  }

  return res && res.getNode();
};

ExpNode.eventHandler = {};
/****
 *
 * @param {KeyboardEvent} event
 */

ExpNode.eventHandler.buttonKeydown = function (event) {
  if (event.target === this) {
    if (!event.metaKey && !event.shiftKey && !event.ctrlKey && !event.altKey) {
      var destNode;
      var tree = this.parentElement;
      var parentTree = tree && tree.getParent();

      switch (event.key) {
        case 'ArrowLeft':
          if (tree.status === 'open') {
            tree.status = 'close';
            tree.notifyStatusChange();
          } else {
            destNode = parentTree && parentTree.getNode();
          }

          break;

        case 'ArrowRight':
          if (tree.status === 'close') {
            tree.status = 'open';
            tree.notifyStatusChange();
          } else {
            destNode = this.findNodeAfter();
          }

          break;

        case 'ArrowUp':
          destNode = this.findNodeBefore();
          break;

        case 'ArrowDown':
          destNode = this.findNodeAfter();
          break;

        case 'Space':
          this.click();
          break;
      }

      if (destNode) {
        destNode.focus();
        event.preventDefault();
      }
    }
  }
};
/***
 * @extends AElement
 * @constructor
 */


function ExpTree() {
  var thisET = this;
  this.$node = $('expnode', this).on('press', function (event) {
    thisET.emit('press', Object.assign({}, {
      target: thisET,
      node: this,
      type: 'press'
    }, event), this);
  }).on('pressremove', function (event) {
    thisET.emit('pressremove', Object.assign({}, {
      target: thisET,
      node: this,
      type: 'pressremove'
    }, event), this);
  }).on('presstoggle', this.eventHandler.nodePressToggle);
  this.$itemsContainer = $('.absol-exp-items', thisET);

  _OOP.default.drillProperty(this, this.$node, ['desc', 'name', 'title', 'extSrc', 'active', 'icon']);

  this.__isExpTree__ = true;
  this._level = 0;
}

ExpTree.tag = 'ExpTree'.toLowerCase();

ExpTree.render = function () {
  return _({
    class: 'absol-exp-tree',
    extendEvent: ['press', 'pressremove', 'statuschange'],
    child: ['expnode', '.absol-exp-items']
  });
};

ExpTree.property = {};
ExpTree.property.level = {
  set: function (value) {
    value = value || 0;

    if (value != this.level) {
      this.$node.level = value;
      Array.prototype.forEach.call(this.$itemsContainer.childNodes, function (e) {
        e.level = value + 1;
      });
    }
  },
  get: function () {
    return this.$node.level;
  }
};
ExpTree.property.status = {
  set: function (value) {
    this.$node.status = value;

    if (value != 'open') {
      this.addClass('hide-children');
    } else {
      this.removeClass('hide-children');
    }
  },
  get: function () {
    return this.$node.status;
  }
};
['findChildBefore', 'findChildAfter', 'removeChild', 'clearChild'].forEach(function (key) {
  ExpTree.prototype[key] = function () {
    this.$itemsContainer[key].apply(this.$itemsContainer, arguments);
  };
});

ExpTree.prototype.addChild = function (child) {
  if (!child.__isExpTree__) throw new Error('Child node must be a ExpTree');
  child.level = this.level + 1;
  this.$itemsContainer.addChild(child);
};

ExpTree.prototype.addChildBefore = function (child, at) {
  child.level = this.level + 1;
  this.$itemsContainer.addChildBefore(child, at);
};

ExpTree.prototype.addChildAfter = function (child, at) {
  child.level = this.level + 1;
  this.$itemsContainer.addChildAfter(child, at);
};
/****
 *
 * @return {ExpTree}
 */


ExpTree.prototype.getParent = function () {
  var current = this.parentNode;

  while (current) {
    if (current.__isExpTree__) break;
    current = current.parentNode;
  }

  return current;
};
/***
 *
 * @return {ExpTree}
 */


ExpTree.prototype.getRoot = function () {
  var parent = this.getParent();
  if (!parent) return this;
  return parent.getRoot();
};

ExpTree.prototype.getNode = function () {
  return this.$node;
};

ExpTree.prototype.getChildren = function () {
  return Array.apply(null, this.$itemsContainer.childNodes);
};
/***
 *
 * @param {function(tree: ExpTree): void} cb
 */


ExpTree.prototype.visitRecursive = function (cb) {
  cb(this);
  if (this.status === 'open') Array.prototype.forEach.call(this.$itemsContainer.childNodes, function (child) {
    child.visitRecursive(cb);
  });
};

ExpTree.prototype.getPath = function () {
  var path = [];
  var current = this;

  while (current) {
    path.push(current.name);
    current = current.getParent();
  }

  return path.reverse();
};

ExpTree.prototype.accessByPath = function (path) {
  if (path.length == 0) return this;
  var childs = this.getChildren();
  var res;

  for (var i = 0; i < childs.length; ++i) {
    if (childs[i].name == path[0]) {
      res = childs[i].accessByPath(path.slice(1));
      break;
    }
  }

  return res;
};

ExpTree.prototype.toggle = function () {
  switch (this.status) {
    case 'close':
      this.status = 'open';
      break;

    case 'open':
      this.status = 'close';
      break;
  }
};

ExpTree.prototype.notifyStatusChange = function (props) {
  this.emit('statuschange', Object.assign({
    type: 'statuschange',
    target: this
  }, props), this);
};

ExpTree.eventHandler = {};

ExpTree.eventHandler.nodePressToggle = function (event) {
  this.toggle();
  this.notifyStatusChange({
    originEvent: event
  });
};
/***
 * @extends ExpTree
 * @constructor
 */


function ExpGroup() {
  this.addClass('as-exp-group');
  this.__isExpTree__ = true;
}

ExpGroup.tag = 'ExpGroup'.toLowerCase();

ExpGroup.render = function () {
  return _('div');
};
/***
 *
 * @param {function(tree: ExpTree): void} cb
 */


ExpGroup.prototype.visitRecursive = function (cb) {
  Array.prototype.forEach.call(this.childNodes, function (child) {
    child.visitRecursive(cb);
  });
};

ExpGroup.prototype.getParent = function () {
  return null;
};

ExpGroup.prototype.getRoot = function () {
  return this;
};

ExpGroup.prototype.getNode = function () {
  return null;
};

_ACore.default.install(ExpNode);

_ACore.default.install(ExpTree);

_ACore.default.install(ExpGroup);

var _default = ExpTree;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/DVExpTree.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/DVExpTree.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ExpTree = _interopRequireDefault(require("./ExpTree"));

var _ACore = _interopRequireWildcard(require("../ACore"));

require("../css/dvexptree.css");

var _EventEmitter = require("absol/src/HTML5/EventEmitter");




/***
 * @extends ExpTree
 * @constructor
 */
function DVExpTree() {
  this.injectInput();
}

DVExpTree.tag = 'DVExpTree'.toLowerCase();

DVExpTree.render = function () {
  return (0, _ACore._)({
    tag: _ExpTree.default.tag,
    extendEvent: ['radiochange', 'indexclick'],
    class: 'as-dv-exp-tree'
  }, true);
};

DVExpTree.prototype.injectInput = function () {
  this.$radio = (0, _ACore._)({
    tag: 'radiobutton',
    on: {
      change: this.eventHandler.radioChange
    }
  });
  this.$node.insertBefore(this.$radio, this.$node.$extIcon);
  this.$index = (0, _ACore._)({
    tag: 'span',
    class: 'as-dv-exp-tree-index',
    on: {
      click: this.eventHandler.indexClick
    }
  });
  this.$node.insertBefore(this.$index, this.$node.$desc);
  this.$node.on('click', this.eventHandler.clickInNode);
};

DVExpTree.property = {};
DVExpTree.property.radioName = {
  enumerable: true,
  set: function (value) {
    if (!value) {
      this.removeClass('as-has-radio');
      this.$radio.name = undefined;
    } else {
      this.addClass('as-has-radio');
      this.$radio.name = value + '';
    }
  },
  get: function () {
    return this.$radio.name;
  }
};
DVExpTree.property.radioValue = {
  enumerable: true,
  set: function (value) {
    this.$radio.value = value;
  },
  get: function () {
    return this.$radio.value;
  }
};
DVExpTree.property.radioChecked = {
  enumerable: true,
  set: function (value) {
    this.$radio.checked = value;
  },
  get: function () {
    return this.$radio.checked;
  }
};
DVExpTree.property.hasIndex = {
  enumerable: true,
  set: function (value) {
    if (value) this.addClass('as-has-index-input');else this.removeClass('as-has-index-input');
  },
  get: function () {
    return this.containsClass('as-has-index-input');
  }
};
DVExpTree.property.indexValue = {
  enumerable: true,
  set: function (value) {
    this.$index.innerHTML = value;
  },
  get: function () {
    return this.$index.innerHTML;
  }
};
DVExpTree.eventHandler = {};

DVExpTree.eventHandler.radioChange = function (event) {
  this.emit('radiochange', Object.assign({}, event, {
    target: this,
    radioElt: this.$radio
  }), this);
};

DVExpTree.eventHandler.indexClick = function (event) {
  this.emit('indexclick', Object.assign({}, event, {
    target: this,
    indexInput: this.$index
  }), this);
};

DVExpTree.eventHandler.clickInNode = function (event) {
  if ((0, _EventEmitter.hitElement)(this.$index, event) || (0, _EventEmitter.hitElement)(this.$radio, event) || (0, _EventEmitter.hitElement)(this.$node.$toggleIcon, event)) return;
  if ((0, _EventEmitter.hitElement)(this.$node, event) && this.radioName) this.$radio.click();
};

_ACore.default.install(DVExpTree);

var _default = DVExpTree;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/DateInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/DateInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/dateinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _datetime = require("absol/src/Time/datetime");

var _ChromeCalendar = _interopRequireDefault(require("./ChromeCalendar"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/**
 * @extends AElement
 * @constructor
 */

function DateInput() {
  this._lastValue = null;
  this._value = null;
  this._format = 'dd/mm/yyyy';
  this.$input = $('input', this).on('mouseup', this.eventHandler.mouseup).on('keydown', this.eventHandler.keydown).on('paste', this.eventHandler.paste).on('cut', this.eventHandler.cut).on('focus', this.eventHandler.focus);
  this._minLimitDate = new Date(1890, 0, 1, 0, 0, 0, 0);
  this._maxLimitDate = new Date(2090, 0, 1, 0, 0, 0, 0);
  this.$calendarBtn = $('.as-date-input-icon-ctn', this).on('mousedown', this.eventHandler.mousedownCalendarBtn);
  this._calendarHolder = _ChromeCalendar.default.showWhenClick(this.$calendarBtn, {
    minLimitDate: this._minLimitDate,
    maxLimitDate: this._maxLimitDate,
    selectedDates: [new Date()]
  }, 'auto', this.eventHandler.calendarSelect);
  this._calendarHolder.element = this;
  this._formater = DateInput.formaters[this._format];

  _OOP.default.drillProperty(this, this._calendarHolder.calendarProps, ['minLimitDate', 'maxLimitDate']);

  this.value = null;
}

DateInput.formaters = {
  'dd/mm/yyyy': {
    separator: '/',
    nan: ['dd', 'mm', 'yyyy'],
    dayIdx: 0,
    monthIdx: 1,
    yearIdx: 2
  },
  'dd-mm-yyyy': {
    separator: '-',
    nan: ['dd', 'mm', 'yyyy'],
    dayIdx: 0,
    monthIdx: 1,
    yearIdx: 2
  },
  'dd.mm.yyyy': {
    separator: '.',
    nan: ['dd', 'mm', 'yyyy'],
    dayIdx: 0,
    monthIdx: 1,
    yearIdx: 2
  },
  'yyyy/mm/dd': {
    separator: '/',
    nan: ['yyyy', 'mm', 'dd'],
    dayIdx: 2,
    monthIdx: 1,
    yearIdx: 0
  },
  'yyyy-mm-dd': {
    separator: '-',
    nan: ['yyyy', 'mm', 'dd'],
    dayIdx: 2,
    monthIdx: 1,
    yearIdx: 0
  },
  'mm/dd/yyyy': {
    separator: '/',
    nan: ['mm', 'dd', 'yyyy'],
    dayIdx: 1,
    monthIdx: 0,
    yearIdx: 2
  }
};
DateInput.tag = 'dateinput';

DateInput.render = function () {
  //only support dd/mm/yyyy
  return _({
    class: 'as-date-input',
    extendEvent: ['change'],
    child: [{
      tag: 'input',
      props: {
        value: '__/__/____'
      }
    }, {
      class: 'as-date-input-icon-ctn',
      child: 'span.mdi.mdi-calendar'
    }]
  });
};

DateInput.prototype._autoSelect = function () {
  var slEnd = this.$input.selectionEnd;
  var slStart = this.$input.selectionStart;
  var texts = this.$input.value.split(this._formater.separator);
  var lTexts = texts.reduce(function (ac, cr) {
    ac.push(ac[ac.length - 1] + cr.length + 1);
    return ac;
  }, [0]);

  function indexOf(offset) {
    var l;

    for (var i = 0; i < lTexts.length; ++i) {
      l = lTexts[i];
      if (l > offset) return i;
    }

    return texts.length;
  }

  var i0 = indexOf(slStart);
  var i1 = indexOf(slEnd);

  if (i0 == i1) {
    this.$input.selectionStart = lTexts[i0 - 1];
    this.$input.selectionEnd = lTexts[i0] - 1;
  } else {
    this.$input.selectionStart = 0;
    this.$input.selectionEnd = lTexts[lTexts.length - 1];
  }
};

DateInput.prototype.notifyChange = function () {
  this.emit('change', {
    type: 'change',
    target: this,
    value: this._value
  }, this);
};

DateInput.prototype._countSeparator = function (text) {
  return text.replace(new RegExp('[^\\' + this._formater.separator + ']', 'g'), '').length;
};

DateInput.prototype._cleanCharacter = function (text) {
  return text.replace(new RegExp('[^0-9\\' + this._formater.separator + ']', 'g'), '');
};

DateInput.prototype._splitBySeparator = function (text) {
  return text.split(this._formater.separator);
};

DateInput.prototype._onlySeparator = function (text) {
  return text.replace(new RegExp('[^\\' + this._formater.separator + ']', 'g'), '');
};

DateInput.prototype._isAcceptKey = function (key) {
  return !!key.match(new RegExp('[0-9\\' + this._formater.separator + ']', 'i'));
};
/**
 * @type {DateInput}
 */


DateInput.eventHandler = {};

DateInput.eventHandler.paste = function (event) {
  var paste = (event.clipboardData || window.clipboardData).getData('text');
  event.preventDefault();
  paste = this._cleanCharacter(paste);
  var slEnd = this.$input.selectionEnd;
  var slStart = this.$input.selectionStart;
  var sStart = Math.min(slStart, slEnd);
  var sEnd = Math.max(slEnd, slStart);
  var value = this.$input.value;

  var slashPasteCount = this._countSeparator(paste);

  var slashSelectedCount = this._countSeparator(value.substr(sStart, sEnd - sStart));

  if (slashPasteCount < 2) {
    if (slashPasteCount > slashSelectedCount) {
      paste = this._splitBySeparator(paste).slice(0, slashSelectedCount + 1).join(this._formater.separator);
    } else if (slashPasteCount < slashSelectedCount) {
      paste += this._formater.separator.repeat(slashSelectedCount - slashPasteCount);
    }

    slStart = (value.substr(0, sStart) + paste).length;
    slEnd = slStart;
    value = value.substr(0, sStart) + paste + value.substr(sEnd);
  } else {
    value = this._splitBySeparator(paste).slice(0, 3).join(this._formater.separator);
    slStart = value.length;
    slEnd = value.length;
  }

  this.$input.value = value;
  this.$input.selectionStart = slStart;
  this.$input.selectionEnd = slEnd;
};

DateInput.eventHandler.cut = function (event) {
  event.preventDefault();
  var slEnd = this.$input.selectionEnd;
  var slStart = this.$input.selectionStart;
  var sStart = Math.min(slStart, slEnd);
  var sEnd = Math.max(slEnd, slStart);
  var value = this.$input.value;
  this.$input.value = value.substr(0, sStart) + this._onlySeparator(value.substr(sStart, sEnd - sStart)) + value.substr(sEnd);
  this.$input.selectionStart = slStart;
  this.$input.selectionEnd = slStart;
};

DateInput.eventHandler.mouseup = function () {
  setTimeout(this._autoSelect.bind(this), 1);
};

DateInput.eventHandler.focus = function () {
  this.$input.on('blur', this.eventHandler.blur);
};

DateInput.eventHandler.blur = function () {
  var thisIp = this;
  this.$input.off('blur', this.eventHandler.blur);
  var value = this.$input.value;

  var slashValueCount = this._countSeparator(value).length;

  for (var i = slashValueCount; i < 2; ++i) value += this._formater.separator;

  var texts = value.split(this._formater.separator).slice(0, 3);
  var day = parseInt(texts[this._formater.dayIdx]);
  var month = parseInt(texts[this._formater.monthIdx]);
  var year = parseInt(texts[this._formater.yearIdx]);
  if (!isNaN(year)) year = Math.min(2090, Math.max(year, 1890));
  if (!isNaN(month)) month = Math.max(1, Math.min(12, month));

  if (!isNaN(day)) {
    day = Math.max(1, Math.min(31, day));

    if (!isNaN(month)) {
      day = Math.min((0, _datetime.daysInMonth)(2000, month), day);
      if (!isNaN(year)) day = Math.min((0, _datetime.daysInMonth)(year, month), day);
    }
  }

  if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
    var dateValue = new Date(year, month - 1, day, 0, 0, 0, 0);

    if (this._lastValue == null || (0, _datetime.compareDate)(dateValue, this._lastValue) != 0) {
      this.value = dateValue;
      this.notifyChange();
    }
  } else {
    var values = this._formater.nan.slice();

    values[this._formater.dayIdx] = day;
    values[this._formater.monthIdx] = month;
    values[this._formater.yearIdx] = year;
    this.$input.value = values.map(function (e, i) {
      if (isNaN(e)) return thisIp._formater.nan[i];
      e = e + '';

      while (e.length < thisIp._formater.nan[i].length) e = '0' + e;

      return e;
    }).join(this._formater.separator);

    if (this._lastValue != null) {
      this._value = null;
      this.notifyChange();
    }
  }
};

DateInput.eventHandler.calendarSelect = function (value) {
  this.value = value;
  this.notifyChange();
};

DateInput.eventHandler.keydown = function (event) {
  var slEnd = this.$input.selectionEnd;
  var slStart = this.$input.selectionStart;
  var value = this.$input.value;
  var sStart = Math.min(slStart, slEnd);
  var sEnd = Math.max(slEnd, slStart);
  var selectedValue = value.substr(sStart, sEnd - sStart);

  var slashValueCount = this._countSeparator(value);

  var slashSelectedCount = this._countSeparator(selectedValue);

  var texts = this._splitBySeparator(value);

  var lTexts = texts.reduce(function (ac, cr) {
    ac.push(ac[ac.length - 1] + cr.length + 1);
    return ac;
  }, [0]);

  function indexOf(offset) {
    var l;

    for (var i = 0; i < lTexts.length; ++i) {
      l = lTexts[i];
      if (l > offset) return i;
    }

    return texts.length;
  }

  var i0 = indexOf(slStart);
  var i1 = indexOf(slEnd);

  if (event.key == 'Enter') {
    event.preventDefault();
    this.$input.blur();
  } else if (event.key == 'Meta') {
    event.preventDefault();
  } else if (event.key == 'Backspace') {
    if (slStart == slEnd) {
      if (slStart > 0) {
        if (value.charAt(slStart - 1) == this._formater.separator) {
          event.preventDefault();
          this.$input.value = value;
          this.$input.selectionStart = slStart - 1;
          this.$input.selectionEnd = slStart - 1;
        }
      }
    } else if (i0 != i1) {
      event.preventDefault();
      this.$input.value = value.substr(0, sStart) + this._onlySeparator(selectedValue) + value.substr(sEnd);
      this.$input.selectionStart = slStart;
      this.$input.selectionEnd = slStart;
    }
  } else if (event.key == 'Delete') {
    if (slStart == slEnd) {
      if (slStart < value.length) {
        if (value.charAt(slStart) == this._formater.separator) {
          event.preventDefault();
          this.$input.value = value;
          this.$input.selectionStart = slStart + 1;
          this.$input.selectionEnd = slStart + 1;
        }
      }
    } else if (i0 != i1) {
      event.preventDefault();
      this.$input.value = value.substr(0, sStart) + this._onlySeparator(selectedValue) + value.substr(sEnd);
      this.$input.selectionStart = slStart;
      this.$input.selectionEnd = slStart;
    }
  } else if (!event.ctrlKey && !event.altKey && event.key && event.key.length == 1) {
    if (this._isAcceptKey(event.key)) {
      if (event.key == this._formater.separator) {
        if (slashSelectedCount == 0 && slashValueCount >= 2 && value.charAt(slEnd) != this._formater.separator) {
          event.preventDefault();
        } else if (value.charAt(slEnd) == this._formater.separator) {
          event.preventDefault();
          this.$input.selectionStart = lTexts[i1];
          this.$input.selectionEnd = lTexts[i1 + 1] - 1;
        }
      }
    } else {
      event.preventDefault();
    }
  } else if (!event.ctrlKey && !event.altKey && event.key == "Tab") {
    if (event.shiftKey) {
      if (i0 > 1) {
        event.preventDefault();
        this.$input.selectionStart = lTexts[i1 - 2];
        this.$input.selectionEnd = lTexts[i1 - 1] - 1;
      }
    } else {
      if (i1 < texts.length) {
        event.preventDefault();
        this.$input.selectionStart = lTexts[i1];
        this.$input.selectionEnd = lTexts[i1 + 1] - 1;
      }
    }
  }
};

DateInput.property = {};
DateInput.property.value = {
  set: function (value) {
    if (value === false || value === null || value === undefined) {
      this.$input.value = this._format;
      this._value = null;
    } else if (typeof value == 'string' || typeof value == 'number') {
      this._value = (0, _datetime.beginOfDay)(new Date(value));
      this.$input.value = (0, _datetime.formatDateString)(this._value, this._format);
    } else if (value.getTime) {
      this._value = (0, _datetime.beginOfDay)(value);
      this.$input.value = (0, _datetime.formatDateString)(this._value, this._format);
    }

    this._lastValue = this._value;
    this._calendarHolder.calendarProps.selectedDates = [this._value || new Date()];
  },
  get: function () {
    return this._value;
  }
};
DateInput.property.format = {
  set: function (value) {
    value = value || 'dd/mm/yyyy';
    if (value == this._format) return;

    if (DateInput.formaters[value]) {
      this._formater = DateInput.formaters[value];
      this._format = value;
      this.value = this.value;
    } else {
      throw new Error("Not support format " + value);
    }
  },
  get: function () {
    return this._format;
  }
};
DateInput.property.disabled = {
  set: function (value) {
    value = !!value;
    this.$input.disabled = value;
    if (value) this.addClass('as-disabled');else this.removeClass('as-disabled');
  },
  get: function () {
    return this.$input.disabled;
  }
};

_ACore.default.install(DateInput);

var _default = DateInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/DateTimeInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/DateTimeInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireWildcard(require("../ACore"));

require("../css/datetimeinput.css");

var _DomSignal = _interopRequireDefault(require("absol/src/HTML5/DomSignal"));

var _utils = require("./utils");

var _datetime = require("absol/src/Time/datetime");

var _ChromeTimePicker = _interopRequireDefault(require("./ChromeTimePicker"));

var _ChromeCalendar = _interopRequireDefault(require("./ChromeCalendar"));

var _Follower = _interopRequireDefault(require("./Follower"));

var _EventEmitter = require("absol/src/HTML5/EventEmitter");




var STATE_NEW = 1;
var STATE_EDITED = 2;
var STATE_NONE = 0;
/***
 * @extends AElement
 * @constructor
 */

function DateTimeInput() {
  this._editingData = {};
  this._value = null;
  this._min = new Date(1890, 0, 1);
  this._max = new Date(new Date(2090, 0, 1).getTime() - 1);
  this._format = 'dd/MM/yyyy hh:mm a';
  this.$attachhook = (0, _ACore._)('attachhook').addTo(this);
  this.domSignal = new _DomSignal.default(this.$attachhook);
  this.domSignal.on('request_auto_select', this._autoSelect.bind(this));
  /***
   *
   * @type {HTMLInputElement | AElement}
   */

  this.$text = (0, _ACore.$)('.as-date-time-input-text', this).on('mousedown', this.eventHandler.mouseDownInput).on('mouseup', this.eventHandler.mouseUpInput).on('dblclick', this.eventHandler.dblclickInput).on('keydown', this.eventHandler.keydown).on('blur', this.eventHandler.inputBlur).on('contextmenu', function (event) {
    event.preventDefault();
  });
  this.$pickerBtn = (0, _ACore.$)('.as-date-time-input-icon-btn', this).on('click', this.eventHandler.clickPickerBtn);
  this.$clearBtn = (0, _ACore.$)('button.as-time-input-clear-btn', this).on('click', this.clear.bind(this));
  this.notNull = false;
  this.min = this._min;
  this.max = this._max;
}

DateTimeInput.tag = 'DateTimeInput'.toLowerCase(); //calendar-clock

DateTimeInput.render = function () {
  return (0, _ACore._)({
    extendEvent: ['change'],
    class: 'as-date-time-input',
    child: [{
      tag: 'input',
      class: 'as-date-time-input-text',
      attr: {
        ondrop: "return false;"
      },
      props: {
        value: 'dd/MM/yyyy hh:mm a'
      }
    }, {
      tag: 'button',
      class: 'as-time-input-clear-btn',
      child: 'span.mdi.mdi-close-circle'
    }, {
      tag: 'button',
      class: 'as-date-time-input-icon-btn',
      child: 'span.mdi.mdi-calendar-clock'
    }]
  });
};

DateTimeInput.prototype.tokenRegex = /([^.\/:\-,\\\s]+)|([.\/:\-,\\]+)/i;
/***
 *
 * @param start
 * @returns {null|{ident: string, length: number, sourceText: string, replace: function(s: string, selecting:boolean):void, text: string, idx: number, elt: (HTMLInputElement|absol.AElement)}}
 */

DateTimeInput.prototype._tokenAt = function (start) {
  var rgx = new RegExp(this.tokenRegex.source, 'g');
  var rgxFormat = new RegExp(this.tokenRegex.source, 'g');
  var s = this.$text.value;
  var format = this._format;
  var tokenMatched = rgx.exec(s);
  var formatToken = rgxFormat.exec(format);
  var tokenMatchedList = [];
  var formatTokenList = [];
  var text, ident;
  var idx;

  while (tokenMatched && formatToken) {
    text = tokenMatched[1];
    ident = formatToken[1];

    if (text && (0, _utils.isDateTimeFormatToken)(ident)) {
      tokenMatchedList.push(tokenMatched);
      formatTokenList.push(formatToken);
    }

    tokenMatched = rgx.exec(s);
    formatToken = rgxFormat.exec(format);
  }

  var bestI = -1;
  var bestD = Infinity;
  var d;

  for (var i = 0; i < tokenMatchedList.length; ++i) {
    tokenMatched = tokenMatchedList[i];
    formatToken = formatTokenList[i];
    text = tokenMatched[1];
    idx = tokenMatched.index;
    d = Math.min(Math.abs(start - idx), Math.abs(start - (idx + text.length)));

    if (d < bestD) {
      bestD = d;
      bestI = i;
    }
  }

  if (bestI >= 0) {
    tokenMatched = tokenMatchedList[bestI];
    formatToken = formatTokenList[bestI];
    text = tokenMatched[1];
    ident = formatToken[1];
    idx = tokenMatched.index;
    return {
      idx: idx,
      text: text,
      length: text.length,
      ident: ident,
      elt: this.$text,
      sourceText: s,
      replace: function (newText, selecting) {
        var left = this.sourceText.substr(0, this.idx);
        var right = this.sourceText.substr(this.idx + this.length);
        this.text = newText;
        this.length = newText.length;
        this.sourceText = left + this.text + right;
        this.elt.value = this.sourceText;

        if (selecting) {
          this.elt.setSelectionRange(this.idx, this.idx + this.length);
        }
      }
    };
  }

  return null;
};

DateTimeInput.prototype._autoSelect = function () {
  var token = this._tokenAt(this.$text.selectionStart);

  var tokenEnd = this._tokenAt(this.$text.selectionEnd);

  if (token) {
    if (tokenEnd.idx === token.idx) {
      this.$text.setSelectionRange(token.idx, token.idx + token.length);
      this._editingData.state = STATE_NEW;
    } else {
      this.$text.select();
      this._editingData.state = STATE_NONE;
    }
  }
};

DateTimeInput.prototype._editNextToken = function () {
  var token = this._tokenAt(this.$text.selectionStart);

  if (!token) return false;
  var cIdx = token.idx;
  var l = this.$text.value.length;

  for (var i = token.idx + token.length; i < l; ++i) {
    token = this._tokenAt(i);

    if (token && token.idx !== cIdx) {
      this.$text.setSelectionRange(token.idx, token.idx + token.length);
      this._editingData.state = STATE_NEW;
      break;
    }
  }
};

DateTimeInput.prototype._editPrevToken = function () {
  var token = this._tokenAt(this.$text.selectionStart);

  if (!token) return false;
  var cIdx = token.idx;
  var l = this.$text.value.length;

  for (var i = token.idx - 1; i >= 0; --i) {
    token = this._tokenAt(i);

    if (token && token.idx !== cIdx) {
      this.$text.setSelectionRange(token.idx, token.idx + token.length);
      this._editingData.state = STATE_NEW;
      break;
    }
  }
};

DateTimeInput.prototype.tokenMap = {
  d: 'd',
  dd: 'd',
  M: 'M',
  MM: 'M',
  y: 'y',
  yyyy: 'y',
  hh: 'h',
  h: 'h',
  mm: 'm',
  m: 'm',
  a: 'a'
};
/***
 *
 * @param {string} s
 * @returns {{}}
 * @private
 */

DateTimeInput.prototype._makeTokenDict = function (s) {
  var rgx = new RegExp(this.tokenRegex.source, 'g');
  var rgxFormat = new RegExp(this.tokenRegex.source, 'g');
  var format = this._format;
  var tokenMap = this.tokenMap;
  var tokenMatched = rgx.exec(s);
  var formatToken = rgxFormat.exec(format);
  var text, ident;
  var idx;
  var res = {};

  while (tokenMatched && formatToken) {
    text = tokenMatched[1];
    ident = formatToken[1];

    if (text) {
      if (tokenMap[ident]) {
        idx = tokenMatched.index;
        res[tokenMap[ident]] = {
          text: text,
          idx: idx,
          length: text.length,
          sourceText: s,
          value: ident === 'a' ? text : parseInt(text)
        };
      }
    }

    tokenMatched = rgx.exec(s);
    formatToken = rgxFormat.exec(format);
  }

  return res;
};
/***
 *
 * @param {Date} date
 * @private
 */


DateTimeInput.prototype._makeValueDict = function (date) {
  var res = {};
  res.d = {
    value: date.getDate()
  };
  res.y = {
    value: date.getFullYear()
  };
  res.M = {
    value: date.getMonth() + 1
  };
  res.m = {
    value: date.getMinutes()
  };
  res.h = {
    value: date.getHours()
  };

  if (res.h.value < 12) {
    if (res.h.value === 0) res.h.value = 12;
    res.a = {
      value: "AM"
    };
  } else {
    if (res.h.value > 12) res.h.value -= 12;
    res.a = {
      value: "PM"
    };
  }

  return res;
};

DateTimeInput.prototype._applyTokenDict = function (format, dict, debug) {
  var rgx = new RegExp(this.tokenRegex.source, 'g');
  var tokenMap = this.tokenMap;
  return format.replace(rgx, function (full, g1, g2, sourceText) {
    if (g1 && tokenMap[g1]) {
      var ident = tokenMap[g1];

      if (ident === 'a') {
        return dict.a && dict.a.value || 'a';
      } else {
        if (dict[ident] && !isNaN(dict[ident].value)) {
          var numberText = dict[ident].value + '';

          while (numberText.length < g1.length) numberText = '0' + numberText;

          return numberText;
        } else {
          return full;
        }
      }
    } else return full;
  });
};

DateTimeInput.prototype._loadValueFromInput = function () {
  var tkDict = this._makeTokenDict(this.$text.value);

  var H = NaN;

  if (tkDict.a.value === 'AM') {
    H = tkDict.h.value % 12;
  } else if (tkDict.a.value === 'PM') {
    H = tkDict.h.value + (tkDict.h.value === 12 ? 0 : 12);
  }

  var date = new Date(tkDict.y.value, tkDict.M.value - 1, tkDict.d.value, H, tkDict.m.value);

  if (isNaN(date.getTime())) {
    this._value = null;
  } else {
    this._value = date;
  }
};

DateTimeInput.prototype.clear = function () {
  var lev = this._lastEmitValue;

  if (this.notNull) {
    this.value = (0, _datetime.formatDateTime)(new Date(Math.max(this.min.getTime(), Math.min(this.max.getTime(), new Date().getTime()))), this.format);
  } else {
    this.value = null;
  }

  this._lastEmitValue = lev;

  this._notifyIfChange();
};

DateTimeInput.prototype._notifyIfChange = function (event) {
  if (!this._lastEmitValue && !this._value) return;
  if (this._lastEmitValue && this._value && this._lastEmitValue.getTime() === this._value.getTime()) return;
  this.emit('change', {
    type: 'change',
    target: this,
    value: this._value,
    originEvent: event
  }, this);
  this._lastEmitValue = this._value;
};

DateTimeInput.prototype._correctingInput = function () {
  var tkDict = this._makeTokenDict(this.$text.value);

  var equalMin = true;
  var equalMax = true;

  if (!isNaN(tkDict.y.value)) {
    tkDict.y.value = Math.max(this._min.getFullYear(), Math.min(this._max.getFullYear(), tkDict.y.value));
    equalMin = tkDict.y.value === this._min.getFullYear();
    equalMax = tkDict.y.value === this._max.getFullYear();
  } else {
    equalMin = false;
    equalMax = false;
  }

  if (!isNaN(tkDict.M.value)) {
    tkDict.M.value = Math.max(1, Math.min(12, tkDict.M.value));

    if (equalMin) {
      tkDict.M.value = Math.max(this._min.getMonth() + 1, tkDict.M.value);
      equalMin = tkDict.M.value === this._min.getMonth() + 1;
    }

    if (equalMax) {
      tkDict.M.value = Math.min(this._max.getMonth() + 1, tkDict.M.value);
      equalMax = this._max.getMonth() + 1;
    }
  } else {
    equalMin = false;
    equalMax = false;
  }

  if (!isNaN(tkDict.d.value)) {
    tkDict.d.value = Math.max(1, Math.min(31, tkDict.d.value));

    if (!isNaN(tkDict.M.value)) {
      tkDict.d.value = Math.min(tkDict.d.value, (0, _datetime.daysInMonth)(isNaN(tkDict.y.value) ? 2020 : tkDict.y.value, tkDict.M.value - 1));
    }

    if (equalMin) {
      tkDict.d.value = Math.max(this._min.getDate(), tkDict.d.value);
      equalMin = tkDict.d.value === this._min.getDate();
    }

    if (equalMax) {
      tkDict.d.value = Math.min(this._max.getDate(), tkDict.d.value);
      equalMax = tkDict.d.value === this._max.getDate();
    }
  } else {
    equalMin = false;
    equalMax = false;
  } //todo: min max


  if (tkDict.a.value === 'AM' || tkDict.a.value === 'PM') {
    if (equalMin) {}
  } else {
    equalMin = false;
    equalMax = false;
  }

  var text = this._applyTokenDict(this._format, tkDict);

  this.$text.value = text;
};

DateTimeInput.prototype._correctingCurrentToken = function () {
  var token = this._tokenAt(this.$text.selectionStart);

  if (!token) return;
  var value;

  if (token.ident === 'a') {
    if (token.text !== 'a' && token.text !== 'AM' && token.text !== 'PM') {
      token.replace('a', false);
    }
  } else {
    value = parseInt(token.text);
    var rqMin = {
      d: 1,
      dd: 1,
      M: 1,
      MM: 1,
      y: 1890,
      yyyy: 1890,
      h: 1,
      hh: 1,
      m: 0,
      mm: 0
    }[token.ident];
    var rqMax = {
      d: 31,
      dd: 31,
      M: 12,
      MM: 12,
      y: 2089,
      yyyy: 2089,
      h: 12,
      hh: 12,
      m: 59,
      mm: 59
    }[token.ident];

    if (rqMin !== undefined) {
      if (!isNaN(value)) {
        if (value < rqMin || value > rqMin) {
          value = Math.max(rqMin, Math.min(rqMax, value));
          token.replace((0, _utils.zeroPadding)(value, token.ident.length), false);
          this._editingData.d = value;
        }
      } else if (token.text !== token.ident) {
        token.replace(token.ident, false);
      }
    }
  }
};

DateTimeInput.prototype._dateFrom = function (value) {
  var typeV = typeof value;

  if (typeV === 'string' || typeV === 'number') {
    value = new Date(value);
  }

  if (!value || !value.getTime) value = null;

  if (value) {
    value = new Date(value.getTime());
    value.setSeconds(0, 0);
  }

  return value || null;
};

DateTimeInput.property = {};
DateTimeInput.property.disabled = {
  set: function (value) {
    this.$text.disabled = !!value;

    if (value) {
      this.addClass('as-disabled');
    } else {
      this.removeClass('as-disabled');
    }
  },
  get: function () {
    return this.containsClass('as-disabled');
  }
};
DateTimeInput.property.format = {
  set: function (value) {
    var dict;

    if (this._value) {
      dict = this._makeValueDict(this._value);
    } else {
      dict = this._makeTokenDict(this.$text.value);
    }

    this._format = value;
    this.$text.value = this._applyTokenDict(value, dict);
  },
  get: function () {
    return this._format;
  }
};
DateTimeInput.property.value = {
  set: function (value) {
    this._value = this._dateFrom(value);
    var dict;

    if (this._value) {
      dict = this._makeValueDict(this._value);
    } else {
      dict = this._makeTokenDict(this.$text.value);
    }

    if (value) {
      this.$text.value = this._applyTokenDict(this._format, dict, true);
    } else {
      this.$text.value = this.format;
    }

    this._lastEmitValue = this._value;
  },
  get: function () {
    return this._value;
  }
};
DateTimeInput.property.min = {
  set: function (value) {
    this._min = this._dateFrom(value) || new Date(1890, 0, 1);
  },
  get: function () {
    return this._min;
  }
};
DateTimeInput.property.max = {
  set: function (value) {
    this._max = this._dateFrom(value) || new Date(new Date(2090, 0, 1).getTime() - 1);
  },
  get: function () {
    return this._max;
  }
};
DateTimeInput.eventHandler = {};

DateTimeInput.eventHandler.mouseUpInput = function () {
  this.domSignal.emit('request_auto_select');
};

DateTimeInput.eventHandler.mouseDownInput = function () {
  if (document.activeElement === this.$text) {
    this._correctingCurrentToken();
  }
};

DateTimeInput.eventHandler.dblclickInput = function (event) {
  event.preventDefault();
};
/***
 *
 * @param {KeyboardEvent} event
 */


DateTimeInput.eventHandler.keydown = function (event) {
  var token = this._tokenAt(this.$text.selectionStart);

  var endToken = this._tokenAt(this.$text.selectionEnd);

  if (!token) {
    if (event.key === 'Enter') {
      this._correctingInput();

      this._loadValueFromInput();

      this._notifyIfChange(event);
    }

    return;
  }

  var newTokenText;
  var value;

  if (event.key.startsWith('Arrow') || [' ', ':', '/', '-'].indexOf(event.key) >= 0) {
    event.preventDefault();

    switch (event.key) {
      case 'ArrowLeft':
        this._editPrevToken();

        break;

      case 'ArrowRight':
      case ' ':
      case ':':
      case '/':
      case '-':
        this._editNextToken();

        break;

      case 'ArrowUp':
      case 'ArrowDown':
        switch (token.ident) {
          case 'dd':
          case 'd':
            value = parseInt(token.text);

            if (isNaN(value)) {
              this._editingData.d = event.key === 'ArrowUp' ? 1 : 31;
            } else {
              this._editingData.d = 1 + (value + (event.key === 'ArrowUp' ? 0 : 29)) % 31;
            }

            newTokenText = '' + this._editingData.d;

            while (newTokenText.length < token.ident.length) newTokenText = '0' + newTokenText;

            token.replace(newTokenText, true);
            break;

          case 'MM':
          case 'M':
            value = parseInt(token.text) - 1;

            if (isNaN(value)) {
              this._editingData.M = event.key === 'ArrowUp' ? 0 : 11;
            } else {
              this._editingData.M = (value + (event.key === 'ArrowUp' ? 1 : 11)) % 12;
            }

            newTokenText = '' + (this._editingData.M + 1);

            while (newTokenText.length < token.ident.length) newTokenText = '0' + newTokenText;

            token.replace(newTokenText, true);
            break;

          case 'yyyy':
            value = parseInt(token.text);

            if (isNaN(value)) {
              this._editingData.y = new Date().getFullYear();
            } else {
              this._editingData.y = Math.max(1890, Math.min(2089, value + (event.key === 'ArrowUp' ? 1 : -1)));
            }

            newTokenText = this._editingData.y + '';

            while (newTokenText.length < token.ident.length) newTokenText = '0' + newTokenText;

            token.replace(newTokenText, true);
            break;

          case "hh":
          case 'h':
            value = parseInt(token.text);

            if (isNaN(value)) {
              this._editingData.h = event.key === 'ArrowUp' ? 1 : 12;
            } else {
              this._editingData.h = 1 + (value + (event.key === 'ArrowUp' ? 0 : 10)) % 12;
            }

            newTokenText = this._editingData.h + '';

            while (newTokenText.length < token.ident.length) newTokenText = '0' + newTokenText;

            token.replace(newTokenText, true);
            break;

          case "mm":
          case 'm':
            value = parseInt(token.text);

            if (isNaN(value)) {
              this._editingData.m = event.key === 'ArrowUp' ? 0 : 59;
            } else {
              this._editingData.m = (value + (event.key === 'ArrowUp' ? 1 : 59)) % 60;
            }

            newTokenText = this._editingData.m + '';

            while (newTokenText.length < token.ident.length) newTokenText = '0' + newTokenText;

            token.replace(newTokenText, true);
            break;

          case 'a':
            value = token.text;
            this._editingData.a = value === 'PM' ? "AM" : "PM";
            newTokenText = this._editingData.a;
            token.replace(newTokenText, true);
            break;
        }

        break;
    }
  } else if (event.key === "Delete" || event.key === 'Backspace') {
    event.preventDefault();

    if (endToken.idx !== token.idx) {
      if (this.notNull) {
        this.$text.value = (0, _datetime.formatDateTime)(new Date(Math.max(this.min.getTime(), Math.min(this.max.getTime(), new Date().getTime()))), this.format);
      } else {
        this.$text.value = this._format;
      }

      this.$text.select();
    } else {
      if (this.notNull) {
        switch (token.ident) {
          case 'HH':
          case 'mm':
          case 'H':
          case 'm':
            token.replace((0, _utils.zeroPadding)(0, token.ident.length), true);
            break;

          case 'h':
          case 'hh':
            token.replace('12', true);
            break;

          case 'M':
          case 'MM':
          case 'dd':
          case 'd':
            token.replace((0, _utils.zeroPadding)(1, token.ident.length), true);
            break;

          case 'y':
          case 'yyyy':
            token.replace((0, _utils.zeroPadding)(Math.max(this.min.getFullYear(), Math.min(this.max.getFullYear(), new Date().getFullYear())), token.ident.length), true);
            break;

          case 'a':
            token.replace('AM', true);
            break;
        }
      } else {
        token.replace(token.ident, true);
      }

      if (event.key === "Delete") this._editNextToken();else this._editPrevToken();
    }
  } else if (event.key === "Enter" || event.key === 'Tab') {
    this._correctingInput();

    this._loadValueFromInput();

    this._notifyIfChange(event);
  } else if (event.ctrlKey) {
    switch (event.key) {
      case 'a':
      case 'A':
        break;

      case 'c':
      case 'C':
        break;

      case 'x':
      case 'X':
        this.domSignal.once('clear_value', function () {
          this.$text.value = this._format;
          this.$text.select();
        }.bind(this));
        this.domSignal.emit('clear_value');
        break;

      default:
        event.preventDefault();
    }
  } else if (event.key.match(/^[0-9]$/g)) {
    event.preventDefault();
    var dVal = parseInt(event.key);

    if (this._editingData.state === STATE_NEW) {
      switch (token.ident) {
        case 'dd':
        case 'd':
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          this._editingData.state = STATE_EDITED;
          this._editingData.d = dVal;

          if (dVal > 3) {
            this._editNextToken();
          }

          break;

        case 'MM':
        case 'M':
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          this._editingData.state = STATE_EDITED;
          this._editingData.M = dVal;

          if (dVal > 1) {
            this._editNextToken();
          }

          break;

        case 'yyyy':
        case 'y':
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          this._editingData.state = STATE_EDITED;
          this._editingData.state_num = 1;
          break;

        case 'm':
        case 'mm':
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          this._editingData.state = STATE_EDITED;

          if (dVal > 5) {
            this._editNextToken();
          }

          break;

        case 'h':
        case 'hh':
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          this._editingData.state = STATE_EDITED;

          if (dVal > 1) {
            this._editNextToken();
          }

          break;
      }
    } else {
      switch (token.ident) {
        case 'dd':
        case 'd':
          dVal = (parseInt(token.text.split('').pop()) || 0) * 10 + dVal;
          dVal = Math.max(1, Math.min(31, dVal));
          this._editingData.d = dVal;
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);

          this._editNextToken();

          break;

        case 'MM':
        case 'M':
          dVal = (parseInt(token.text.split('').pop()) || 0) * 10 + dVal;
          dVal = Math.max(1, Math.min(12, dVal));
          this._editingData.M = dVal - 1;
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);

          this._editNextToken();

          break;

        case 'yyyy':
        case 'y':
          dVal = (parseInt(token.text.replace(/^./, '')) || 0) * 10 + dVal;
          this._editingData.state_num++;

          if (this._editingData.state_num >= 4) {
            // dVal = Math.max(1890, Math.min(2089, dVal));
            token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);

            this._editNextToken();
          } else {
            token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          }

          break;

        case 'm':
        case 'mm':
          dVal = (parseInt(token.text.split('').pop()) || 0) * 10 + dVal;
          dVal = Math.max(0, Math.min(59, dVal));
          this._editingData.m = dVal;
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);

          this._editNextToken();

          break;

        case 'h':
        case 'hh':
          dVal = (parseInt(token.text.split('').pop()) || 0) * 10 + dVal;
          dVal = Math.max(1, Math.min(12, dVal));
          this._editingData.h = dVal;
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);

          this._editNextToken();

          break;
      }
    }
  } else if (event.key.match(/^[aApPSCsc]$/) && token.ident === 'a') {
    event.preventDefault();

    if (event.key.match(/^[aAsS]$/)) {
      token.replace('AM', true);
      this._editingData.a = "AM";
    } else {
      token.replace('PM', true);
      this._editingData.a = "PM";
    }

    this._editNextToken();
  } else {
    event.preventDefault();
  }
};

DateTimeInput.eventHandler.inputBlur = function () {
  this._correctingInput();

  this._loadValueFromInput();

  this._notifyIfChange();
};

DateTimeInput.eventHandler.clickPickerBtn = function () {
  this._attachPicker();
};

DateTimeInput.eventHandler.clickOut = function (event) {
  if ((0, _EventEmitter.hitElement)(this.share.$follower, event)) return;

  this._releasePicker();
};

DateTimeInput.eventHandler.calendarPick = function (event) {
  var value = event.value;

  var tkDict = this._makeTokenDict(this.$text.value);

  if (tkDict.y) {
    tkDict.y.value = value.getFullYear();
  }

  if (tkDict.M) {
    tkDict.M.value = value.getMonth() + 1;
  }

  if (tkDict.d) {
    tkDict.d.value = value.getDate();
  }

  this.$text.value = this._applyTokenDict(this._format, tkDict);

  this._correctingInput();

  this._loadValueFromInput();

  this._notifyIfChange(event);
};

DateTimeInput.eventHandler.timePick = function (event) {
  var hour = event.hour;
  var minute = event.minute;

  var tkDict = this._makeTokenDict(this.$text.value);

  if (tkDict.h) {
    tkDict.h.value = 1 + (hour + 11) % 12;

    if (tkDict.a) {
      tkDict.a.value = hour >= 12 ? "PM" : 'AM';
    }
  }

  if (tkDict.m) {
    tkDict.m.value = minute;
  }

  this.$text.value = this._applyTokenDict(this._format, tkDict);

  this._correctingInput();

  this._loadValueFromInput();

  this._notifyIfChange(event);
};

DateTimeInput.prototype.share = {
  $follower: null,
  $calendar: null,
  $timePicker: null,
  $holdingInput: null
};

DateTimeInput.prototype._preparePicker = function () {
  if (!this.share.$follower) {
    this.share.$timePicker = (0, _ACore._)({
      tag: _ChromeTimePicker.default.tag,
      class: 'as-date-time-input-time-picker'
    });
    this.share.$calendar = (0, _ACore._)({
      tag: _ChromeCalendar.default.tag,
      class: 'as-date-time-input-time-picker'
    });
    this.share.$follower = (0, _ACore._)({
      tag: _Follower.default.tag,
      class: 'as-date-time-input-follower',
      child: [this.share.$calendar, this.share.$timePicker]
    });
  }
};

DateTimeInput.prototype._attachPicker = function () {
  this._preparePicker();

  if (this.share.$holdingInput) this.share.$holdingInput._releasePicker();
  this.share.$holdingInput = this;
  this.share.$follower.addStyle('visibility', 'hidden');
  this.share.$follower.addTo(document.body);
  this.share.$follower.followTarget = this;
  this.$pickerBtn.off('click', this.eventHandler.clickPickerBtn);
  this.share.$calendar.on('pick', this.eventHandler.calendarPick);
  this.share.$timePicker.on('change', this.eventHandler.timePick);

  var tkDict = this._makeTokenDict(this.$text.value);

  if (tkDict.h && !isNaN(tkDict.h.value)) {
    if (tkDict.a && tkDict.a.value === 'PM') {
      this.share.$timePicker.hour = 12 + tkDict.h.value % 12;
    } else {
      this.share.$timePicker.hour = tkDict.h.value % 12;
    }
  } else {
    this.share.$timePicker.hour = 0;
  }

  if (tkDict.m && !isNaN(tkDict.m.value)) {
    this.share.$timePicker.minute = tkDict.m.value;
  } else {
    this.share.$timePicker.minute = 0;
  }

  var date = null;

  if (tkDict.d && !isNaN(tkDict.d.value) && tkDict.M && !isNaN(tkDict.M.value) && tkDict.y && !isNaN(tkDict.y.value)) {
    date = new Date(tkDict.y.value, tkDict.M.value - 1, tkDict.d.value);
    if (isNaN(date.getTime())) date = null;
  }

  if (date) {
    this.share.$calendar.selectedDates = [date];
    this.share.$calendar.viewDate = date;
  } else {
    this.share.$calendar.selectedDates = [];
    var viewDate = null;

    if (tkDict.y && !isNaN(tkDict.y.value)) {
      if (tkDict.M && !isNaN(tkDict.M.value)) {
        if (tkDict.d && !isNaN(tkDict.d.value)) {
          viewDate = new Date(tkDict.y.value, tkDict.M.value - 1, tkDict.d.value);
        } else {
          viewDate = new Date(tkDict.y.value, tkDict.M.value - 1, 1);
        }
      } else {
        viewDate = new Date(tkDict.y.value, 0, 1);
      }
    } else {
      viewDate = new Date();
    }

    if (viewDate && !isNaN(viewDate.getTime())) {
      this.share.$calendar.viewDate = viewDate;
    } else {
      this.share.$calendar.viewDate = new Date();
    }
  }

  setTimeout(function () {
    this.share.$follower.removeStyle('visibility');
    document.body.addEventListener('click', this.eventHandler.clickOut);
  }.bind(this), 5);
};

DateTimeInput.prototype._releasePicker = function () {
  if (this.share.$holdingInput !== this) return;
  this.share.$follower.remove();
  this.share.$holdingInput = null;
  this.share.$calendar.off('pick', this.eventHandler.calendarPick);
  this.share.$timePicker.off('change', this.eventHandler.timePick);
  document.body.removeEventListener('click', this.eventHandler.clickOut);
  setTimeout(function () {
    this.$pickerBtn.on('click', this.eventHandler.clickPickerBtn);
  }.bind(this));
};

_ACore.default.install(DateTimeInput);

var _default = DateTimeInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/DateInput2.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/DateInput2.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/dateinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _datetime = require("absol/src/Time/datetime");

var _ChromeCalendar = _interopRequireDefault(require("./ChromeCalendar"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _DateInput = _interopRequireDefault(require("./DateInput"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _DomSignal = _interopRequireDefault(require("absol/src/HTML5/DomSignal"));

var _DateTimeInput = _interopRequireDefault(require("./DateTimeInput"));

var _utils = require("./utils");

var _EventEmitter = require("absol/src/HTML5/EventEmitter");


var STATE_NEW = 1;
var STATE_EDITED = 2;
var STATE_NONE = 0;
var _ = _ACore.default._;
var $ = _ACore.default.$;
/**
 * @extends AElement
 * @constructor
 */

function DateInput2() {
  this._lastValue = null;
  this._value = null;
  this._format = 'dd/MM/yyyy';
  this.$input = $('input', this);
  this._editingData = {};
  this.$text = this.$input;
  this.$text.on('mousedown', this.eventHandler.mouseDownInput).on('mouseup', this.eventHandler.mouseUpInput).on('dblclick', this.eventHandler.dblclickInput).on('keydown', this.eventHandler.keydown).on('blur', this.eventHandler.inputBlur).on('contextmenu', function (event) {
    event.preventDefault();
  });
  this.$domSignal = _('attachhook').addTo(this);
  this.domSignal = new _DomSignal.default(this.$domSignal);
  this.domSignal.on('request_auto_select', this._autoSelect.bind(this));
  this._min = new Date(1890, 0, 1, 0, 0, 0, 0);
  this._max = new Date(2090, 0, 1, 0, 0, 0, 0);
  this.$calendarBtn = $('.as-date-input-icon-ctn', this).on('click', this.eventHandler.clickCalendarBtn);
  this.$clearBtn = $('button.as-date-input-clear-btn', this).on('click', this.clear.bind(this));
  this.value = this._value;
  this.format = this._format;
  this.notNull = false;

  _OOP.default.drillProperty(this, this, 'minLimitDate', 'min');

  _OOP.default.drillProperty(this, this, 'minDateLimit', 'min');

  _OOP.default.drillProperty(this, this, 'maxLimitDate', 'max');

  _OOP.default.drillProperty(this, this, 'maxDateLimit', 'max');
}

DateInput2.tag = 'dateinput';

DateInput2.render = function () {
  //only support dd/mm/yyyy
  return _({
    class: 'as-date-input',
    extendEvent: ['change'],
    child: [{
      tag: 'input',
      class: 'as-date-input-text',
      props: {
        value: '__/__/____'
      }
    }, {
      tag: 'button',
      class: 'as-date-input-clear-btn',
      child: 'span.mdi.mdi-close-circle'
    }, {
      class: 'as-date-input-icon-ctn',
      child: 'span.mdi.mdi-calendar'
    }]
  });
};
/**
 * @param {String} text
 */


DateInput2.prototype._verifyFormat = function (text) {
  var regex = /([,.\-\/])|([a-zA-Z0-9]+)/g;
  var tokens = text.match(regex);
  var count = [['dd', 'd'], ['M', 'MM'], ['yy', 'yyyy']].map(function (list) {
    return list.reduce(function (ac, cr) {
      if (tokens.indexOf(cr) >= 0) return ac + 1;
      return ac;
    }, 0);
  });
  return count[0] <= count[1] && count[1] <= count[2] && count[2] === 1;
};

DateInput2.prototype._notifyIfChange = function (event) {
  if (!this._lastValue !== !this._value || (this._lastValue && (0, _datetime.compareDate)(this._lastValue, this._value)) !== 0) {
    this._lastValue = this._value;
    this.emit('change', {
      type: 'change',
      target: this,
      value: this._value,
      originEvent: event
    }, this);
  }
};

DateInput2.prototype.notifyChange = function () {
  this._lastValue = this._value;
  this.emit('change', {
    type: 'change',
    target: this,
    value: this._value
  }, this);
};

DateInput2.prototype.focus = function () {
  this.$input.focus();
};

DateInput2.prototype.blur = function () {
  this.$input.blur();
};

DateInput2.prototype.clear = function () {
  this._applyValue(null);

  this._notifyIfChange();
};
/***
 *
 * @param {Date|null} value
 */


DateInput2.prototype._applyValue = function (value) {
  this._value = value;

  if (!value) {
    this.$input.value = this.format;
  } else {
    this.$input.value = (0, _datetime.formatDateTime)(this._value, this._format);
  }

  this._updateNullClass();
};

DateInput2.prototype._updateNullClass = function () {
  var value = this._value;

  if (!value) {
    this.addClass('as-value-null');
  } else {
    this.removeClass('as-value-null');
  }
};

DateInput2.prototype.tokenRegex = _DateTimeInput.default.prototype.tokenRegex;
DateInput2.prototype._autoSelect = _DateTimeInput.default.prototype._autoSelect;
DateInput2.prototype._tokenAt = _DateTimeInput.default.prototype._tokenAt;
DateInput2.prototype._editNextToken = _DateTimeInput.default.prototype._editNextToken;
DateInput2.prototype._editPrevToken = _DateTimeInput.default.prototype._editPrevToken;
DateInput2.prototype._makeTokenDict = _DateTimeInput.default.prototype._makeTokenDict;

DateInput2.prototype._correctingInput = function () {
  var tkDict = this._makeTokenDict(this.$text.value);

  var min = this._min;
  var max = this._max;
  var equalMin;
  var equalMax;

  if (!isNaN(tkDict.y.value)) {
    tkDict.y.value = Math.max(min.getFullYear(), Math.min(max.getFullYear(), tkDict.y.value));
    equalMin = tkDict.y.value === min.getFullYear();
    equalMax = tkDict.y.value === max.getFullYear();
  } else {
    equalMin = false;
    equalMax = false;
  }

  if (tkDict.M && !isNaN(tkDict.M.value)) {
    tkDict.M.value = Math.max(1, Math.min(12, tkDict.M.value));

    if (equalMin) {
      tkDict.M.value = Math.max(min.getMonth() + 1, tkDict.M.value);
      equalMin = tkDict.M.value === min.getMonth() + 1;
    }

    if (equalMax) {
      tkDict.M.value = Math.min(max.getMonth() + 1, tkDict.M.value);
      equalMax = max.getMonth() + 1;
    }
  } else {
    equalMin = false;
    equalMax = false;
  }

  if (tkDict.d && !isNaN(tkDict.d.value)) {
    tkDict.d.value = Math.max(1, Math.min(31, tkDict.d.value));

    if (!isNaN(tkDict.M.value)) {
      tkDict.d.value = Math.min(tkDict.d.value, (0, _datetime.daysInMonth)(isNaN(tkDict.y.value) ? 2020 : tkDict.y.value, tkDict.M.value - 1));
    }

    if (equalMin) {
      tkDict.d.value = Math.max(min.getDate(), tkDict.d.value);
    }

    if (equalMax) {
      tkDict.d.value = Math.min(max.getDate(), tkDict.d.value);
    }
  }

  var text = this._applyTokenDict(this._format, tkDict);

  this.$text.value = text;
};

DateInput2.prototype._correctingCurrentToken = function () {
  var token = this._tokenAt(this.$text.selectionStart);

  if (!token) return;
  var value;
  value = parseInt(token.text);
  var rqMin = {
    d: 1,
    dd: 1,
    M: 1,
    MM: 1,
    y: 1890,
    yyyy: 1890
  }[token.ident];
  var rqMax = {
    d: 31,
    dd: 31,
    M: 12,
    MM: 12,
    y: 2089,
    yyyy: 2089
  }[token.ident];

  if (rqMin !== undefined) {
    if (!isNaN(value)) {
      if (value < rqMin || value > rqMin) {
        value = Math.max(rqMin, Math.min(rqMax, value));
        token.replace((0, _utils.zeroPadding)(value, token.ident.length), false);
      }
    } else if (this.notNull) {
      if (token.ident.startsWith('y')) {
        value = new Date().getFullYear();
      } else {
        value = rqMin;
      }

      token.replace((0, _utils.zeroPadding)(value, token.ident.length), false);
    } else if (token.text !== token.ident) {
      token.replace(token.ident, false);
    }
  }
};
/***
 *
 * @param {Date|string|null}date
 * @return {Date|null}
 */


DateInput2.prototype._normalizeValue = function (date) {
  var temp;

  if (date === null || date === undefined || date === false) {
    return null;
  }

  if (typeof date === 'string') {
    temp = new Date(date);

    if (isNaN(temp.getTime())) {
      temp = (0, _datetime.parseDateTime)(date, this._format);
    }

    date = temp;
  } else if (typeof date === 'number') {
    date = new Date(date);
  }

  if (date.getTime && date.getHours) {
    if (isNaN(date.getTime())) {
      return null;
    } else {
      return (0, _datetime.beginOfDay)(date);
    }
  } else {
    return null;
  }
};

DateInput2.prototype._loadValueFromInput = function () {
  var tkDict = this._makeTokenDict(this.$text.value);

  var y = tkDict.y ? tkDict.y.value : new Date().getFullYear();
  var m = tkDict.M ? tkDict.M.value - 1 : 0;
  var d = tkDict.d ? tkDict.d.value : 1;
  var date = new Date(y, m, d);

  if (isNaN(date.getTime())) {
    this._value = null;
  } else {
    this._value = date;
  }

  this._updateNullClass();
};

DateInput2.prototype._applyTokenDict = function (format, dict, debug) {
  var rgx = new RegExp(this.tokenRegex.source, 'g');
  var tokenMap = this.tokenMap;
  return format.replace(rgx, function (full, g1, g2, sourceText) {
    if (g1 && tokenMap[g1]) {
      var ident = tokenMap[g1];

      if (dict[ident] && !isNaN(dict[ident].value)) {
        var numberText = dict[ident].value + '';

        while (numberText.length < g1.length) numberText = '0' + numberText;

        return numberText;
      } else {
        return full;
      }
    } else return full;
  });
};

DateInput2.prototype.focus = function () {
  this.$text.focus();
  this.$text.select();
};

DateInput2.prototype.tokenMap = {
  d: 'd',
  dd: 'd',
  M: 'M',
  MM: 'M',
  y: 'y',
  yyyy: 'y'
};
/**
 * @type {DateInput2}
 */

DateInput2.eventHandler = {};

DateInput2.eventHandler.keydown = function (event) {
  var token = this._tokenAt(this.$text.selectionStart);

  var endToken = this._tokenAt(this.$text.selectionEnd);

  if (!token) {
    if (event.key === 'Enter') {
      this._correctingInput();

      this._loadValueFromInput();

      this._notifyIfChange(event);
    }

    return;
  }

  var newTokenText;
  var value;

  if (event.key.startsWith('Arrow') || event.key.match(/^[\-/,\s]$/)) {
    event.preventDefault();

    switch (event.key) {
      case 'ArrowLeft':
        this._editPrevToken();

        break;

      case 'ArrowRight':
      case '-':
      case ',':
      case '/':
      case ' ':
        this._editNextToken();

        break;

      case 'ArrowUp':
      case 'ArrowDown':
        switch (token.ident) {
          case 'dd':
          case 'd':
            value = parseInt(token.text);

            if (isNaN(value)) {
              this._editingData.d = event.key === 'ArrowUp' ? 1 : 31;
            } else {
              this._editingData.d = 1 + (value + (event.key === 'ArrowUp' ? 0 : 29)) % 31;
            }

            newTokenText = '' + this._editingData.d;

            while (newTokenText.length < token.ident.length) newTokenText = '0' + newTokenText;

            token.replace(newTokenText, true);
            break;

          case 'MM':
          case 'M':
            value = parseInt(token.text) - 1;

            if (isNaN(value)) {
              this._editingData.M = event.key === 'ArrowUp' ? 0 : 11;
            } else {
              this._editingData.M = (value + (event.key === 'ArrowUp' ? 1 : 11)) % 12;
            }

            newTokenText = '' + (this._editingData.M + 1);

            while (newTokenText.length < token.ident.length) newTokenText = '0' + newTokenText;

            token.replace(newTokenText, true);
            break;

          case 'yyyy':
            value = parseInt(token.text);

            if (isNaN(value)) {
              this._editingData.y = new Date().getFullYear();
            } else {
              this._editingData.y = Math.max(1890, Math.min(2089, value + (event.key === 'ArrowUp' ? 1 : -1)));
            }

            newTokenText = this._editingData.y + '';

            while (newTokenText.length < token.ident.length) newTokenText = '0' + newTokenText;

            token.replace(newTokenText, true);
            break;
        }

    }
  } else if (event.key === "Delete" || event.key === 'Backspace') {
    event.preventDefault();

    if (endToken.idx !== token.idx) {
      if (this.notNull) {
        this.$text.value = (0, _datetime.formatDateTime)(new Date(Math.min(this.max.getTime(), Math.max(this.min.getTime(), new Date().getTime()))), this._format);
      } else {
        this.$text.value = this._format;
      }

      this.$text.select();
    } else {
      if (this.notNull) {
        switch (token.ident) {
          case 'y':
          case 'yyyy':
            token.replace((0, _utils.zeroPadding)(new Date().getFullYear(), token.ident.length), true);
            break;

          case 'M':
          case 'MM':
          case 'd':
          case 'dd':
            token.replace((0, _utils.zeroPadding)(1, token.ident.length), true);
            break;

          default:
            token.replace(token.ident, true);
        }
      } else {
        token.replace(token.ident, true);
      }

      if (event.key === "Delete") this._editNextToken();else this._editPrevToken();
    }
  } else if (event.key === "Enter" || event.key === 'Tab') {
    this._correctingInput();

    this._loadValueFromInput();

    this._notifyIfChange(event);
  } else if (event.ctrlKey) {
    switch (event.key) {
      case 'a':
      case 'A':
        break;

      case 'c':
      case 'C':
        break;

      case 'x':
      case 'X':
        this.domSignal.once('clear_value', function () {
          this.$text.value = this._format;
          this.$text.select();
        }.bind(this));
        this.domSignal.emit('clear_value');
        break;

      default:
        event.preventDefault();
    }
  } else if (event.key.match(/^[0-9]$/g)) {
    event.preventDefault();
    var dVal = parseInt(event.key);

    if (this._editingData.state === STATE_NEW) {
      switch (token.ident) {
        case 'dd':
        case 'd':
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          this._editingData.state = STATE_EDITED;
          this._editingData.d = dVal;

          if (dVal > 3) {
            this._editNextToken();
          }

          break;

        case 'MM':
        case 'M':
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          this._editingData.state = STATE_EDITED;
          this._editingData.M = dVal;

          if (dVal > 1) {
            this._editNextToken();
          }

          break;

        case 'yyyy':
        case 'y':
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          this._editingData.state = STATE_EDITED;
          this._editingData.state_num = 1;
          break;
      }
    } else {
      switch (token.ident) {
        case 'dd':
        case 'd':
          dVal = (parseInt(token.text.split('').pop()) || 0) * 10 + dVal;
          dVal = Math.max(1, Math.min(31, dVal));
          this._editingData.d = dVal;
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);

          this._editNextToken();

          break;

        case 'MM':
        case 'M':
          dVal = (parseInt(token.text.split('').pop()) || 0) * 10 + dVal;
          dVal = Math.max(1, Math.min(12, dVal));
          this._editingData.M = dVal - 1;
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);

          this._editNextToken();

          break;

        case 'yyyy':
        case 'y':
          dVal = (parseInt(token.text.replace(/^./, '')) || 0) * 10 + dVal;
          this._editingData.state_num++;

          if (this._editingData.state_num >= 4) {
            // dVal = Math.max(1890, Math.min(2089, dVal));
            token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);

            this._editNextToken();
          } else {
            token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          }

          break;
      }
    }
  } else {
    event.preventDefault();
  }
};

DateInput2.eventHandler.mouseUpInput = _DateTimeInput.default.eventHandler.mouseUpInput;
DateInput2.eventHandler.mouseDownInput = _DateTimeInput.default.eventHandler.mouseDownInput;
DateInput2.eventHandler.dblclickInput = _DateTimeInput.default.eventHandler.dblclickInput;
DateInput2.eventHandler.inputBlur = _DateTimeInput.default.eventHandler.inputBlur;

DateInput2.eventHandler.calendarSelect = function (value) {
  this.value = value;
  this.notifyChange();
};

DateInput2.eventHandler.clickCalendarBtn = function () {
  this._attachCalendar();
};

DateInput2.eventHandler.clickOut = function (event) {
  if ((0, _EventEmitter.hitElement)(this.share.$calendar, event)) return;

  this._releaseCalendar();
};

DateInput2.eventHandler.calendarPick = function (event) {
  this._applyValue(event.value);

  this._notifyIfChange(event.originEvent || event);

  this._releaseCalendar();
};

DateInput2.property = {};
DateInput2.property.value = {
  set: function (value) {
    value = this._normalizeValue(value);
    if (!value && this.notNull) value = (0, _datetime.beginOfDay)(new Date());
    this._lastValue = value;

    this._applyValue(value);
  },
  get: function () {
    return this._value;
  }
};
/**
 * not support MMM, MMMM, support number only
 * @type {DateInput2}
 */

DateInput2.property.format = {
  set: function (value) {
    value = value || 'dd/MM/yyyy';
    value = value.replace(/m/g, 'M');
    value = value.replace(/MM([M]+)/, 'MM');

    if (!this._verifyFormat(value)) {
      value = 'dd/MM/yyyy';
      console.error("Invalid date format: " + value);
    }

    this._format = value;
    this.value = this.value; //update
  },
  get: function () {
    return this._format;
  }
};
DateInput2.property.disabled = {
  set: function (value) {
    value = !!value;
    this.$input.disabled = value;
    if (value) this.addClass('as-disabled');else this.removeClass('as-disabled');
    this.$text.disabled = value;
  },
  get: function () {
    return this.$input.disabled;
  }
};
DateInput2.property.calendarLevel = {
  get: function () {
    if (this._format.indexOf('d') >= 0) return 'day';
    if (this._format.indexOf('M') >= 0) return 'month';
    return 'year';
  }
};
DateInput2.property.min = {
  set: function (value) {
    this._min = this._normalizeValue(value) || new Date(1890, 0, 1);
  },
  get: function () {
    return this._min;
  }
};
DateInput2.property.max = {
  set: function (value) {
    this._max = this._normalizeValue(value) || new Date(2090, 0, 1);
  },
  get: function () {
    return this._max;
  }
};
DateInput2.property.notNull = {
  set: function (value) {
    if (value) {
      this.addClass('as-must-not-null');
      if (!this.value) this.value = new Date();
    } else {
      this.removeClass('as-must-not-null');
    }
  },
  get: function () {
    return this.containsClass('as-must-not-null');
  }
};
DateInput2.prototype.share = {
  /***
   * @type {ChromeCalendar}
   */
  $calendar: null,

  /***
   * @type {Follower}
   */
  $follower: null,

  /***
   * @type {DateInput2}
   */
  $holdingInput: null
};

DateInput2.prototype._prepareCalendar = function () {
  if (this.share.$calendar) return;
  this.share.$calendar = _({
    tag: 'chromecalendar',
    class: 'as-date-input-calendar'
  });
  this.share.$follower = _({
    tag: 'follower',
    class: 'as-date-input-follower',
    child: this.share.$calendar
  });
};

DateInput2.prototype._attachCalendar = function () {
  this._prepareCalendar();

  if (this.share.$holdingInput) this.share.$holdingInput._releaseCalendar();
  this.share.$follower.addTo(document.body);
  this.share.$follower.addStyle('visibility', 'hidden');
  this.share.$holdingInput = this;
  this.share.$follower.followTarget = this;
  this.share.$calendar.level = this.calendarLevel;
  this.share.$calendar.min = this._min;
  this.share.$calendar.max = this._max;
  this.share.$calendar.on('pick', this.eventHandler.calendarPick);
  this.share.$calendar.selectedDates = this.value ? [this.value] : [];
  this.share.$calendar.viewDate = this.value ? this.value : new Date(Math.max(this._min.getTime(), Math.min(this._max.getTime(), new Date().getTime())));
  setTimeout(function () {
    document.body.addEventListener('click', this.eventHandler.clickOut);
    this.share.$follower.removeStyle('visibility');
  }.bind(this), 5);
  this.$calendarBtn.off('click', this.eventHandler.clickCalendarBtn);
};

DateInput2.prototype._releaseCalendar = function () {
  if (this.share.$holdingInput !== this) return;
  this.share.$calendar.off('pick', this.eventHandler.calendarPick);
  this.share.$follower.remove();
  document.body.removeEventListener('click', this.eventHandler.clickOut);
  setTimeout(function () {
    this.$calendarBtn.on('click', this.eventHandler.clickCalendarBtn);
  }.bind(this), 5);
  this.share.$holdingInput = null;
};

_ACore.default.install(DateInput2);

var _default = DateInput2;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/Math/random.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/Math/random.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomArbitrary = randomArbitrary;
exports.randomInt = randomInt;
exports.randomPick = randomPick;

/**
 * Returns a random number between min (inclusive) and max (exclusive)
 */
function randomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
}
/**
 * Returns a random integer between min (inclusive) and max (inclusive)
 * Using Math.round() will give you a non-uniform distribution!
 */


function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomPick(arr) {
  var id = randomInt(0, arr.length - 1);
  return arr[id];
}
return module.exports;
};

moduleFactories["node_modules/absol/src/String/stringGenerate.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/String/stringGenerate.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomIdent = randomIdent;
exports.parallelMatch = parallelMatch;
exports.randomWord = randomWord;
exports.randomPhrase = randomPhrase;
exports.randomSentence = randomSentence;
exports.randomParagraph = randomParagraph;
exports.ipsumLoremWord = exports.identCharacters = void 0;

var _random = require("../Math/random");

var identCharacters = function () {
  var chars = 'qwertyuiopasdfghjklzxcvbnm';
  chars = chars + chars.toUpperCase();
  var num = '0123456789';
  var spect = '_';
  return (chars + spect + num).split('');
}();

exports.identCharacters = identCharacters;

function randomIdent(length) {
  if (!(length > 0)) length = 4;
  var factor = identCharacters;
  return [factor[Math.random() * (factor.length - 10) >> 0]].concat(Array(length - 1).fill('').map(function () {
    return factor[Math.random() * factor.length >> 0];
  })).join('');
}

function parallelMatch(a, b) {
  var l = Math.min(a.length, b.length);
  var res = 0;

  for (var i = 0; i < l; ++i) {
    if (a[i] == b[i]) ++res;
  }

  return res;
}

var ipsumLoremWord = ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipiscing', 'elit', 'sed', 'do', 'eiusmod', 'tempor', 'incididunt', 'ut', 'labore', 'et', 'dolore', 'magna', 'aliqua', 'enim', 'ad', 'minim', 'veniam', 'quis', 'nostrud', 'exercitation', 'ullamco', 'laboris', 'nisi', 'aliquip', 'ex', 'ea', 'commodo', 'consequat', 'duis', 'aute', 'irure', 'in', 'reprehenderit', 'voluptate', 'velit', 'esse', 'cillum', 'eu', 'fugiat', 'nulla', 'pariatur', 'excepteur', 'sint', 'occaecat', 'cupidatat', 'non', 'proident', 'sunt', 'culpa', 'qui', 'officia', 'deserunt', 'mollit', 'anim', 'id', 'est', 'laborum', 'perspiciatis', 'unde', 'omnis', 'iste', 'natus', 'error', 'voluptatem', 'accusantium', 'doloremque', 'laudantium', 'totam', 'rem', 'aperiam', 'eaque', 'ipsa', 'quae', 'ab', 'illo', 'inventore', 'veritatis', 'quasi', 'architecto', 'beatae', 'vitae', 'dicta', 'explicabo', 'nemo', 'ipsam', 'quia', 'voluptas', 'aspernatur', 'aut', 'odit', 'fugit', 'consequuntur', 'magni', 'dolores', 'eos', 'ratione', 'sequi', 'nesciunt', 'neque', 'porro', 'quisquam', 'dolorem', 'adipisci', 'numquam', 'eius', 'modi', 'tempora', 'incidunt', 'magnam', 'aliquam', 'quaerat', 'minima', 'nostrum', 'exercitationem', 'ullam', 'corporis', 'suscipit', 'laboriosam', 'aliquid', 'commodi', 'consequatur', 'autem', 'vel', 'eum', 'iure', 'quam', 'nihil', 'molestiae', 'illum', 'quo', 'at', 'vero', 'accusamus', 'iusto', 'odio', 'dignissimos', 'ducimus', 'blanditiis', 'praesentium', 'voluptatum', 'deleniti', 'atque', 'corrupti', 'quos', 'quas', 'molestias', 'excepturi', 'occaecati', 'cupiditate', 'provident', 'similique', 'mollitia', 'animi', 'dolorum', 'fuga', 'harum', 'quidem', 'rerum', 'facilis', 'expedita', 'distinctio', 'nam', 'libero', 'tempore', 'sum', 'soluta', 'nobis', 'eligendi', 'optio', 'cumque', 'impedit', 'minus', 'quod', 'maxime', 'placeat', 'facere', 'possimus', 'assumenda', 'repellendus', 'temporibus', 'quibusdam', 'officiis', 'debitis', 'necessitatibus', 'saepe', 'eveniet', 'voluptates', 'repudiandae', 'recusandae', 'itaque', 'earum', 'hic', 'tenetur', 'a', 'sapiente', 'delectus', 'reiciendis', 'voluptatibus', 'maiores', 'alias', 'perferendis', 'doloribus', 'asperiores', 'repellat', 'integer', 'nec', 'praesent', 'cursus', 'ante', 'dapibus', 'diam', 'sem', 'nibh', 'elementum', 'imperdiet', 'sagittis', 'mauris', 'fusce', 'tellus', 'augue', 'semper', 'porta', 'massa', 'vestibulum', 'lacinia', 'arcu', 'eget', 'class', 'aptent', 'taciti', 'sociosqu', 'litora', 'torquent', 'per', 'conubia', 'nostra', 'inceptos', 'himenaeos', 'curabitur', 'sodales', 'ligula', 'dignissim', 'nunc', 'tortor', 'pellentesque', 'aenean', 'scelerisque', 'maecenas', 'mattis', 'convallis', 'tristique', 'proin', 'egestas', 'porttitor', 'morbi', 'lectus', 'risus', 'iaculis', 'luctus', 'ac', 'turpis', 'aliquet', 'metus', 'ullamcorper', 'tincidunt', 'euismod', 'quisque', 'volutpat', 'condimentum', 'urna', 'facilisi', 'fringilla', 'suspendisse', 'potenti', 'feugiat', 'mi', 'sapien', 'etiam', 'ultrices', 'justo', 'lacus', 'pharetra', 'auctor', 'interdum', 'primis', 'faucibus', 'orci', 'posuere', 'cubilia', 'curae', 'molestie', 'dui', 'blandit', 'congue', 'pede', 'facilisis', 'laoreet', 'donec', 'viverra', 'malesuada', 'pulvinar', 'sollicitudin', 'cras', 'nisl', 'felis', 'venenatis', 'ultricies', 'accumsan', 'pretium', 'fermentum', 'nullam', 'purus', 'mollis', 'vivamus', 'consectetuer'];
exports.ipsumLoremWord = ipsumLoremWord;

function randomWord() {
  var arr = ipsumLoremWord;
  var idx = (0, _random.randomInt)(0, arr.length - 1);
  return arr[idx];
}

function randomPhrase(limitLenght) {
  if (!limitLenght) limitLenght = 50;
  var length = Math.ceil(Math.random() * limitLenght / 7);
  return new Array(length).fill(null).map(randomWord).reduce(function (ac, cr) {
    if (ac.length + cr.length < limitLenght) {
      ac.parts.push(cr);
    }

    return ac;
  }, {
    parts: [],
    length: 0
  }).parts.join(' ');
}

function randomSentence(limitLenght) {
  if (!limitLenght) limitLenght = 300;
  var length = Math.ceil(Math.random() * limitLenght / 70);
  var res = new Array(length).fill(null).map(randomPhrase).reduce(function (ac, cr) {
    if (ac.length + cr.length < limitLenght) {
      ac.parts.push(cr);
    }

    return ac;
  }, {
    parts: [],
    length: 0
  }).parts.join(', ');

  if (Math.random() < 0.03) {
    res = res.replace(/\,/i, ':');
  }

  res = res.replace(/^./, function (x) {
    return x.toUpperCase();
  });
  res += '.';
  return res;
}

function randomParagraph(limitLenght) {
  if (!limitLenght) limitLenght = 1000;
  var length = Math.ceil(Math.random() * limitLenght / 200);
  return new Array(length).fill(null).map(randomSentence).reduce(function (ac, cr) {
    if (ac.length + cr.length < limitLenght) {
      ac.parts.push(cr);
    }

    return ac;
  }, {
    parts: [],
    length: 0
  }).parts.join(' ');
}
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/PositionTracker.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/PositionTracker.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

var _Element = _interopRequireDefault(require("absol/src/HTML5/Element"));


/***
 * @extends {AElement}
 * @constructor
 */
function PositionTracker() {
  this.defineEvent('positionchange');
  this.$trackScrollParents = [];
  this._scrollTrackEventHandler = this.notifyPositionChange.bind(this);
}

PositionTracker.tag = 'PositionTracker'.toLowerCase();
/***
 *
 * @return {AElement}
 */

PositionTracker.render = function () {
  return _('div');
};

PositionTracker.prototype.notifyPositionChange = function (event) {
  this.emit('positionchange', {
    type: 'positionchange',
    originEvent: event
  });
};

PositionTracker.prototype.startTrackPosition = function () {
  if (this.$trackScrollParents.length > 0) this.stopTrackPosition();
  var trackElt = this;

  while (trackElt) {
    if (trackElt.addEventListener) trackElt.addEventListener('scroll', this._scrollTrackEventHandler, false);else trackElt.attachEvent('onscroll', this._scrollTrackEventHandler, false);
    this.$trackScrollParents.push(trackElt);
    trackElt = trackElt.parentElement;
  }

  if (document.addEventListener) {
    document.addEventListener('scroll', this._scrollTrackEventHandler, false);
  } else {
    document.attachEvent('onscroll', this._scrollTrackEventHandler, false);
  }

  this.$trackScrollParents.push(document);
};

PositionTracker.prototype.stopTrackPosition = function () {
  var trackElt;

  for (var i = 0; i < this.$trackScrollParents.length; ++i) {
    trackElt = this.$trackScrollParents[i];
    if (trackElt.removeEventListener) trackElt.removeEventListener('scroll', this._scrollTrackEventHandler, false);else trackElt.dettachEvent('onscroll', this._scrollTrackEventHandler, false);
  }

  this.$trackScrollParents = [];
};

_ACore.default.install(PositionTracker);

var _default = PositionTracker;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/DraggableVStack.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/DraggableVStack.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

require("../css/draggablestack.css");

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _Hanger = _interopRequireDefault(require("./Hanger"));

var _utils = require("./utils");

var _stringGenerate = require("absol/src/String/stringGenerate");

var _Vec = _interopRequireDefault(require("absol/src/Math/Vec2"));

var _PositionTracker = _interopRequireDefault(require("./PositionTracker"));

var _Rectangle = _interopRequireDefault(require("absol/src/Math/Rectangle"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @augments Hanger
 * @augments PositionTracker
 * @constructor
 */

function DraggableVStack() {
  _({
    tag: 'PositionTracker'.toLowerCase(),
    elt: this
  });

  this.$cloneContainer = _('.absol-draggable-stack-clone-container');
  this.on('predrag', this.eventHandler.predrag).on('dragstart', this.eventHandler.dragstart).on('drag', this.eventHandler.drag).on('dragend', this.eventHandler.dragend);
  this._state = 0;
  this.friends = [];
  this.$friends = [];
  this._privateDraggableVStackIdent = (0, _stringGenerate.randomIdent)(35);
  this._dragData = null;
  this.on('positionchange', this.eventHandler.scroll);
}

DraggableVStack.tag = 'DraggableVStack'.toLowerCase();

DraggableVStack.render = function () {
  return _({
    tag: 'hanger',
    extendEvent: ['change', 'orderchange', 'itemleave', 'itementer'],
    class: ['absol-draggable-stack', 'absol-draggable-vstack']
  });
};

DraggableVStack.prototype._updateFriends = function () {
  var dict = {};
  dict[this._privateDraggableVStackIdent] = this;
  this.$friends = this.friends.reduce(function (ac, cr) {
    if (_Dom.default.isDomNode(cr)) {
      if (cr._privateDraggableVStackIdent) {
        ac.result.push(cr);
        ac.dict[cr._privateDraggableVStackIdent] = cr;
      }
    } else if (typeof cr === 'string') {
      $(cr, false, function (elt) {
        if (elt._privateDraggableVStackIdent) {
          if (!ac.dict[elt._privateDraggableVStackIdent]) {
            ac.result.push(elt);
            ac.dict[elt._privateDraggableVStackIdent] = elt;
          }
        }
      });
    }

    return ac;
  }, {
    dict: dict,
    result: []
  }).result;
};

DraggableVStack.prototype._findIndex = function (clientY) {
  var childBounds = Array.prototype.map.call(this.childNodes, function (elt) {
    return elt.getBoundingClientRect();
  });
  var childTops = childBounds.map(function (b) {
    return b.top;
  });
  childTops.push((childBounds[childBounds.length - 1] || this.getBoundingClientRect()).bottom);
  var nearestIdx = 0;
  var nearestVal = 10000000;
  var val;

  for (var i = 0; i < childTops.length; ++i) {
    val = Math.abs(clientY - childTops[i]);

    if (val < nearestVal) {
      nearestVal = val;
      nearestIdx = i;
    }
  }

  return nearestIdx;
};
/***
 *
 * @type {DraggableVStack|{}}
 */


DraggableVStack.eventHandler = {};

DraggableVStack.eventHandler.predrag = function (event) {
  var dragzone = this._findDragzone(event.target);

  if (!dragzone) {
    event.cancel();
  }
};

DraggableVStack.eventHandler.dragstart = function (event) {
  this.startTrackPosition();
  event.preventDefault();

  this._updateFriends();

  this._state = 1;
  this.addClass('as-state-drag');
  this._dragData = {
    mouseStartPos: new _Vec.default(event.clientX, event.clientY),
    elt: this._findDirectChild(event.target),
    rootBound: this.getBoundingClientRect(),
    dest: this
  };
  this._dragData.mouseCurrentPos = this._dragData.mouseStartPos;

  this._updateDestChildrenBound();

  this._dragData.idx = Array.prototype.indexOf.call(this.childNodes, this._dragData.elt);
  this._dragData.eltBound = this._dragData.destChildBounds[this._dragData.idx];
  this._dragData.offsetPos = this._dragData.mouseStartPos.sub(new _Vec.default(this._dragData.eltBound.left, this._dragData.eltBound.top));
  this._dragData.eltRelative = new _Vec.default(this._dragData.eltBound.left, this._dragData.eltBound.top).sub(new _Vec.default(this._dragData.rootBound.left, this._dragData.rootBound.top));
  this.$cloneContainer.addTo(document.body);
  this.$cloneContainer.clearChild().addChild($(this._dragData.elt.cloneNode(true)).addStyle({
    boxSizing: 'border-box',
    width: this._dragData.eltBound.width + 'px',
    height: this._dragData.eltBound.height + 'px'
  }));
  this.$cloneContainer.addStyle({
    left: this._dragData.eltBound.left + 'px',
    top: this._dragData.eltBound.top + 'px'
  });

  this._dragData.elt.addClass('dragging');
};

DraggableVStack.eventHandler.drag = function (event) {
  event.preventDefault();
  this._dragData.mouseCurrentPos = new _Vec.default(event.clientX, event.clientY);

  this._updateHoverDest();

  this._updateDraggingPosition();

  this.eventHandler.dragOverflow(event);
};

DraggableVStack.prototype.getClientY = function () {
  var top = 1000000;
  var bottom = -10000000;
  var child;
  var childBound;

  for (var i = 0; i < this.childNodes.length; ++i) {
    child = this.childNodes[i];
    if (child === this.$cloneContainer) continue;

    if (child.getBoundingClientRect) {
      childBound = child.getBoundingClientRect();
      top = Math.min(top, childBound.top);
      bottom = Math.max(bottom, childBound.bottom);
    }
  }

  return {
    top: top,
    bottom: bottom
  };
};

DraggableVStack.eventHandler.dragOverflow = function (event) {
  var scroller = this;

  while (scroller) {
    var overflowStyle = window.getComputedStyle(scroller)['overflow'];
    if ((overflowStyle === 'auto' || overflowStyle === 'scroll' || scroller.tagName === 'HTML') && scroller.clientHeight < scroller.scrollHeight) break;
    scroller = scroller.parentElement;
  }

  if (!scroller) return;
  var outBound = scroller.getBoundingClientRect();
  var bBound = this.$cloneContainer.getBoundingClientRect();

  var screenSize = _Dom.default.getScreenSize();

  if (scroller.tagName !== "HTML") {
    outBound = {
      top: Math.max(outBound.top, 0),
      bottom: Math.min(outBound.bottom, screenSize.height)
    };
  } else {
    outBound = {
      top: 0,
      bottom: screenSize.height
    };
  }

  var vy = 0;

  if (bBound.top < outBound.top) {
    vy = bBound.top - outBound.top;
  } else if (bBound.bottom > outBound.bottom) {
    vy = bBound.bottom - outBound.bottom;
  }

  var dt = 1 / 30;

  if (vy !== 0) {
    var copyEvent = {
      type: event.type,
      preventDefault: function () {
        /* noop */
      },
      target: event.target
    };
    copyEvent.clientX = event.clientX;
    copyEvent.clientY = event.clientY;
    var thisBT = this;
    setTimeout(function () {
      if (scroller.scrollHeight > scroller.clientHeight) {
        scroller.scrollTop += (0, _utils.absCeil)(vy * dt);
      }

      if (thisBT._state === 1) {
        thisBT.eventHandler.dragOverflow(copyEvent);
      }
    }, dt * 1000);
  }
};

DraggableVStack.eventHandler.scroll = function (event) {
  this._updateDraggingPosition();
};

DraggableVStack.eventHandler.dragend = function (event) {
  this.stopTrackPosition();
  event.preventDefault();

  this._dragData.dest.removeClass('as-state-drag');

  this.$cloneContainer.remove();

  this._dragData.elt.removeClass('dragging');

  this.removeClass('as-state-no-change');
  this._state = 0;
  var beforeElt;

  if (this._dragData.dest === this) {
    if (this._dragData.idx === this._dragData.destIdx || this._dragData.idx + 1 === this._dragData.destIdx) {//todo
    } else {
      if (this._dragData.destIdx === this.childNodes.length) {
        this._dragData.elt.remove();

        this.addChild(this._dragData.elt);
        this.emit('change', {
          type: 'change',
          fromStack: this,
          toStack: this,
          elt: this._dragData.elt,
          sourceIndex: this._dragData.idx,
          destIndex: this.childNodes.length,
          oldIdx: this._dragData.idx,
          newIdx: this.childNodes.length - 1,
          desc: "Move element to end of stack."
        }, this);
        this.emit('orderchange', {
          type: 'orderchange',
          fromStack: this,
          toStack: this,
          elt: this._dragData.elt,
          oldIdx: this._dragData.idx,
          newIdx: this.childNodes.length - 1,
          desc: "Move element to end of stack."
        }, this);
      } else {
        beforeElt = this.childNodes[this._dragData.destIdx];

        this._dragData.elt.remove();

        this.addChildBefore(this._dragData.elt, beforeElt);
        this.emit('change', {
          type: 'change',
          fromStack: this,
          toStack: this,
          elt: this._dragData.elt,
          sourceIndex: this._dragData.idx,
          destIndex: this._dragData.destIdx,
          oldIdx: this._dragData.idx,
          newIdx: this._dragData.destIdx > this._dragData.idx ? this._dragData.destIdx - 1 : this._dragData.destIdx,
          desc: "Move element to before  this.childNodes[" + this._dragData.destIdx + "]"
        }, this);
        this.emit('orderchange', {
          type: 'orderchange',
          fromStack: this,
          toStack: this,
          elt: this._dragData.elt,
          oldIdx: this._dragData.idx,
          newIdx: this._dragData.destIdx > this._dragData.idx ? this._dragData.destIdx - 1 : this._dragData.destIdx,
          desc: "Move element to before  this.childNodes[" + this._dragData.destIdx + "]"
        }, this);
      }
    }
  } else {
    if (this._dragData.destIdx === this._dragData.dest.childNodes.length) {
      this.emit('orderchange', {
        type: 'itemleave',
        fromStack: this,
        toStack: this._dragData.dest,
        oldIdx: this._dragData.idx,
        newIdx: this.childNodes.length - 1,
        desc: "Move element to end of friend stack."
      }, this);

      this._dragData.elt.remove();

      this._dragData.dest.addChild(this._dragData.elt);

      this._dragData.dest.emit('orderchange', {
        type: 'itementer',
        fromStack: this,
        toStack: this._dragData.dest,
        oldIdx: this._dragData.idx,
        newIdx: this.childNodes.length - 1,
        desc: "Move element to end of friend stack."
      }, this._dragData.dest);

      this.emit('change', {
        type: 'change',
        fromStack: this,
        toStack: this._dragData.dest,
        elt: this._dragData.elt,
        sourceIndex: this._dragData.idx,
        destIndex: this.childNodes.length,
        oldIdx: this._dragData.idx,
        newIdx: this.childNodes.length - 1,
        desc: "Move element to end of friend stack."
      });
    } else {
      beforeElt = this._dragData.dest.childNodes[this._dragData.destIdx];

      this._dragData.elt.remove();

      this.emit('itemleave', {
        type: 'itemleave',
        fromStack: this,
        toStack: this._dragData.dest,
        elt: this._dragData.elt,
        oldIdx: this._dragData.idx,
        newIdx: this._dragData.destIdx,
        desc: "Move element to before friend.childNodes[" + this._dragData.destIdx + "]"
      }, this);

      this._dragData.dest.addChildBefore(this._dragData.elt, beforeElt);

      this._dragData.dest.emit('itementer', {
        type: 'itementer',
        fromStack: this,
        toStack: this._dragData.dest,
        elt: this._dragData.elt,
        oldIdx: this._dragData.idx,
        newIdx: this._dragData.destIdx,
        desc: "Move element to before friend.childNodes[" + this._dragData.destIdx + "]"
      }, this._dragData.dest);

      this.emit('change', {
        type: 'change',
        fromStack: this,
        toStack: this._dragData.dest,
        elt: this._dragData.elt,
        sourceIndex: this._dragData.idx,
        destIndex: this._dragData.destIdx,
        oldIdx: this._dragData.idx,
        newIdx: this._dragData.destIdx,
        desc: "Move element to before friend.childNodes[" + this._dragData.destIdx + "]"
      }, this);
    }
  }
};

DraggableVStack.prototype._updateDestChildrenBound = function () {
  var top0 = this._dragData.dest.getBoundingClientRect().top;

  this._dragData.destChildBounds = Array.prototype.map.call(this._dragData.dest.childNodes, function (elt) {
    return elt.getBoundingClientRect();
  });
  this._dragData.destChildTops = this._dragData.destChildBounds.map(function (bound) {
    return bound.top - top0;
  }).concat([(this._dragData.destChildBounds[this._dragData.destChildBounds.length - 1] || this.getBoundingClientRect()).bottom - top0]);
};

DraggableVStack.prototype._updateHoverDest = function () {
  var bound;
  var newDest;
  var friendElt;
  var friendList = this.$friends.concat([this]);
  var top0;

  for (var i = 0; i < friendList.length; ++i) {
    friendElt = friendList[i];
    bound = _Rectangle.default.fromClientRect(friendElt.getBoundingClientRect());

    if (bound.containsPoint(this._dragData.mouseCurrentPos)) {
      top0 = bound.y;
      newDest = friendElt;
      break;
    }
  }

  if (newDest && this._dragData.dest !== newDest) {
    this._dragData.dest.removeClass('as-state-drag');

    this._dragData.dest = newDest;

    this._dragData.dest.addClass('as-state-drag');

    this._dragData.dest.addStyle('--dest-y', 'unset');

    this._updateDestChildrenBound();
  }
};

DraggableVStack.prototype._updateDraggingPosition = function () {
  var bound = this.getBoundingClientRect();

  var clonePos = this._dragData.mouseCurrentPos.sub(this._dragData.offsetPos);

  this.$cloneContainer.addStyle({
    top: clonePos.y + 'px',
    left: bound.left + 'px'
  });
  this._dragData.destIdx = this._dragData.dest._findIndex(clonePos.y + this._dragData.eltBound.height / 2);

  this._dragData.dest.addStyle('--dest-y', this._dragData.destChildTops[this._dragData.destIdx] + 'px');

  if (this._dragData.dest === this) {
    if (this._dragData.idx === this._dragData.destIdx || this._dragData.idx + 1 === this._dragData.destIdx) {
      this.addClass('as-state-no-change');
    } else {
      this.removeClass('as-state-no-change');
    }
  }
};

DraggableVStack.prototype._autoScrollParentIfNeed = function (delta) {
  //todo: choose which element should be scroll
  if (!(delta > 0)) delta = 10000;
  var bound = this.getBoundingClientRect();
  var cloneBound = this.$cloneContainer.getBoundingClientRect();

  var outBound = _Dom.default.traceOutBoundingClientRect(this.$cloneContainer);

  if (outBound.bottom >= cloneBound.bottom && outBound.top <= cloneBound.top) return;
  var scrollables = [];
  var current = this;

  while (current) {
    var oy = window.getComputedStyle(current);
    oy = oy['overflow-y'] || oy['overflowY'];

    if (oy == 'auto' || oy == 'scroll') {
      scrollables.push(current);
    }

    current = current.parentElement;
  }

  scrollables.push(document.body.parentElement);
};

DraggableVStack.prototype._findDragzone = function (elt) {
  var result = null;

  while (elt && elt != this) {
    if (elt.classList && elt.classList.contains('drag-zone')) {
      result = elt;
      break;
    }

    elt = elt.parentNode;
  }

  if (result) {
    elt = result;

    while (elt && elt != this) {
      if (elt.classList && elt.classList.contains('absol-draggable-stack')) {
        result = null;
        break;
      }

      elt = elt.parentNode;
    }
  }

  return result;
};

DraggableVStack.prototype._findDirectChild = function (elt) {
  while (elt && elt != this) {
    if (elt.parentNode == this) return elt;
    elt = elt.parentNode;
  }

  return undefined;
};

DraggableVStack.property = {};
DraggableVStack.property.friends = {
  set: function (value) {
    if (!(value instanceof Array)) value = [value];
    this._friends = value;
  },
  get: function () {
    return this._friends;
  }
};

_ACore.default.install(DraggableVStack);

var _default = DraggableVStack;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/DraggableHStack.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/DraggableHStack.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

require("../css/draggablestack.css");

var _DraggableVStack = _interopRequireDefault(require("./DraggableVStack"));

var _Vec = _interopRequireDefault(require("absol/src/Math/Vec2"));

var _Rectangle = _interopRequireDefault(require("absol/src/Math/Rectangle"));

var _PositionTracker = _interopRequireDefault(require("./PositionTracker"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @augments DraggableVStack
 * @augments PositionTracker
 * @constructor
 */

function DraggableHStack() {
  this._dragData = null;
  this.$cloneContainer = _('.absol-draggable-stack-clone-container');
  this.on('predrag', this.eventHandler.predrag).on('dragstart', this.eventHandler.dragstart).on('drag', this.eventHandler.drag).on('dragend', this.eventHandler.dragend);

  _({
    elt: this,
    tag: _PositionTracker.default
  }).on('positionchange', this._updateDraggingPosition.bind(this));
}

DraggableHStack.tag = "DraggableHStack".toLowerCase();

DraggableHStack.render = function () {
  return _({
    tag: 'hanger',
    extendEvent: 'change',
    class: ['absol-draggable-stack', 'absol-draggable-hstack']
  });
};
/***
 *
 * @param {Rectangle} rect
 * @returns {number}
 * @private
 */


DraggableHStack.prototype._findDropIdx = function (rect) {
  if (!this._dragData) return -1;
  var centerX = rect.x + rect.width / 2;

  var currentBound = _Rectangle.default.fromClientRect(this.getBoundingClientRect());

  var nearestDistance = Math.abs(centerX - currentBound.width); //end of stack

  var cDist;
  var nearestIndex = this._dragData.childBounds.length;
  var childX;

  for (var i = 0; i < this._dragData.childBounds.length; ++i) {
    childX = this._dragData.childBounds[i].x + currentBound.x - this._dragData.bound.x;
    cDist = Math.abs(centerX - childX);

    if (cDist < nearestDistance) {
      nearestDistance = cDist;
      nearestIndex = i;
    }
  }

  return nearestIndex;
};
/***
 *
 * @type {DraggableHStack|{}}
 */


DraggableHStack.eventHandler = {};
DraggableHStack.eventHandler.predrag = _DraggableVStack.default.eventHandler.predrag;

DraggableHStack.eventHandler.dragstart = function (event) {
  this.addClass('as-has-dragging');
  this.startTrackPosition();
  var mousePos = new _Vec.default(event.clientX, event.clientY);

  var elt = this._findDirectChild(event.target);

  var childBounds = Array.prototype.map.call(this.childNodes, function (e) {
    return _Rectangle.default.fromClientRect(e.getBoundingClientRect());
  });
  var eltIdx = Array.prototype.indexOf.call(this.childNodes, elt);
  var eltBound = childBounds[eltIdx];
  var eltMouseOffset = mousePos.sub(new _Vec.default(eltBound.x, eltBound.y));
  this._dragData = {
    mouseStartPos: mousePos,
    mousePos: mousePos,
    bound: _Rectangle.default.fromClientRect(this.getBoundingClientRect()),
    childBounds: childBounds,
    elt: elt,
    eltIdx: eltIdx,
    eltBound: eltBound,
    eltMouseOffset: eltMouseOffset
  };
  this.$cloneContainer.addStyle({
    left: eltBound.x + 'px',
    top: eltBound.y + 'px',
    width: eltBound.width + 'px',
    height: eltBound.height + 'px'
  }).clearChild().addChild($(elt.cloneNode(true))).addTo(document.body);
  elt.addClass('as-dragging');

  this._updateDraggingPosition();
};

DraggableHStack.eventHandler.drag = function (event) {
  event.preventDefault();
  this._dragData.mousePos = new _Vec.default(event.clientX, event.clientY);

  this._updateDraggingPosition();
};

DraggableHStack.eventHandler.dragend = function (event) {
  var thisS = this;
  this.stopTrackPosition();
  this.removeClass('as-has-dragging');

  this._dragData.elt.removeClass('as-dragging');

  if (this._dragData.destIdx == this._dragData.eltIdx || this._dragData.destIdx == this._dragData.eltIdx + 1) {
    this.$cloneContainer.addClass('as-home-going');

    this._updateDraggingPosition();

    setTimeout(function () {
      thisS.$cloneContainer.selfRemove().removeClass('as-home-going');
    }, 100);
  } else {
    if (this._dragData.destIdx === this._dragData.childBounds.length) {
      this._dragData.elt.remove();

      this.addChild(this._dragData.elt);
      this.emit('change', {
        type: 'change',
        elt: this._dragData.elt,
        sourceIndex: this._dragData.eltIdx,
        destIndex: this._dragData.childBounds.length,
        oldIdx: this._dragData.eltIdx,
        newIdx: this._dragData.childBounds.length - 1,
        desc: "Move element to end of stack."
      }, this);
    } else {
      var beforeElt = this.childNodes[this._dragData.destIdx];

      this._dragData.elt.remove();

      this.addChildBefore(this._dragData.elt, beforeElt);
      this.emit('change', {
        type: 'change',
        elt: this._dragData.elt,
        sourceIndex: this._dragData.eltIdx,
        destIndex: this._dragData.destIdx,
        oldIdx: this._dragData.eltIdx,
        newIdx: this._dragData.destIdx > this._dragData.eltIdx ? this._dragData.destIdx - 1 : this._dragData.destIdx,
        desc: "Move element to before  this.childNodes[" + this._dragData.destIdx + "]"
      }, this);
    }

    this.$cloneContainer.selfRemove().removeClass('as-home-going');
  }

  this.removeClass('as-no-change');
};

DraggableHStack.prototype._findDragzone = _DraggableVStack.default.prototype._findDragzone;
DraggableHStack.prototype._findDirectChild = _DraggableVStack.default.prototype._findDirectChild;

DraggableHStack.prototype._updateDraggingPosition = function () {
  var bound = this.getBoundingClientRect();
  var x, y;

  if (this.$cloneContainer.containsClass('as-home-going')) {
    x = this._dragData.eltBound.x - this._dragData.bound.x + bound.left;
    y = this._dragData.eltBound.y - this._dragData.bound.y + bound.top;
  } else {
    y = bound.top + (this._dragData.eltBound.y - this._dragData.bound.y);

    var newPos = this._dragData.mousePos.sub(this._dragData.eltMouseOffset);

    x = newPos.x;
  }

  this.$cloneContainer.addStyle({
    left: x + 'px',
    top: y + 'px'
  });

  var cBound = this._dragData.eltBound.clone();

  cBound.x = x;
  cBound.y = y;

  var destIdx = this._findDropIdx(cBound);

  this._dragData.destIdx = destIdx;
  var destX;

  if (destIdx >= this._dragData.childBounds.length) {
    var lastRect = this._dragData.childBounds[this._dragData.childBounds.length - 1];
    destX = lastRect.x + lastRect.width - this._dragData.bound.x;
  } else {
    destX = this._dragData.childBounds[destIdx].x - this._dragData.bound.x;
  }

  this.addStyle('--dest-x', destX + 'px');

  if (destIdx == this._dragData.eltIdx || destIdx == this._dragData.eltIdx + 1) {
    this.addClass('as-no-change');
  } else {
    this.removeClass('as-no-change');
  }
};

_ACore.default.install(DraggableHStack);

var _default = DraggableHStack;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/DropPanel.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/DropPanel.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/droppanel.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _ExpTree = require("./ExpTree");


var _ = _ACore.default._;
var $ = _ACore.default.$;
/**
 * @extends AElement
 * @constructor
 */

function DropPanel() {
  var thisDP = this;
  /***
   *
   * @type {ExpGroup}
   */

  this.$body = $('.absol-drop-panel-body', this);
  this.$head = $('.absol-drop-panel-head', this).on('click', thisDP.eventHandler.clickHead);
  this.$name = $('.absol-drop-panel-name', thisDP);

  _OOP.default.drillProperty(this, this.$name, 'name', 'innerHTML');

  return thisDP;
}

DropPanel.tag = 'DropPanel'.toLowerCase();

DropPanel.render = function () {
  return _({
    class: 'absol-drop-panel',
    extendEvent: ['toggle'],
    child: [{
      class: 'absol-drop-panel-head',
      child: ['toggler-ico', {
        tag: 'span',
        class: "absol-drop-panel-name"
      }]
    }, {
      tag: 'expgroup',
      class: ['absol-drop-panel-body', 'absol-bscroller']
    }]
  });
};

DropPanel.eventHandler = {};

DropPanel.eventHandler.clickHead = function (event) {
  if (!this._childOfButton(event.target)) {
    var event = {
      target: this,
      isShowed: this.show,
      preventDefault: function () {
        this.prevented = true;
      }
    };
    this.emit('toggle', event, this);

    if (!event.prevented) {
      this.toggle();
    }
  }
};

['findChildBefore', 'findChildAfter', 'removeChild', 'clearChild', 'addChild'].forEach(function (key) {
  DropPanel.prototype[key] = function () {
    this.$body[key].apply(this.$body, arguments);
  };
});

DropPanel.prototype._childOfButton = function (elt) {
  while (elt && elt != this) {
    if (elt.tagName == "BUTTON") {
      return true;
    }

    elt = elt.parentElement;
  }

  return false;
};

DropPanel.prototype.toggle = function () {
  this.show = !this.show;
};

DropPanel.property = {};
DropPanel.property.show = {
  set: function (value) {
    if (value) {
      var maxHeight = parseFloat(this.getComputedStyleValue('max-height').replace('px', ''));
      var headBound = this.$head.getBoundingClientRect();

      if (maxHeight != 'none' && maxHeight != 'auto') {
        this.$body.addStyle('max-height', maxHeight - headBound.height + 'px');
      }

      this.$body.addStyle('height', this.$body.scrollHeight + 'px');
      setTimeout(function () {
        this.$body.removeStyle('height');
        window.dispatchEvent(new Event('resize'));
      }.bind(this), 200);
      this.addClass('show');
    } else {
      this.$body.addStyle('height', this.$body.scrollHeight + 'px');
      setTimeout(function () {
        this.$body.addStyle('height', '0');
      }.bind(this), 0);
      setTimeout(function () {
        this.$body.removeStyle('height');
        window.dispatchEvent(new Event('resize'));
      }.bind(this), 200);
      this.removeClass('show');
    }
  },
  get: function () {
    return this.containsClass('show');
  }
};

_ACore.default.install(DropPanel);

var _default = DropPanel;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/DropPanelStack.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/DropPanelStack.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/droppanel.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/**
 * @extends AElement
 * @constructor
 */

function DropPanelStack() {
  var res = this;
  this.$attachHook = _('attachhook').on('error', function () {
    _Dom.default.addToResizeSystem(this);

    this.updateSize = res.updateSize.bind(res);
  });
  this.sync = new Promise(function (rs) {
    res.$attachHook.once('error', rs);
  });
}

DropPanelStack.tag = 'DropPanelStack'.toLowerCase();

DropPanelStack.render = function () {
  return _({
    class: 'absol-drop-panel-stack',
    child: ['attachhook']
  });
};

DropPanelStack.prototype.updateSize = function () {};

DropPanelStack.prototype.getFreeHeight = function () {
  var childNodes = this.childNodes;
  var sumHeight = 0;
  var bound = this.getBoundingClientRect();
  var childBound;

  for (var i = 0; i < childNodes.length; ++i) {
    var child = childNodes[i];

    if (child.containsClass && child.containsClass('absol-drop-panel')) {
      childBound = child.getBoundingClientRect();
      sumHeight += childBound.height;
    }
  }

  return bound.height - sumHeight;
};

DropPanelStack.prototype.addChild = function (child) {
  var self = this;

  if (child.containsClass('absol-drop-panel')) {
    //remove last event listener off other parent
    if (child.__drop_panel_toggle_listener__) {
      child.off('toggle', child.__drop_panel_toggle_listener__);
    }

    child.__drop_panel_toggle_listener__ = function (event) {
      event.preventDefault();
      self.sync = self.sync.then(function () {
        if (event.isShowed) {
          setTimeout(function () {
            child.removeStyle('max-height');
          }, 200);
          child.toggle();
        } else {
          var headBound = child.$head.getBoundingClientRect();
          var vailableHeight = self.getFreeHeight();

          if (vailableHeight > 3) {
            child.addStyle('max-height', self.getFreeHeight() + headBound.height + 'px');
            child.toggle();
          }
        }

        return new Promise(function (rs) {
          setTimeout(rs, 200);
        });
      });
    };

    child.on('toggle', child.__drop_panel_toggle_listener__);
    this.super(child);
  } else {
    throw new Error('Child element must be a DropPanel');
  }
};

_ACore.default.install('droppanelstack', DropPanelStack);

var _default = DropPanelStack;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/DropZone.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/DropZone.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/dropzone.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function DropZone() {
  this.defineEvent(['fileenter', 'fileleave', 'filedrop']);
  this.addClass('as-drop-zone');
  this.on('dragover', this.eventHandler.dragZoneFileOver).on('drop', this.eventHandler.dropZoneFileDrop);
  this._fileOverTimeout = -1;
}

DropZone.tag = 'dropzone';

DropZone.render = function () {
  return _('div');
};

DropZone.eventHandler = {};

DropZone.eventHandler.dragZoneFileOver = function (event) {
  event.preventDefault();

  if (this._fileOverTimeout > 0) {
    clearTimeout(this._fileOverTimeout);
  } else {
    this.addClass('as-drag-over');
    this.emit('fileenter', event, this);
  }

  this._fileOverTimeout = setTimeout(this.eventHandler.dragZoneFileOverEnd, 100);
};
/***
 *
 * @param {DragEvent} event
 */


DropZone.eventHandler.dropZoneFileDrop = function (event) {
  if (this._fileOverTimeout > 0) {
    clearTimeout(this._fileOverTimeout);
    this._fileOverTimeout = -1;
  }

  event.preventDefault();
  this.removeClass('as-drag-over');
  event._files = null;
  Object.defineProperty(event, 'files', {
    get: function () {
      if (this._files) return this._files;
      var files = [];
      var file;

      if (event.dataTransfer.items) {
        for (var i = 0; i < event.dataTransfer.items.length; i++) {
          if (event.dataTransfer.items[i].kind === 'file') {
            file = event.dataTransfer.items[i].getAsFile();
            files.push(file);
          }
        }
      } else {
        // Use DataTransfer interface to access the file(s)
        for (var i = 0; i < event.dataTransfer.files.length; i++) {
          files.push(event.dataTransfer.files[i]);
        }
      }

      this._files = files;
      return this._files;
    }
  });
  this.emit('filedrop', event, this);
};

DropZone.eventHandler.dragZoneFileOverEnd = function () {
  this._fileOverTimeout = -1;
  this.removeClass('as-drag-over');
  this.emit('fileleave', {
    type: 'fileleave'
  }, this);
};

_ACore.default.install(DropZone);

var _default = DropZone;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/EditableText.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/EditableText.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/editabletext.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function EditableText() {
  var thisET = this;
  this.$span = $('span', this);
  this.$text = document.createTextNode('');
  this.$span.addChild(this.$text);
  this.$higne = $('.absol-editabe-text-higne', this);
  this.$input = $('input', this);

  _OOP.default.drillProperty(this, this.$input, ['selectionStart', 'selectionEnd']);

  this.sync = new Promise(function (rs) {
    _('attachhook').addTo(thisET).once('error', rs);
  });
  this.$input.on('keydown', this.eventHandler.inputKeyDown, true);
  this.$input.on('change', this.eventHandler.inputChange);
  this.$input.on('blur', this.eventHandler.inputBlur);
}

;
EditableText.tag = 'EditableText'.toLowerCase();

EditableText.render = function () {
  return _({
    class: 'absol-editabe-text',
    extendEvent: ['blur', 'focus', 'change', 'modify'],
    child: [{
      class: 'absol-editabe-text-higne',
      child: '<input type="text">'
    }, 'span']
  });
};

EditableText.prototype.focus = function () {
  this.$input.focus();
};

EditableText.prototype.blur = function () {
  this.$input.blur();
};

EditableText.prototype.select = function () {
  this.$input.select();
};

EditableText.prototype.edit = function (flag, select) {
  this.editing = !!flag;
  this.sync = this.sync.then(function () {
    if (flag) {
      this.focus();
      if (select) this.select();
    } else this.blur();
  }.bind(this));
  return this.sync;
};

EditableText.prototype._update = function () {
  this.sync = this.sync.then(function () {
    return new Promise(function (rs) {
      // setTimeout(function () {
      var bound = this.getBoundingClientRect();
      var higneBound = this.$higne.getBoundingClientRect();
      var fsize = this.getFontSize();
      this.$input.addStyle('width', bound.width + 4 + fsize * 0 + 'px');
      this.$input.addStyle('height', bound.height + 4 + 'px');
      this.$input.addStyle('left', bound.left - higneBound.left - 2 + 'px');
      this.$input.addStyle('top', bound.top - higneBound.top + 'px');
      rs();
    }.bind(this));
  }.bind(this));
};

EditableText.property = {};
EditableText.property.text = {
  set: function (value) {
    this.$text.textContent = value;
    this.$input.value = value;
  },
  get: function () {
    return this.$text.textContent;
  }
};
EditableText.property.editing = {
  set: function (value) {
    if (this._editting === value) return;
    this._editting = !!value;

    if (value) {
      this.$input.value = this.text;

      this._update();

      this.sync = this.sync.then(function () {
        this.addClass('editing');
        this.$input.value = this.text;
        this.$input.addStyle('font', this.$span.getComputedStyleValue('font'));
        this.$input.addStyle('font-style', this.$span.getComputedStyleValue('font-style'));
        this.$input.addStyle('color', this.$span.getComputedStyleValue('color'));
      }.bind(this));
    } else {
      this.removeClass('editing');
    }
  },
  get: function () {
    return !!this._editting;
  }
};
EditableText.eventHandler = {};

EditableText.eventHandler.inputKeyDown = function (event) {
  requestAnimationFrame(function () {
    this.text = this.$input.value;

    this._update();

    event.text = this.text;
    this.emit('modify', event);
  }.bind(this));
};

EditableText.eventHandler.inputChange = function (event) {
  this.editing = false;
  this.emit('change', event);
};

EditableText.eventHandler.inputBlur = function (event) {
  this.editing = false;
  this.emit('blur', event);
};

_ACore.default.install(EditableText);

var _default = EditableText;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Sprite.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Sprite.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.STATE_TO_STRING = exports.ERROR = exports.STOP = exports.PAUSE = exports.RUNNING = exports.START = exports.READY = exports.NOT_READY = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
var NOT_READY = 0;
exports.NOT_READY = NOT_READY;
var READY = 1;
exports.READY = READY;
var START = 2;
exports.START = START;
var RUNNING = 3;
exports.RUNNING = RUNNING;
var PAUSE = 4;
exports.PAUSE = PAUSE;
var STOP = 5;
exports.STOP = STOP;
var ERROR = 6;
exports.ERROR = ERROR;
var STATE_TO_STRING = ['NOT_READY', 'READY', 'START', 'RUNNING', 'PAUSE', 'STOP', 'ERROR'];
/**
 * @augments AElement
 * @augments HTMLCanvasElement
 * @constructor
 */

exports.STATE_TO_STRING = STATE_TO_STRING;

function Sprite() {
  this.loadTextureTimeout = 5000;
  this._textureLoaded = false;
  this._state = NOT_READY;
  this.defineEvent(['ready', 'srcerror', 'play', 'resume', 'pause', 'stop', 'reset', 'end', 'frame']);
  this._length = 60;
  this._lastDrawFrame = -1;
  this._frameIndex = 0;
  this._timeout = -1;
  this.ctx = this.getContext('2d');
  this._fps = 10;
  this._lastDrawMilis = 0;
  this._overTime = 0;
  this.draw = this.draw.bind(this);
  this.texture = null;
  this._frames = {
    type: 'grid',
    col: 1,
    row: 1
  };
  this._loop = false;
}

Sprite.cache = {};

Sprite.prototype.draw = function () {
  //todo
  var now = new Date().getTime();
  var dt = this._overTime + now - this._lastDrawMilis;
  var di = Math.floor(dt / 1000 * this._fps);
  var frameIndex = this._frameIndex + di;

  if (this._loop) {
    frameIndex = frameIndex % this._length;
  } else {
    frameIndex = Math.min(this._length - 1, frameIndex);
  }

  if (!isNaN(this._frameIndex) && frameIndex != this._frameIndex) {
    this.drawFrame(this._frameIndex);
  }

  this._overTime = dt - di * 1000 / this._fps;
  var nextTime = now + 1000 / this._fps - this._overTime - new Date().getTime();
  this._lastDrawMilis = now;
  this._frameIndex = frameIndex;
  this._timeout = -1;

  if (this._loop || frameIndex + 1 < this._length) {
    if (this._state == RUNNING) this._timeout = setTimeout(this.draw, nextTime);
  } else this.stop();
};

Sprite.prototype.drawFrame = function (index) {
  if (this._lastDrawFrame == index) return;
  this._lastDrawFrame = index;
  this.ctx.clearRect(0, 0, this.width, this.height);

  if (this._frames.type == 'grid') {
    var imgWidth = this.texture.naturalWidth;
    var imgHeight = this.texture.naturalHeight;
    var sHeight = imgHeight / this._frames.row;
    var sWidth = imgWidth / this._frames.col;
    var sx = index % this._frames.col * sWidth;
    var sy = Math.floor(index / this._frames.col) * sHeight;
    this.ctx.drawImage(this.texture, sx, sy, sWidth, sHeight, 0, 0, this.width, this.height);
  } else {}

  this.emit('frame', {
    name: 'frame',
    target: this,
    frameIndex: index
  }, this);
};

Sprite.prototype.stop = function () {
  this.pause();
  if (this._state != PAUSE) return this;
  this._state = STOP;
  this.emit('stop', {
    name: 'stop',
    target: this
  }, this);
  return this;
};

Sprite.prototype.pause = function () {
  if (this._state != RUNNING) return this;
  this._state = PAUSE;

  if (this._timeout > 0) {
    clearTimeout(this._timeout);
    this._timeout = -1;
  }

  var now = new Date().getTime();
  this._overTime += now - this._lastDrawMilis;
  this.emit('pause', {
    name: 'pause',
    target: this
  }, this);
};

Sprite.prototype.resume = function () {
  if (this._state != START && this._state != PAUSE) return this;
  if (this._state == RUNNING) return this;
  this._state = RUNNING;
  var now = new Date().getTime();
  this._lastDrawMilis = now;
  this.draw();
  this.emit('resume', {
    name: 'pause',
    target: this
  }, this);
};

Sprite.prototype.reset = function () {
  this._frameIndex = 0;
  this._overTime = 0;
};

Sprite.prototype.play = function () {
  if (this._state == ERROR) return this;
  if (this._state == RUNNING) return this;

  if (this._state == READY || this._state == STOP) {
    this.reset();
  }

  this._state = START;
  this.emit('play', {
    name: 'start',
    target: this
  }, this);
  this.resume();
  return this;
};

Sprite.prototype.afterReady = function () {
  var thisSprite = this;
  if (this._state != NOT_READY && this._state != ERROR) return Promise.resolve();else return new Promise(function (rs, rj) {
    thisSprite.once('ready', rs);
    thisSprite.once('srcerror', rj);
  });
};

Sprite.tag = 'sprite';

Sprite.render = function () {
  return _('canvas.as-sprite');
};

Sprite.property = {};
Sprite.property.frames = {
  set: function (value) {
    this.stop();
    this._lastDrawFrame = -1;

    if (value && value.type == 'grid') {
      this._length = value.col * value.row;
    }

    this._frames = value;

    if (this._textureLoaded && this._frames && this._state == NOT_READY) {
      //todo: verify frame
      this._state = READY;
      this.emit('ready', {
        target: this,
        name: 'ready'
      }, this);
    }
  },
  get: function () {
    return this._frames;
  }
};
Sprite.property.frameIndex = {
  set: function (value) {
    value = value || 0;
    if (value < 0) value = this._length - 1;

    if (this._loop) {
      this._frameIndex = value % this._length;
      this._overTime = 0;
    } else {
      this._frameIndex = Math.max(this._length - 1, value);
      this._overTime = 0;
    }

    this.drawFrame(this._frameIndex);
  },
  get: function () {
    return this._frameIndex;
  }
};
Sprite.property.src = {
  set: function (value) {
    this.stop();
    this._lastDrawFrame = -1; //did not draw any thing 

    value = value || [];
    var lastSrc = this._src;
    this._src = value || null;
    if (lastSrc == this._src) return;
    if (!value) this.texture = null;else {
      var cImage;

      if (!Sprite.cache[this._src]) {
        cImage = new Image();
        Sprite.cache[this._src] = cImage;
        cImage.src = this._src;
      } else {
        cImage = Sprite.cache[this._src];
      }

      this.texture = cImage;
      this._state = NOT_READY;
      var thisSprite = this;
      this._textureLoaded = false;

      _Dom.default.waitImageLoaded(this.texture, this.loadTextureTimeout).then(function (rs) {
        if (thisSprite.texture == cImage) {
          thisSprite._textureLoaded = true;

          if (thisSprite._frames) {
            thisSprite._lastDrawFrame = -1;
            thisSprite._state = READY;
            thisSprite.emit('ready', {
              target: thisSprite,
              name: 'ready'
            }, thisSprite);
          }
        }
      }, function () {
        if (thisSprite.texture == cImage) {
          thisSprite._state = ERROR;
          thisSprite.emit('srcerror', {
            target: thisSprite,
            name: 'srcerror'
          }, thisSprite);
        }
      });
    }
  },
  get: function () {
    return this._src;
  }
};
Sprite.property.state = {
  get: function () {
    return STATE_TO_STRING[this._state];
  }
};
Sprite.property.length = {
  get: function () {
    return this._length;
  }
};
Sprite.property.fps = {
  set: function (value) {
    value = Math.max(value || 0, 0);
    this._fps = value;

    if (this._state == RUNNING) {
      clearTimeout(this._timeout);
      this._timeout = -1;
      var now = new Date().getTime();
      this._overTime += now - this._lastDrawMilis;
      this._overTime = Math.min(1000 / this._fps, this._overTime);
      this.draw();
    }
  },
  get: function () {
    return this._fps;
  }
};
Sprite.property.loop = {
  set: function (value) {
    value = !!value;
    this._loop = value;
  },
  get: function () {
    return this._loop;
  }
};

_ACore.default.install(Sprite);

var _default = Sprite;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/EmojiAnims.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/EmojiAnims.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var EmojiAnims = [["(heart)", "heart.png", "Heart"], ["(cool)", "cool.png", "Cool"], ["(hearteyes)", "hearteyes.png", "Heart eyes"], ["(stareyes)", "stareyes.png", "Star eyes"], ["(like)", "like.png", "Like"], ["(unamused)", "unamused.png", "Unamused"], ["(cwl)", "cwl.png", "Crying with laughter"], ["(xd)", "xd.png", "XD smiley"], [":)", "smile.png", "Smile"], [":(", "sad.png", "Sad"], [":D", "laugh.png", "Laugh"], [":O", "surprised.png", "Surprised"], [";)", "wink.png", "Wink"], [";(", "cry.png", "Crying"], ["(shivering)", "shivering.png", "Cold shivering"], ["(:|", "sweat.png", "Sweating"], [":|", "speechless.png", "Speechless"], [":P", "tongueout.png", "Cheeky"], [":$", "blush.png", "Blushing"], ["(inlove)", "inlove.png", "In love"], ["(kiss)", "kiss.png", "Kiss"], [":^)", "wonder.png", "Wondering"], ["|-)", "sleepy.png", "Sleepy"], ["|-(", "dull.png", "Dull"], ["(yawn)", "yawn.png", "Yawn"], ["(puke)", "puke.png", "Vomiting"], ["(doh)", "doh.png", "Doh!"], ["(angry)", "angry.png", "Angry"], ["(wasntme)", "wasntme.png", "It wasn't me!"], ["(worry)", "worry.png", "Worried"], ["(mm)", "mmm.png", "Mmmmm…"], ["(nerd)", "nerdy.png", "Nerdy"], ["(rainbowsmile)", "rainbowsmile.png", "Rainbow smile"], [":x", "lipssealed.png", "My lips are sealed"], ["(devil)", "devil.png", "Devil"], ["(angel)", "angel.png", "Angel"], ["(envy)", "envy.png", "Envy"], ["(makeup)", "makeup.png", "Make-up"], ["(think)", "think.png", "Thinking"], ["(rofl)", "rofl.png", "Rolling on the floor laughing"], ["(happy)", "happy.png", "Happy"], ["(smirk)", "smirk.png", "Smirking"], ["(nod)", "nod.png", "Nodding"], ["(shake)", "shake.png", "Shake"], ["(waiting)", "waiting.png", "Waiting"], ["(emo)", "emo.png", "Emo"], ["(donttalk)", "donttalktome.png", "Don't talk to me"], ["(idea)", "idea.png", "Idea"], ["(talk)", "talk.png", "Talking"], ["(swear)", "swear.png", "Swearing"], ["]:)", "evilgrin.png", "Evil grin"], ["(headbang)", "headbang.png", "Banging head on wall"], ["(learn)", "learn.png", "Global Learning"], ["(headphones)", "headphones.png", "Listening to headphones"], ["(morningafter)", "hungover.png", "Morning after party"], ["(selfie)", "selfie.png", "Selfie"], ["(shock)", "shock.png", "Spoiler alert"], ["(llsshock)", "llsshock.png", "Spoiler alert"], ["(ttm)", "ttm.png", "Talking too much"], ["(dream)", "dream.png", "Dreaming"], ["(ill)", "ill.png", "Ill"], ["(tired)", "tired.png", "Tired"], ["(party)", "party.png", "Party"], ["(bandit)", "bandit.png", "Bandit"], ["(tauri)", "tauri.png", "Bald man with glasses"], ["(nazar)", "nazar.png", "Blessing"], ["(movember)", "movember.png", "Movember"], ["(mysteryskype)", "mysteryskype.png", "Mystery Skype"], ["(dotdfemale)", "dotdfemale.png", "Day of the dead"], ["(dotdmale)", "dotdmale.png", "Day of the dead"], ["(selfiediwali)", "selfiediwali.png", "Selfie Diwali"], ["(diwaliselfie)", "diwaliselfie.png", "Diwali selfie"], ["(steveaoki)", "steveaoki.png", "Steve Aoki"], ["(aokijump)", "aokijump.png", "Aoki jump"], ["(cakethrow)", "cakethrow.png", "Cake throw"], ["(kolony)", "kolony.png", "Kolony"], ["(joy)", "joy.png", "Joy"], ["(anger)", "anger.png", "Anger"], ["(sadness)", "sadness.png", "Sadness"], ["(disgust)", "disgust.png", "Disgust"], ["(fear)", "fear.png", "Fear"], ["(hestonfacepalm)", "hestonfacepalm.png", "Heston facepalm"], ["(heston)", "heston.png", "Heston Blumenthal"], ["(stormtrooper)", "stormtrooper.png", "Storm trooper"], ["(kyloren)", "kyloren.png", "Kylo Ren"], ["(captainphasma)", "captainphasma.png", "Captain Phasma"], ["(malthe)", "malthe.png", "Smiling man with glasses"], ["(ladyvamp)", "ladyvampire.png", "Lady vampire"], ["(vampire)", "vampire.png", "Vampire"], ["(ghost)", "ghost.png", "Ghost"], ["(skull)", "skull.png", "Skull"], ["(pumpkin)", "pumpkin.png", "Pumpkin"], ["(santa)", "santa.png", "Santa"], ["(xmascwl)", "xmascwl.png", "Xmas crying with laughter"], ["(festiveparty)", "festiveparty.png", "Festive party"], ["(holidayspirit)", "holidayspirit.png", "Holiday spirit"], ["(rudolfsurprise)", "rudolfsurprise.png", "Surprised Rudolf"], ["(rudolfidea)", "rudolfidea.png", "Rudolf idea"], ["(wtf)", "wtf.png", "WTF…"], ["(smoking)", "smoke.png", "Smoking"], ["(drunk)", "drunk.png", "Drunk"], ["(finger)", "finger.png", "Finger"], ["(oliver)", "oliver.png", "Man saying come on"], ["(xmassarcastic)", "xmassarcastic.png", "Xmas sarcastic"], ["(xmascry)", "xmascry.png", "Xmas cry"], ["(wave)", "hi.png", "Hi"], ["(highfive)", "highfive.png", "High five"], ["(clap)", "clap.png", "Clapping"], ["(sarcastic)", "sarcastic.png", "Sarcastic"], ["(chuckle)", "giggle.png", "Giggle"], ["(facepalm)", "facepalm.png", "Facepalm"], ["(rock)", "rock.png", "Rock"], ["(yn)", "fingerscrossed.png", "Fingers crossed"], ["(listening)", "listening.png", "Listening"], ["(wait)", "wait.png", "Wait"], ["(whew)", "whew.png", "Relieved"], ["(tmi)", "tmi.png", "Too much information"], ["(call)", "call.png", "Call"], ["(punch)", "punch.png", "Punch"], ["(talktothehand)", "talktothehand.png", "Talk to the hand"], ["(whistle)", "whistle.png", "Whistle"], ["(slap)", "slap.png", "Slap"], ["(lalala)", "lalala.png", "Lalala"], ["(y)", "yes.png", "Yes"], ["(n)", "no.png", "No"], ["(handshake)", "handshake.png", "Handshake"], ["(fistbump)", "fistbump.png", "Fist bump"], ["(poke)", "poke.png", "Poke"], ["(celebrate)", "handsinair.png", "Hands celebrating"], ["(hearthands)", "hearthands.png", "Heart hands"], ["(victory)", "victory.png", "Victory sign"], ["(noworries)", "noworries.png", "No worries"], ["(ok)", "ok.png", "OK"], ["(pray)", "praying.png", "Praying"], ["(flex)", "muscle.png", "Muscle"], ["(ek)", "naturescall.png", "Nature's call"], ["(woty)", "woty.png", "Woman of the year"], ["(glassceiling)", "glassceiling.png", "Glass ceiling"], ["(deadyes)", "deadyes.png", "Dead yes"], ["(xmasyes)", "xmasyes.png", "Xmas yes"], ["(dropthemic)", "dropthemic.png", "Drop the mic"]];
var _default = EmojiAnims;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/EmojiPicker.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/EmojiPicker.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/emojipicker.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _EmojiAnims = _interopRequireDefault(require("./EmojiAnims"));

var _Sprite = _interopRequireDefault(require("./Sprite"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function EmojiPicker() {
  var thisPicker = this;
  this._aliveTimeout = 90;
  this._assetRoot = this.attr('data-asset-root');
  /***
   *
   * @type {Sprite}
   */

  this.$previewAnim = $('sprite.as-emoji-picker-preview-anim', this).on('ready', this.eventHandler.previewAnimReady).on('frame', this.eventHandler.previewAnimFrame);
  this.$previewAnim.loop = true;
  this.$previewAnim.src = this._assetRoot + '/anim/x120/' + _EmojiAnims.default[0][1];
  this.$previewAnim.fps = 30;
  this.$desc = $('.as-emoji-picker-preview-desc', this);
  this.$shortcut = $('.as-emoji-picker-preview-shortcut', this);
  this.$desc.clearChild().addChild(_({
    text: _EmojiAnims.default[0][2]
  }));
  this.$shortcut.clearChild().addChild(_({
    text: _EmojiAnims.default[0][0]
  }));
  this.$list = $('.as-emoji-picker-list', this);
  this.$items = _EmojiAnims.default.reduce(function (ac, it) {
    var itemElt = _({
      tag: 'img',
      class: 'as-emoji-picker-item',
      props: {
        src: thisPicker._assetRoot + '/static/x20/' + it[1]
      }
    }).addTo(thisPicker.$list);

    itemElt.on('mouseenter', thisPicker.eventHandler.mouseenterItem.bind(thisPicker, it, itemElt));
    itemElt.on('click', thisPicker.eventHandler.clickItem.bind(thisPicker, it));
    ac[it[0]] = itemElt;
    return ac;
  }, {});
  this.$attachook = _('attachhook').addTo(this).on('error', this.eventHandler.attach);
}

EmojiPicker.assetRoot = function () {
  if (location.hostname.match(/^.+\.absol.cf$/)) return 'https://absol.cf/emoji';
  return '/emoji';
}();

EmojiPicker.tag = 'EmojiPicker'.toLowerCase();

EmojiPicker.render = function (data) {
  data = data || {};
  data.assetRoot = data.assetRoot || EmojiPicker.assetRoot;
  return _({
    class: 'as-emoji-picker',
    extendEvent: 'pick',
    attr: {
      'data-asset-root': data.assetRoot
    },
    child: [{
      class: 'as-emoji-picker-preview',
      child: [{
        class: '.as-emoji-picker-preview-anim-ctn',
        child: 'sprite.as-emoji-picker-preview-anim'
      }, '.as-emoji-picker-preview-desc', '.as-emoji-picker-preview-shortcut']
    }, {
      tag: 'bscroller',
      class: 'as-emoji-picker-list'
    }]
  });
};
/**
 * @type {EmojiPicker}
 */


EmojiPicker.eventHandler = {};

EmojiPicker.eventHandler.attach = function () {
  this._aliveTimeout = 90;
  setTimeout(this.$previewAnim.play.bind(this.$previewAnim), 1);
};

EmojiPicker.eventHandler.previewAnimReady = function () {
  this.$previewAnim.frames = {
    type: 'grid',
    col: 1,
    row: this.$previewAnim.texture.naturalHeight / this.$previewAnim.texture.naturalWidth
  };
  this.$previewAnim.play();
};

EmojiPicker.eventHandler.previewAnimFrame = function () {
  if (this._aliveTimeout == 0) {
    var bound = this.getBoundingClientRect();

    if (bound.width == 0) {
      this.$previewAnim.stop();
    } else {
      this._aliveTimeout = 90;
    }
  }

  this._aliveTimeout--;
};

EmojiPicker.eventHandler.mouseenterItem = function (itemData, itemElt, event) {
  if (this.$lastHoverItem == itemElt) return;
  this.$lastHoverItem = itemElt;
  this.$previewAnim.src = this._assetRoot + '/anim/x120/' + itemData[1];
  this.$desc.clearChild().addChild(_({
    text: itemData[2]
  }));
  this.$shortcut.clearChild().addChild(_({
    text: itemData[0]
  }));
};

EmojiPicker.eventHandler.clickItem = function (itemData, event) {
  this.emit('pick', {
    name: 'pick',
    key: itemData[0],
    target: this
  }, this);
};

_ACore.default.install(EmojiPicker);

var _default = EmojiPicker;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Tooltip.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Tooltip.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateTooltipPosition = updateTooltipPosition;
exports.default = void 0;

require("../css/tooltip.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireWildcard(require("absol/src/HTML5/Dom"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));




var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function ToolTip() {
  this.$content = $('.absol-tooltip-content', this);
  this.$arrow = $('.absol-tooltip-arrow', this);
}

ToolTip.tag = 'ToolTip'.toLowerCase();

ToolTip.render = function () {
  return _({
    class: 'absol-tooltip',
    child: [{
      class: 'absol-tooltip-content'
    }, '.absol-tooltip-arrow']
  });
};

['addChild', 'addChildBefore', 'addChildAfter', 'clearChild'].forEach(function (key) {
  ToolTip.prototype[key] = function () {
    return this.$content[key].apply(this.$content, arguments);
  };
});

_ACore.default.install(ToolTip);

function updateTooltipPosition(toolTipClass) {
  var element = toolTipClass.$element;
  if (!element) return;
  var orientation = toolTipClass._orientation;
  var tBound = toolTipClass.$tooltip.$content.getBoundingClientRect();
  var ebound = element.getBoundingClientRect();
  var screenSize = (0, _Dom.getScreenSize)();
  var sMargin = Math.round(Math.min(5, screenSize.width / 100, screenSize.height));
  screenSize.width = Math.min(screenSize.width, document.body.getBoundingClientRect().width);
  var fontSize = toolTipClass.$tooltip.getFontSize();
  var dx = 0;
  var dy = 0;
  var arrowPos = null;
  var aHCenter = ebound.left + ebound.width / 2 > tBound.width / 2 && screenSize.width - ebound.left - ebound.width / 2 > tBound.width / 2;
  var aVCenter = ebound.top + ebound.height / 2 > tBound.height / 2 && screenSize.height - ebound.top - ebound.height / 2 > tBound.height / 2;
  var aTop = tBound.height < ebound.top - sMargin;
  var aBottom = tBound.height < screenSize.height - sMargin - ebound.bottom;
  var aRight = tBound.width < screenSize.width - sMargin - ebound.right;
  var aLeft = tBound.width < ebound.left - sMargin;
  var aHLeft = ebound.left + ebound.width / 2 - tBound.width / 2 < sMargin && ebound.left + ebound.width / 2 >= sMargin + fontSize / 2;
  var aHRight = ebound.left + ebound.width / 2 + tBound.width / 2 > screenSize.width - sMargin && ebound.left + ebound.width / 2 < screenSize.width - sMargin - fontSize / 2;
  var aVTop = ebound.top + ebound.width / 2 - tBound.height / 2 < sMargin && ebound.top + ebound.height / 2 >= sMargin + fontSize / 2;
  var aVBottom = ebound.top + ebound.width / 2 + tBound.height / 2 <= screenSize.height - sMargin && ebound.top + ebound.height / 2 > screenSize.height - sMargin - fontSize / 2;

  if (orientation === 'auto' && aHCenter) {
    if (aTop) {
      orientation = 'top';
    } else if (aBottom) {
      orientation = 'bottom';
    }
  }

  if (orientation === 'auto' && aVCenter) {
    if (aRight) {
      orientation = 'right';
    } else if (aLeft) {
      orientation = 'left';
    }
  }

  if ((orientation === 'auto' || orientation === 'top' || orientation === 'bottom') && aHLeft) {
    if (aTop || orientation === 'auto') orientation = "top";else if (aBottom || orientation === 'auto') orientation = 'bottom';

    if (aTop || aBottom) {
      dx += tBound.width / 2 - (ebound.left + ebound.width / 2) + sMargin;
      arrowPos = tBound.width / 2 - dx + 'px';
    }
  }

  if ((orientation === 'auto' || orientation === 'top' || orientation === 'bottom') && aHRight) {
    if (aTop || orientation === 'auto') orientation = "top";else if (aBottom || orientation === 'auto') orientation = 'bottom';

    if (aTop || aBottom) {
      dx -= tBound.width / 2 - (screenSize.width - (ebound.left + ebound.width / 2)) + sMargin;
      arrowPos = tBound.width / 2 - dx + 'px';
    }
  }

  if ((orientation === 'auto' || orientation === 'left' || orientation === 'right') && aVTop) {
    if (aLeft || orientation === 'auto') orientation = "left";else if (aRight || orientation === 'auto') {
      orientation = 'right';
    }

    if (aLeft || aRight) {
      dy += tBound.height / 2 - (ebound.top + ebound.height / 2) + sMargin;
      arrowPos = tBound.height / 2 - dy + 'px';
    }
  }

  if ((orientation === 'auto' || orientation === 'left' || orientation === 'right') && aVBottom) {
    if (aLeft || orientation === 'auto') orientation = "left";else if (aRight || orientation === 'auto') {
      orientation = 'right';
    }

    if (aLeft || aRight) {
      dy -= tBound.height / 2 - (screenSize.height - (ebound.top + ebound.height / 2)) + sMargin;
      arrowPos = tBound.height / 2 - dx + 'px';
    }
  }

  if (orientation === 'auto') {
    if (aRight) {
      if (aTop) {
        orientation = 'ne';
      } else if (aBottom) {
        orientation = 'se';
      }
    } else if (aLeft) {
      if (aTop) {
        orientation = 'nw';
      } else if (aBottom) {
        orientation = 'sw';
      }
    }
  }

  if (orientation === 'auto') orientation = "error";
  toolTipClass.$tooltip.removeClass('top').removeClass('left').removeClass('right').removeClass('bottom').removeClass('ne').removeClass('nw').removeClass('se').removeClass('sw').addClass(orientation);
  tBound = toolTipClass.$tooltip.getBoundingClientRect();

  if (orientation == 'top') {
    dy += ebound.top - tBound.height;
    dx += ebound.left + ebound.width / 2 - tBound.width / 2;
  } else if (orientation == 'left') {
    dy += ebound.top + ebound.height / 2 - tBound.height / 2;
    dx += ebound.left - tBound.width;
  } else if (orientation == 'right') {
    dy += ebound.top + ebound.height / 2 - tBound.height / 2;
    dx += ebound.right;
  } else if (orientation == 'bottom') {
    dy += ebound.bottom;
    dx += ebound.left + ebound.width / 2 - tBound.width / 2;
  } else if (orientation === 'ne') {
    dy += ebound.top - tBound.height;
    dx += ebound.right;
  } else if (orientation === 'nw') {
    dy += ebound.top - tBound.height;
    dx += ebound.left - tBound.width;
  } else if (orientation === 'se') {
    dy += ebound.bottom;
    dx += ebound.right;
  } else if (orientation === 'sw') {
    dy += ebound.bottom;
    dx += ebound.left - tBound.width;
  } else {
    throw new Error("Invalid orientation, orientation: ['left', 'right', 'top', 'bottom', 'auto', 'nw', 'ne', 'sw', 'se']");
  }

  if (arrowPos) {
    toolTipClass.$tooltip.addStyle('--tool-tip-arrow-pos', arrowPos);
  } else {
    toolTipClass.$tooltip.removeStyle('--tool-tip-arrow-pos');
  }

  toolTipClass.$holder.addStyle({
    top: dy + 'px',
    left: dx + 'px'
  });
}

ToolTip.$holder = _('.absol-tooltip-root-holder');
ToolTip.$tooltip = _('tooltip.top').addTo(ToolTip.$holder);
ToolTip.$element = undefined;
ToolTip.$content = undefined;
ToolTip._orientation = 'top';
ToolTip._session = Math.random() * 10000000000 >> 0;

ToolTip.updatePosition = function () {
  if (!ToolTip.$element) return;
  updateTooltipPosition(ToolTip);
};

ToolTip.$tooltip.$arrow.updateSize = ToolTip.updatePosition.bind(ToolTip);

ToolTip.show = function (element, content, orientation) {
  orientation = orientation || 'auto';

  if (typeof content == 'string') {
    content = _({
      tag: 'span',
      style: {
        'white-space': 'nowrap'
      },
      props: {
        innerHTML: content
      }
    });
  }

  $('', content, function (elt) {
    if (elt.tagName == "IMG" && elt.src) {
      _Dom.default.waitImageLoaded(elt).then(ToolTip.updatePosition.bind(ToolTip));
    } else if (elt.sync) {
      elt.sync.then(ToolTip.updatePosition.bind(ToolTip));
    }
  });
  var currentSession = Math.random() * 10000000000 >> 0;
  ToolTip.$holder.addTo(document.body);

  _Dom.default.addToResizeSystem(ToolTip.$tooltip.$arrow);

  ToolTip.$element = element;
  ToolTip._session = currentSession;
  ToolTip.$content = content;
  ToolTip._orientation = orientation;
  ToolTip.$tooltip.clearChild().addChild(content);
  ToolTip.$holder.removeStyle('visibility');
  ToolTip.$tooltip.removeClass('top').removeClass('left').removeClass('right').removeClass('bottom').removeClass('ne').removeClass('nw').removeClass('auto');
  ToolTip.$tooltip.addClass(orientation);
  ToolTip.updatePosition();
  return currentSession;
};

ToolTip.close = function (session) {
  if (session === true || session === this._session) {
    ToolTip.$holder.addStyle('visibility', 'hidden');
    ToolTip.$tooltip.clearChild();
    ToolTip.$holder.addStyle({
      top: false,
      left: false
    });
  }
};

ToolTip.closeTooltip = ToolTip.close;

ToolTip.showWhenClick = function (element, content, orientation) {
  var mSession = undefined;
  element.addEventListener('click', function () {
    if (mSession !== undefined) return;
    mSession = ToolTip.show(element, content, orientation);

    var finish = function (event) {
      if (!_EventEmitter.default.hitElement(content, event)) {
        $(document.body).off('click', finish);
        ToolTip.closeTooltip(mSession);
        mSession = undefined;
      }
    };

    setTimeout(function () {
      $(document.body).on('click', finish);
    }, 100);
  });
};

var _default = ToolTip;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/PageIndicator.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/PageIndicator.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

require("../css/pageindicator.css");


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function PageIndicator() {
  this._idx = -1;
  this.length = 0;
  this.idx = -1;
}

PageIndicator.tag = 'PageIndicator'.toLowerCase();

PageIndicator.render = function () {
  return _({
    class: 'as-page-indicator',
    child: []
  });
};

PageIndicator.property = {};
PageIndicator.property.length = {
  set: function (value) {
    value = value || 0;
    value = Math.max(0, value);

    while (this.childNodes.length < value) {
      this.addChild(_('button.as-page-indicator-item'));
    }

    while (this.childNodes.length > value) {
      this.removeChild(this.childNodes[this.childNodes.length - 1]);
    }

    this.idx = this._idx; //update
  },
  get: function () {
    return this.childNodes.length;
  }
};
PageIndicator.property.idx = {
  set: function (value) {
    var activeElt = this.childNodes[this._idx];
    if (activeElt) activeElt.removeClass('as-active');
    this._idx = value;
    activeElt = this.childNodes[this._idx];
    if (activeElt) activeElt.addClass('as-active');
  },
  get: function () {
    return this._idx;
  }
};

_ACore.default.install(PageIndicator);

var _default = PageIndicator;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/EmojiPickerTooltip.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/EmojiPickerTooltip.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/emojipickertooltip.css");

var _Tooltip = require("./Tooltip");

var _ACore = _interopRequireDefault(require("../ACore"));

var _EmojiPicker = _interopRequireDefault(require("./EmojiPicker"));

var _EmojiAnims = _interopRequireDefault(require("./EmojiAnims"));

var _PositionTracker = _interopRequireDefault(require("./PositionTracker"));

var _ResizeSystem = _interopRequireDefault(require("absol/src/HTML5/ResizeSystem"));

var _Dom = require("absol/src/HTML5/Dom");

var _Rectangle = _interopRequireDefault(require("absol/src/Math/Rectangle"));

var _EventEmitter = require("absol/src/HTML5/EventEmitter");

var _BrowserDetector = _interopRequireDefault(require("absol/src/Detector/BrowserDetector"));

var _PageIndicator = _interopRequireDefault(require("./PageIndicator"));

var _Hanger = _interopRequireDefault(require("./Hanger"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
var isMobile = _BrowserDetector.default.isMobile;
/***
 * @augments Tooltip
 * @augments AElement
 * @augments Hanger
 * @constructor
 */

function EmojiPickerTooltip() {
  if (isMobile) {
    _({
      tag: _Hanger.default.tag,
      elt: this,
      on: {
        predrag: this.eventHandler.preDragTT,
        dragstart: this.eventHandler.dragStartTT,
        drag: this.eventHandler.dragTT,
        dragend: this.eventHandler.dragEndTT
      }
    });
  }

  this.$iconList = $('.as-emoji-picker-tooltip-icon-list', this);
  this.$leftBtn = $('.as-emoji-picker-tooltip-left-btn', this).on('click', this.eventHandler.clickLeft);
  this.$scroller = $('.as-emoji-picker-tooltip-scroller', this);
  this.$rightBtn = $('.as-emoji-picker-tooltip-right-btn', this).on('click', this.eventHandler.clickRight);
  this.$removeBtn = $('.as-emoji-picker-tooltip-remove-btn', this).on('click', this.eventHandler.clickRemove);
  this.$pageIndicatior = $('pageindicator', this);
  this._iconButtonCache = {};
  this._icons = [];
  this.icons = EmojiPickerTooltip.defaultIcons;
}

EmojiPickerTooltip.tag = 'EmojiPickerTooltip'.toLowerCase();
EmojiPickerTooltip.defaultIcons = [';(', '(sarcastic)', ':O', '(cwl)', '(heart)', '(y)', '(n)', '(rock)', '(facepalm)', '(xd)', ':$', '(waiting)', '(headbang)', '(ghost)', '(clap)', '(punch)', '(ok)', '(angry)'];
EmojiPickerTooltip.emojiDict = _EmojiAnims.default.reduce(function (ac, cr) {
  ac[cr[0]] = {
    imageFileName: cr[1],
    text: cr[0],
    desc: cr[2]
  };
  return ac;
}, {});

EmojiPickerTooltip.render = function () {
  return _({
    tag: 'tooltip',
    extendEvent: ['pick'],
    class: ['as-emoji-picker-tooltip'].concat(isMobile ? ['as-mobile'] : []),
    child: [{
      tag: 'button',
      class: 'as-emoji-picker-tooltip-left-btn',
      child: 'span.mdi.mdi-chevron-left'
    }, {
      class: 'as-emoji-picker-tooltip-scroller',
      child: {
        class: 'as-emoji-picker-tooltip-icon-list'
      }
    }, {
      tag: 'button',
      class: 'as-emoji-picker-tooltip-right-btn',
      child: 'span.mdi.mdi-chevron-right'
    }, {
      tag: 'button',
      attr: {
        title: 'Remove Emoji'
      },
      class: 'as-emoji-picker-tooltip-remove-btn',
      child: 'span.mdi.mdi-close'
    }, {
      tag: 'pageindicator',
      class: 'as-emoji-picker-tooltip-page-indicator',
      props: {
        length: 3,
        idx: 0
      }
    }]
  }, true);
};
/*var */


EmojiPickerTooltip.prototype._makeIconBtn = function (iconText) {
  var icon = EmojiPickerTooltip.emojiDict[iconText];
  var url = _EmojiPicker.default.assetRoot + '/anim/x40/' + icon.imageFileName;

  var spriteElt = _({
    tag: 'sprite',
    class: 'as-emoji-picker-tooltip-icon',
    attr: {
      title: icon.desc
    },
    props: {
      src: url,
      loop: true,
      fps: 30,
      debug: true
    },
    on: {
      ready: function () {
        this.frames = {
          type: 'grid',
          col: 1,
          row: this.texture.naturalHeight / this.texture.naturalWidth
        };
        this.frameIndex = 0;
      }
    }
  });

  var buttonElt = _({
    tag: 'button',
    class: 'as-emoji-picker-tooltip-icon-btn',
    child: spriteElt,
    on: {
      click: this.eventHandler.clickIconBtn.bind(null, icon)
    }
  });

  buttonElt.on('mouseenter', function () {
    spriteElt.play();
  }).on('mouseleave', function () {
    spriteElt.stop();
    spriteElt.frameIndex = 0;
  });
  return buttonElt;
};

EmojiPickerTooltip.prototype._updateIconList = function () {
  this.$iconList.clearChild();
  var iconText;

  for (var i = 0; i < this._icons.length; ++i) {
    iconText = this._icons[i];
    this._iconButtonCache[iconText] = this._iconButtonCache[iconText] || this._makeIconBtn(iconText);
    this.$iconList.addChild(this._iconButtonCache[iconText]);
  }
};

EmojiPickerTooltip.property = {};
EmojiPickerTooltip.property.icons = {
  set: function (icons) {
    this._icons = icons || [];

    this._updateIconList();

    this.viewOffset = 0;
    this.$pageIndicatior.length = Math.ceil(this._icons.length / 6);
  },
  get: function () {
    return this._icons;
  }
};
EmojiPickerTooltip.property.viewOffset = {
  set: function (value) {
    this._viewOffset = Math.max(0, Math.min(value, this._icons.length - 6));
    this.$iconList.addStyle('left', -(100 * this._viewOffset / 6) + '%');
    this.$leftBtn.disabled = this._viewOffset === 0;
    this.$rightBtn.disabled = this._viewOffset === this._icons.length - 6;
    this.$pageIndicatior.idx = Math.floor(this._viewOffset / 6);
  },
  get: function () {
    return this._viewOffset;
  }
};
EmojiPickerTooltip.eventHandler = {};

EmojiPickerTooltip.eventHandler.clickLeft = function () {
  this.viewOffset -= 6;
};

EmojiPickerTooltip.eventHandler.clickRight = function () {
  this.viewOffset += 6;
};

EmojiPickerTooltip.eventHandler.clickIconBtn = function (icon) {
  if (this._preventClick) return;
  this.emit('pick', Object.assign({
    type: 'pick',
    icon: icon,
    target: this
  }, icon), this);
};

EmojiPickerTooltip.eventHandler.clickRemove = function () {
  this.emit('pick', Object.assign({
    type: 'pressremove',
    icon: "REMOVE",
    target: this
  }), this);
};

EmojiPickerTooltip.eventHandler.preDragTT = function (event) {
  var scrollerBound = this.$scroller.getBoundingClientRect();
  var listBound = this.$iconList.getBoundingClientRect();
  this._scrollData = {
    left: listBound.left - scrollerBound.left,
    scrollerWidth: scrollerBound.width,
    newLeft: listBound.left - scrollerBound.left
  };
};

EmojiPickerTooltip.eventHandler.dragStartTT = function () {
  this.addClass('as-scrolling');
  this._preventClick = true;
};

EmojiPickerTooltip.eventHandler.dragTT = function (event) {
  event.preventDefault();
  var dx = event.currentPoint.sub(event.startingPoint).x;
  var newLeft = Math.min(0, Math.max(-this._scrollData.scrollerWidth * 2, this._scrollData.left + dx));
  this._scrollData.newLeft = newLeft;
  this.$iconList.addStyle('left', newLeft + 'px');
};

EmojiPickerTooltip.eventHandler.dragEndTT = function (event) {
  event.preventDefault();
  this.removeClass('as-scrolling');
  var dOffset = (this._scrollData.left - this._scrollData.newLeft) / this._scrollData.scrollerWidth;

  if (dOffset > 0.25) {
    dOffset = 1;
  } else if (dOffset < -0.25) {
    dOffset = -1;
  } else {
    dOffset = 0;
  }

  this.viewOffset += dOffset * 6;
  setTimeout(function () {
    this._preventClick = false;
  }.bind(this), 5);
};

_ACore.default.install(EmojiPickerTooltip);

function prepare() {
  if (EmojiPickerTooltip.$holder) return;
  EmojiPickerTooltip.$holder = _('.absol-tooltip-root-holder');
  EmojiPickerTooltip.$tooltip = _('emojipickertooltip.top').addTo(EmojiPickerTooltip.$holder).on('pick', function (event) {
    EmojiPickerTooltip._listener && EmojiPickerTooltip._listener(event.icon);
  });
  /***
   *
   * @type {PositionTracker|undefined}
   */

  EmojiPickerTooltip.$element = undefined;
  EmojiPickerTooltip.$content = undefined;
  EmojiPickerTooltip._orientation = 'auto';
  EmojiPickerTooltip._session = Math.random() * 10000000000 >> 0;
  EmojiPickerTooltip._listener = undefined;
  EmojiPickerTooltip._scrollOutListener = undefined;
  EmojiPickerTooltip.$tooltip.$arrow.updateSize = EmojiPickerTooltip.updatePosition;
}

EmojiPickerTooltip.updatePosition = function () {
  if (!EmojiPickerTooltip.$element) return;

  var outBound = _Rectangle.default.fromClientRect((0, _Dom.traceOutBoundingClientRect)(EmojiPickerTooltip.$element));

  var eBound = _Rectangle.default.fromClientRect(EmojiPickerTooltip.$element.getBoundingClientRect());

  if (!outBound.isCollapse(eBound, 0)) {
    EmojiPickerTooltip._scrollOutListener && EmojiPickerTooltip._scrollOutListener();
  }

  (0, _Tooltip.updateTooltipPosition)(EmojiPickerTooltip);
};

EmojiPickerTooltip.updatePosition = EmojiPickerTooltip.updatePosition.bind(EmojiPickerTooltip);

EmojiPickerTooltip.show = function (element, menuListener, orientation) {
  prepare();

  if (EmojiPickerTooltip.$element) {
    EmojiPickerTooltip.$element.stopTrackPosition();
    EmojiPickerTooltip.$element.off('positionchange', EmojiPickerTooltip.updatePosition);
  }

  if (!element.startTrackPosition) {
    _({
      tag: _PositionTracker.default.tag,
      elt: element
    });
  }

  element.startTrackPosition();
  EmojiPickerTooltip.$element = element;
  EmojiPickerTooltip.$element.on('positionchange', EmojiPickerTooltip.updatePosition);
  EmojiPickerTooltip._listener = menuListener;
  EmojiPickerTooltip._session = Math.random() * 10000000000 >> 0;
  EmojiPickerTooltip._orientation = orientation || 'auto';
  EmojiPickerTooltip.$holder.addTo(document.body);

  _ResizeSystem.default.add(EmojiPickerTooltip.$tooltip.$arrow);

  EmojiPickerTooltip.$tooltip.viewOffset = 0;
  EmojiPickerTooltip.$tooltip.addClass('top').removeClass('left').removeClass('right').removeClass('bottom').removeClass('ne').removeClass('nw').removeClass('auto');
  EmojiPickerTooltip.updatePosition();
  return EmojiPickerTooltip._session;
};

EmojiPickerTooltip.close = function (token) {
  if (EmojiPickerTooltip._session !== token) return;

  if (EmojiPickerTooltip.$element) {
    EmojiPickerTooltip.$element.stopTrackPosition();
    EmojiPickerTooltip.$element.off('positionchange', EmojiPickerTooltip.updatePosition);
  }

  EmojiPickerTooltip.$element = undefined;
  EmojiPickerTooltip._listener = undefined;
  EmojiPickerTooltip._session = Math.random() * 10000000000 >> 0;
  EmojiPickerTooltip.$holder.remove();
};

EmojiPickerTooltip.toggleWhenClick = function (trigger, adaptor) {
  var res = {
    trigger: trigger,
    adaptor: adaptor,
    currentSession: undefined
  };

  function clickHandler(event) {
    if (res.currentSession === EmojiPickerTooltip._session) return;
    res.currentSession = EmojiPickerTooltip.show(res.adaptor.getFlowedElement ? res.adaptor.getFlowedElement() : trigger, res.adaptor.onSelect, res.adaptor.orientation || 'auto');
    if (res.adaptor.onOpen) res.adaptor.onOpen();

    var finish = function (event) {
      if (event && ((0, _EventEmitter.hitElement)(EmojiPickerTooltip.$tooltip.$leftBtn, event) || (0, _EventEmitter.hitElement)(EmojiPickerTooltip.$tooltip.$rightBtn, event)) || event && event.target && event.target.classList.contains('absol-tooltip-content')) return;
      document.body.removeEventListener('click', finish, false);
      EmojiPickerTooltip.close(res.currentSession);
      if (adaptor.onClose) adaptor.onClose();
      res.currentSession = undefined;
      if (EmojiPickerTooltip._scrollOutListener === EmojiPickerTooltip) EmojiPickerTooltip._scrollOutListener = undefined;
    };

    EmojiPickerTooltip._scrollOutListener = finish;
    setTimeout(function () {
      document.body.addEventListener('click', finish, false);
    }, 10);
  }

  res.remove = function () {
    trigger.removeEventListener('click', clickHandler, false);
    trigger.classList.remove('as-emoji-picker-tooltip-trigger');
  };

  trigger.addEventListener('click', clickHandler, false);
  trigger.classList.add('as-emoji-picker-tooltip-trigger');
  return res;
};

var _default = EmojiPickerTooltip;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/EmojiUserListTooltip.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/EmojiUserListTooltip.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/emojiuserlisttooltip.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Tooltip = _interopRequireDefault(require("./Tooltip"));

var _EmojiPicker = _interopRequireDefault(require("./EmojiPicker"));

var _EmojiPickerTooltip = _interopRequireDefault(require("./EmojiPickerTooltip"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @augments ToolTip
 * @augments AElement
 * @constructor
 */

function EmojiUserListTooltip() {
  this._text = null;
  this._users = [];
  this.$sprite = _({
    tag: 'sprite',
    class: 'as-emoji-user-list-tooltip-emoji',
    props: {
      fps: 30,
      loop: true
    },
    on: {
      ready: function () {
        this.frames = {
          type: 'grid',
          col: 1,
          row: this.texture.naturalHeight / this.texture.naturalWidth
        };
      }
    }
  });
  this.appendChild(this.$sprite);
  this.text = '(heart)';
  this.user = [];
}

EmojiUserListTooltip.tag = 'EmojiUserListTooltip'.toLowerCase();

EmojiUserListTooltip.render = function () {
  return _({
    tag: 'tooltip',
    class: 'as-emoji-user-list-tooltip'
  }, true);
};

EmojiUserListTooltip.prototype._updateUsers = function () {
  var thisT = this;
  this.$content.clearChild();

  this._users.forEach(function (user) {
    var elt = _({
      class: 'as-emoji-user-list-tooltip-user',
      child: [{
        class: 'as-emoji-user-list-tooltip-avatar',
        style: {
          backgroundImage: 'url(' + user.avatar + ')'
        }
      }, {
        class: 'as-emoji-user-list-tooltip-name',
        child: {
          text: user.name
        }
      }]
    });

    if (user.onclick) {
      elt.addClass('as-clickable');
      elt.on('click', user.onclick.bind(user));
    }

    thisT.$content.addChild(elt);
  });
};

EmojiUserListTooltip.prototype.playEmoji = function () {
  this.$sprite.afterReady().then(this.$sprite.play.bind(this.$sprite));
};

EmojiUserListTooltip.prototype.stopEmoji = function () {
  this.$sprite.stop();
};

EmojiUserListTooltip.property = {};
EmojiUserListTooltip.property.users = {
  set: function (users) {
    this._users = users || [];

    this._updateUsers();
  },
  get: function () {
    return this._users;
  }
};
EmojiUserListTooltip.property.text = {
  set: function (value) {
    if (value === this._text) return;
    var icon = _EmojiPickerTooltip.default.emojiDict[value];
    if (!value) return;
    var url = _EmojiPicker.default.assetRoot + '/anim/x60/' + icon.imageFileName;
    this._text = value;
    this.$sprite.src = url;
  },
  get: function () {
    return this._text;
  }
};

_ACore.default.install(EmojiUserListTooltip);

var _default = EmojiUserListTooltip;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/EmojiCounter.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/EmojiCounter.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/emojicounter.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _EmojiPickerTooltip = _interopRequireDefault(require("./EmojiPickerTooltip"));

var _EmojiPicker = _interopRequireDefault(require("./EmojiPicker"));

var _Tooltip = _interopRequireWildcard(require("./Tooltip"));

var _Rectangle = _interopRequireDefault(require("absol/src/Math/Rectangle"));

var _Dom = require("absol/src/HTML5/Dom");

var _EmojiUserListTooltip = _interopRequireDefault(require("./EmojiUserListTooltip"));

var _BrowserDetector = _interopRequireDefault(require("absol/src/Detector/BrowserDetector"));




var $ = _ACore.default.$;
var _ = _ACore.default._;
var isMobile = _BrowserDetector.default.isMobile;
/***
 * @extends AElement
 * @constructor
 */

function EmojiCounter() {
  /***
   *
   * @type {Sprite}
   */
  this.$sprite = $('sprite', this);
  this.$num = $('.as-emoji-counter-num', this);
  this.$numText = this.$num.firstChild;
  this._text = '(heart)';
  this.text = this._text;
  this._count = 0;
  this.count = 0;
  this._checkInterval = -1;

  if (isMobile) {
    this.attr('tabindex', '1');
    this.on('focus', this.eventHandler.mouseEnter);
  } else {
    this.on('mouseenter', this.eventHandler.mouseEnter);
  }

  this._tooltipSession = null;
  this._tooltipFinishTimeout = -1;
}

EmojiCounter.tag = 'EmojiCounter'.toLowerCase();

EmojiCounter.render = function () {
  var icon = _EmojiPickerTooltip.default.emojiDict['(heart)'];
  var url = _EmojiPicker.default.assetRoot + '/anim/x40/' + icon.imageFileName;
  return _({
    class: 'as-emoji-counter',
    child: [{
      tag: 'sprite',
      class: 'as-emoji-counter-sprite',
      props: {
        src: url,
        loop: true,
        fps: 30,
        debug: true
      },
      on: {
        ready: function () {
          this.frames = {
            type: 'grid',
            col: 1,
            row: this.texture.naturalHeight / this.texture.naturalWidth
          };
          this.frameIndex = 0;
        }
      }
    }, {
      tag: 'span',
      class: 'as-emoji-counter-num',
      child: {
        text: '0'
      }
    }]
  });
};

EmojiCounter.property = {};
EmojiCounter.property.text = {
  set: function (value) {
    var icon = _EmojiPickerTooltip.default.emojiDict[value];
    if (!icon) return;
    if (this._text === value) return;
    this.$sprite.src = _EmojiPicker.default.assetRoot + '/anim/x40/' + icon.imageFileName;
    this._text = value;
  },
  get: function () {
    return this._text;
  }
};
EmojiCounter.property.count = {
  set: function (value) {
    this.$numText.data = value + '';

    if (value === 1 && this._count != 1) {
      this.$numText.remove();
    } else if (value != 1 && this._count == 1) {
      this.$num.addChild(this.$numText);
    }

    if (value == 0) this.addClass('as-zero');else this.removeClass('as-zero');
    this._count = value;
  },
  get: function () {
    return this._count;
  }
};

_ACore.default.install(EmojiCounter);

EmojiCounter.eventHandler = {};

EmojiCounter.eventHandler.loop = function () {
  if (!this.isDescendantOf(document.body)) this.eventHandler.finishHover();
  if (this.getBoundingClientRect().width === 0) this.eventHandler.finishHover();
};

EmojiCounter.eventHandler.mouseEnter = function () {
  if (this._tooltipFinishTimeout > 0) {
    clearTimeout(this._tooltipFinishTimeout);
  }

  if (this._checkInterval > 0) return;
  this.$sprite.play();
  this._checkInterval = setInterval(this.eventHandler.loop, 1000);
  this.on('mouseleave', this.eventHandler.finishHover);

  if (this.users && this.users.length > 0) {
    prepare();
    EmojiCounter._session = Math.random() * 10000000000 >> 0;
    this._tooltipSession = EmojiCounter._session;
    EmojiCounter.$element = this;
    EmojiCounter.$holder.addTo(this);
    EmojiCounter.$tooltip.text = this.text;
    EmojiCounter.$tooltip.users = this.users;
    EmojiCounter.$tooltip.playEmoji();
    (0, _Tooltip.updateTooltipPosition)(EmojiCounter);
  }
};

EmojiCounter.eventHandler.finishHover = function () {
  if (this._tooltipFinishTimeout > 0) {
    clearTimeout(this._tooltipFinishTimeout);
  }

  this._tooltipFinishTimeout = setTimeout(function () {
    this._tooltipFinishTimeout = -1;
    this.$sprite.stop();
    this.off('mouseleave', this.eventHandler.finishHover);

    if (this._checkInterval > 0) {
      clearInterval(this._checkInterval);
      this._checkInterval = -1;
    }

    if (this._tooltipSession === EmojiCounter._session) {
      EmojiCounter._session = Math.random() * 10000000000 >> 0;
      EmojiCounter.$holder.remove();
      EmojiCounter.$tooltip.stopEmoji();
    }
  }.bind(this), 500);
};

function prepare() {
  if (EmojiCounter.$holder) return;
  EmojiCounter.$holder = _('.absol-tooltip-root-holder');
  EmojiCounter.$tooltip = _('EmojiUserListTooltip.top'.toLowerCase()).addTo(EmojiCounter.$holder);
  EmojiCounter._scrollOutListener = undefined;
  EmojiCounter._orientation = 'top';
  EmojiCounter._session = Math.random() * 10000000000 >> 0;
  _EmojiPickerTooltip.default._listener = undefined;
  EmojiCounter.$element = null;
  EmojiCounter.$tooltip.$arrow.updateSize = EmojiCounter.updatePosition;
}

EmojiCounter.updatePosition = function () {
  if (!EmojiCounter.$element) return;

  var outBound = _Rectangle.default.fromClientRect((0, _Dom.traceOutBoundingClientRect)(EmojiCounter.$element));

  var eBound = _Rectangle.default.fromClientRect(EmojiCounter.$element.getBoundingClientRect());

  if (!outBound.isCollapse(eBound, 0)) {
    _EmojiPickerTooltip.default._scrollOutListener && EmojiCounter._scrollOutListener();
  }

  (0, _Tooltip.updateTooltipPosition)(EmojiCounter);
};

EmojiCounter.updatePosition = EmojiCounter.updatePosition.bind(EmojiCounter);
var _default = EmojiCounter;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/EmojiCounterList.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/EmojiCounterList.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

var _EmojiPickerTooltip = _interopRequireDefault(require("./EmojiPickerTooltip"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function EmojiCounterList() {
  this._counters = [];
  this.counters = [];
}

EmojiCounterList.tag = 'EmojiCounterList'.toLowerCase();

EmojiCounterList.render = function () {
  return _({
    class: 'as-emoji-counter-list'
  });
};

EmojiCounterList.iconOrdering = _EmojiPickerTooltip.default.defaultIcons.reduce(function (ac, cr, idx) {
  ac[cr] = idx + 1;
  return ac;
}, {});

EmojiCounterList.prototype._updateCounters = function () {
  var newCounters = this._counters;
  var newCounterNameArr = Object.keys(newCounters);
  newCounterNameArr.sort(function (a, b) {
    return (EmojiCounterList.iconOrdering[a] || 1000) - (EmojiCounterList.iconOrdering[b] || 1000);
  });
  var counterElements = Array.prototype.filter.call(this.childNodes, function (e) {
    return e.containsClass && e.containsClass('as-emoji-counter');
  });
  var newCounterElements = [];
  var elt, name;
  var oe, on;

  while (counterElements.length > 0 || newCounterNameArr.length > 0) {
    elt = counterElements[0];
    name = newCounterNameArr[0];

    if (elt && name) {
      if (elt.text === name) {
        newCounterElements.push(elt);
        counterElements.shift();
        newCounterNameArr.shift();
      } else {
        oe = EmojiCounterList.iconOrdering[elt.text];
        on = EmojiCounterList.iconOrdering[name];

        if (oe < on) {
          newCounterElements.push(elt);
          counterElements.shift();
        } else {
          newCounterElements.push(name);
          newCounterNameArr.shift();
        }
      }
    } else if (elt) {
      newCounterElements.push(elt);
      counterElements.shift();
    } else {
      newCounterElements.push(name);
      newCounterNameArr.shift();
    }
  }

  var cElt, prevElt;

  while (newCounterElements.length > 0) {
    cElt = newCounterElements.pop();

    if (typeof cElt === "string") {
      cElt = _({
        tag: 'emojicounter',
        props: {
          text: cElt,
          users: newCounters[cElt].users || [],
          count: newCounters[cElt].count
        }
      });

      if (!prevElt) {
        this.addChild(cElt);
      } else {
        this.addChildBefore(cElt, prevElt);
      }

      prevElt = cElt;
    } else {
      if (newCounters[cElt.text]) {
        cElt.count = newCounters[cElt.text].count;
        cElt.users = newCounters[cElt.text].users || [];
        prevElt = cElt;
      } else {
        cElt.remove();
      }
    }
  }
};

EmojiCounterList.property = {};
EmojiCounterList.property.counters = {
  set: function (counters) {
    this._counters = Object.keys(counters || {}).reduce(function (ac, key) {
      var counter = counters[key];

      if (typeof counter === "object") {
        if (counter.count > 0 && _EmojiPickerTooltip.default.emojiDict[key]) {
          ac[key] = counter;
        }
      }

      return ac;
    }, {});

    this._updateCounters();
  },
  get: function () {
    return this._counters;
  }
};

_ACore.default.install(EmojiCounterList);

var _default = EmojiCounterList;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/FlexiconButton.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/FlexiconButton.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/flexiconbutton.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/**
 * @extends AElement
 * @constructor
 */

function FlexiconButton() {
  this._icon = null;
  this.$content = $('.as-flexicon-button-content', this);
  this.$iconCtn = $('.as-flexicon-button-icon-container', this);
  this.$textCtn = $('.as-flexicon-button-text-container', this);
}

FlexiconButton.tag = 'FlexiconButton'.toLowerCase();

FlexiconButton.render = function () {
  return _({
    tag: 'button',
    class: 'as-flexicon-button',
    child: {
      class: 'as-icon-button-table-box',
      child: {
        class: 'as-flexicon-button-content',
        child: ['.as-flexicon-button-icon-container', '.as-flexicon-button-text-container']
      }
    }
  });
};

FlexiconButton.property = {};
FlexiconButton.property.icon = {
  set: function (value) {
    value = value || null;
    this._icon = value;
    this.$iconCtn.clearChild();

    if (value !== null) {
      this.$iconCtn.addChild(_(value));
    }
  },
  get: function () {
    return this._icon;
  }
};
FlexiconButton.property.text = {
  set: function (value) {
    value = value || null;
    this._text = value;
    this.$textCtn.clearChild();

    if (value !== null) {
      this.$textCtn.addChild(_({
        text: value
      }));
    }
  },
  get: function () {
    return this._text;
  }
};

_ACore.default.install(FlexiconButton);

var _default = FlexiconButton;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/FlexiconInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/FlexiconInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/flexiconinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function FlexiconInput() {
  this.$input = $('.as-flexicon-input-text-input', this);
  this.$iconCtn = $('.as-flexicon-input-icon-ctn', this);
  this.$unitCtn = $('.as-flexicon-input-unit-ctn', this);

  _OOP.default.drillProperty(this, this.$input, ['value', 'readonly']);

  this.on('click', function (event) {
    if (event.target != this.$input) this.$input.focus();
  }.bind(this));
}

FlexiconInput.prototype.on = function () {
  return this.$input.on.apply(this.$input, arguments);
};

FlexiconInput.prototype.once = function () {
  return this.$input.once.apply(this.$input, arguments);
};

FlexiconInput.prototype.off = function () {
  return this.$input.off.apply(this.$input, arguments);
};

FlexiconInput.tag = 'FlexiconInput'.toLowerCase();

FlexiconInput.render = function () {
  return _({
    class: 'as-flexicon-input',
    child: [{
      class: 'as-flexicon-input-icon-ctn'
    }, {
      tag: 'input',
      class: 'as-flexicon-input-text-input',
      attr: {
        type: 'text'
      }
    }, {
      class: 'as-flexicon-input-unit-ctn'
    }]
  });
};

FlexiconInput.property = {};
FlexiconInput.property.icon = {
  set: function (value) {
    value = value || null;
    this._icon = value;
    this.$iconCtn.clearChild();

    if (value == null) {
      this.removeClass('as-flexicon-input-has-icon');
    } else {
      this.addClass('as-flexicon-input-has-icon');
      this.$iconCtn.addChild(_(value));
    }
  },
  get: function () {
    return this._icon;
  }
};
FlexiconInput.property.unit = {
  set: function (value) {
    this._unit = value;

    if (this._unit) {
      this.addClass('as-flexicon-input-has-unit');
      this.$unitCtn.clearChild().addChild(_({
        text: value + ''
      }));
    } else {
      this.removeClass('as-flexicon-input-has-unit');
      this.$unitCtn.clearChild();
    }
  },
  get: function () {
    return this._unit;
  }
};
FlexiconInput.property.disabled = {
  set: function (value) {
    value = !!value;
    this.$input.disabled = value;

    if (value) {
      this.addClass('as-disabled');
    } else {
      this.removeClass('as-disabled');
    }
  },
  get: function () {
    return this.$input.disabled;
  }
};

_ACore.default.install(FlexiconInput);

var _default = FlexiconInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/FollowerToggler.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/FollowerToggler.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function FollowerToggler() {
  this.defineEvent(['close', 'open', 'preopen']);
  this.on('click', this.eventHandler.click);
  this.addClass('as-follower-trigger');
  this.$follower = null;
  this._opened = false;
}

FollowerToggler.tag = 'FollowerToggler'.toLowerCase();

FollowerToggler.render = function () {
  return _('div');
};

FollowerToggler.prototype.toggle = function () {
  if (this._opened) this.close();else this.open();
};

FollowerToggler.prototype.open = function () {
  if (this._opened) return;
  this._opened = true;
  this.addClass('as-follower-trigger-open');
  if (!this.$follower) return;
  this.emit('preopen', {
    name: 'preopen',
    target: this
  }, this);
  var thisTg = this;
  setTimeout(function () {
    thisTg.$follower.refollow();
    thisTg.$follower.removeClass('absol-follower-hidden');
    document.body.addEventListener('click', thisTg.eventHandler.clickBody);
    thisTg.emit('open', {
      name: 'open',
      target: this
    }, this);
  }, 1);
};

FollowerToggler.prototype.close = function () {
  if (!this._opened) return;
  this._opened = false;
  this.removeClass('as-follower-trigger-open');
  if (!this.$follower) return;
  this.$follower.unfollow();
  this.$follower.addClass('absol-follower-hidden');
  document.body.removeEventListener('click', this.eventHandler.clickBody);
  this.emit('close', {
    name: 'close',
    target: this
  }, this);
};

FollowerToggler.prototype.bindFollower = function (elt) {
  if (this.$follower) {
    this.$follower.followTarget = null;
  }

  if (elt && elt.refollow) {
    if (this._opened) elt.removeClass('absol-follower-hidden');else elt.addClass('absol-follower-hidden');
    elt.followTarget = this;
    this.$follower = elt;
  } else {
    throw new Error("Must be a follower!");
  }
};

FollowerToggler.eventHandler = {};

FollowerToggler.eventHandler.clickBody = function (event) {
  if (_EventEmitter.default.hitElement(this, event) || _EventEmitter.default.hitElement(this.$follower, event)) return;
  this.close();
};

FollowerToggler.eventHandler.click = function () {
  this.toggle();
};

_ACore.default.install(FollowerToggler);

var _default = FollowerToggler;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Frame.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Frame.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/frame.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _stringGenerate = require("absol/src/String/stringGenerate");

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function Frame() {
  this.$parent = null; // FrameView or TabView
}

Frame.tag = 'frame';

Frame.render = function () {
  return _({
    class: 'absol-frame',
    attr: {
      id: (0, _stringGenerate.randomIdent)(12)
    },
    extendEvent: ['attached', 'detached', 'deactive', 'active'] // deactive and active event will be send by parent

  });
};

Frame.prototype.notifyAttached = function (parentElt) {
  this.$parent = parentElt;
  this.emit('attached', {
    type: 'attached',
    target: this,
    parentElt: parentElt
  }, this);
};

Frame.prototype.notifyDetached = function () {
  this.emit('detached', {
    type: 'detached',
    target: this,
    parentElt: this.$parent
  }, this);
  this.$parent = undefined;
};

Frame.prototype.selfRemove = function () {
  if (this.$parent) this.$parent.removeChild(this);else this.super(); // normal remove
};

Frame.prototype.getParent = function () {
  return this.$parent;
};

Frame.prototype.requestActive = function () {
  if (this.$parent) {
    this.$parent.activeFrame(this);
  }
};

_ACore.default.install(Frame);

var _default = Frame;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/FrameView.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/FrameView.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/frameview.css");

var _Frame = _interopRequireDefault(require("./Frame"));

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function FrameView() {
  this.$containers = [];
}

FrameView.tag = 'frameview';

FrameView.render = function () {
  return _({
    class: 'absol-frame-view',
    extendEvent: ['activeframe', 'deactiveframe']
  });
};

FrameView.prototype.addChild = function (elt) {
  if (elt.containsClass && elt.containsClass('absol-frame')) {
    elt.selfRemove();

    var containerElt = _({
      class: 'absol-frame-view-frame-container',
      child: elt,
      props: {
        __elt__: elt
      }
    });

    this.$containers.push(containerElt);
    this.appendChild(containerElt);
    elt.notifyAttached(this);
  } else {
    throw new Error('Children must be a frame');
  }
};

FrameView.prototype.addLast = function (elt) {
  this.addChild(elt);
  this.activeFrame(elt);
};

FrameView.prototype.removeLast = function () {
  if (this.$containers.length > 0) {
    this.removeChild(this.$containers[this.$containers.length - 1].__elt__);
  }

  if (this.$containers.length > 0) {
    this.activeFrame(this.$containers[this.$containers.length - 1].__elt__);
  }
};

FrameView.prototype.getLength = function () {
  return this.$containers.length;
};

FrameView.prototype.getAllChild = function () {
  return this.$containers.map(function (ctn) {
    return ctn.__elt__;
  });
};

FrameView.prototype.getLast = function () {
  if (this.$containers.length > 0) {
    return this.$containers[this.$containers.length - 1].__elt__;
  }

  return null;
};

FrameView.prototype.addChildBefore = function (elt, at) {
  if (elt.containsClass && elt.containsClass('absol-frame')) {
    elt.selfRemove();
    var index = this.childIndexOf(at);

    if (index < 0) {
      throw new Error('Second param is not a child');
    }

    var index = this.childIndexOf(at);
    var atCtnElt = this.$containers[index];

    var containerElt = _({
      class: 'absol-frame-view-frame-container',
      child: elt,
      props: {
        __elt__: elt
      }
    });

    this.$containers.splice(index, 0, containerElt);
    this.super(containerElt, atCtnElt);
    elt.notifyAttached(this);
  } else {
    throw new Error('Children must be a frame');
  }
};

FrameView.prototype.addChildAfter = function (elt, at) {
  if (elt.containsClass && elt.containsClass('absol-frame')) {
    elt.selfRemove();
    var index = this.childIndexOf(at);

    if (index < 0) {
      throw new Error('Second param is not a child');
    }

    var index = this.childIndexOf(at);
    var atCtnElt = this.$containers[index];

    var containerElt = _({
      class: 'absol-frame-view-frame-container',
      child: elt,
      props: {
        __elt__: elt
      }
    });

    this.$containers.splice(index + 1, 0, containerElt);
    this.super(containerElt, atCtnElt);
    elt.notifyAttached(this);
  } else {
    throw new Error('Children must be a frame');
  }
};

FrameView.prototype.removeChild = function (elt) {
  var ctnEltIndex = this.childIndexOf(elt);

  if (ctnEltIndex >= 0) {
    var ctnElt = this.$containers[ctnEltIndex];
    this.$containers.splice(ctnEltIndex, 1);
    this.super(ctnElt);
  } else {
    throw new Error('Removed element is not a child!');
  }
};

FrameView.prototype.childIndexOf = function (elt) {
  for (var i = 0; i < this.$containers.length; ++i) {
    if (this.$containers[i].__elt__ == elt) return i;
  }

  return -1;
};

FrameView.prototype.findChildBefore = function (elt) {
  var eltIndex = this.childIndexOf(elt);
  if (eltIndex < 0) return -1;
  return this.$containers[eltIndex - 1];
};

FrameView.prototype.findChildAfter = function (elt) {
  var eltIndex = this.childIndexOf(elt);
  if (eltIndex < 0) return -1;
  return this.$containers[eltIndex + 1];
};

FrameView.prototype.clearChild = function () {
  while (this.$containers.length > 0) {
    this.removeChild(this.$containers[0].__elt__);
  }

  return this;
};

FrameView.prototype.findChildById = function (id) {
  var elt;

  for (var i = 0; i < this.$containers.length; ++i) {
    elt = this.$containers[i].__elt__;
    if (elt.getAttribute('id') == id) return elt;
  }

  return undefined;
};

FrameView.prototype.getAllChild = function () {
  return this.$containers.map(function (ctnElt) {
    return ctnElt.__elt__;
  });
};

FrameView.prototype.activeFrame = function (frameElt) {
  var ctnElt, elt;

  for (var i = 0; i < this.$containers.length; ++i) {
    ctnElt = this.$containers[i];
    elt = ctnElt.__elt__;

    if (frameElt == elt) {
      if (!ctnElt.containsClass('absol-active')) {
        ctnElt.addClass('absol-active');
        this.notifyActiveFrame(elt);
      } // else do nothing

    } else {
      if (ctnElt.containsClass('absol-active')) {
        ctnElt.removeClass('absol-active');
        this.notifyDeactiveFrame(elt);
      } // else do nonthing

    }
  }

  return this;
};

FrameView.prototype.notifyActiveFrame = function (frameElt, originEvent) {
  frameElt.emit('active', {
    target: frameElt,
    type: 'active',
    originEvent: originEvent
  });
  this.emit('activeframe', {
    type: 'activeframe',
    target: this,
    frameElt: frameElt,
    originEvent: originEvent
  }, this);
};

FrameView.prototype.notifyDeactiveFrame = function (frameElt, originEvent) {
  this.emit('deactiveframe', {
    type: 'deactiveframe',
    target: this,
    frameElt: frameElt,
    originEvent: originEvent
  }, this);
};

FrameView.prototype.activeFrameById = function (id) {
  var frameElt = this.findChildById(id);
  if (frameElt) this.activeFrame(frameElt);
  return this;
};

_ACore.default.install('frameview', FrameView);

var _default = FrameView;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/HRuler.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/HRuler.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/hruler.css");

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function HRuler() {
  var self = this;
  this.$attachHook = _('attachhook').on('error', function () {
    this.updateSize = self.update.bind(self);

    _Dom.default.addToResizeSystem(this);

    this.updateSize();
  }).addTo(self);
  this.$lines = [];
  this.$numbers = [];
  this._viewingNumberCount = 0;
  this._viewingLineCount = 0;
  this._spacing = 10;
  this._major = 10;
  this.$measureTarget = null;
  this._valueFloat = 'left';
}

HRuler.tag = 'hruler';

HRuler.render = function () {
  return _({
    class: 'as-hruler'
  });
};

HRuler.prototype.measureElement = function (elt) {
  if (typeof elt == "string") elt = $(elt);
  this.$measureTarget = elt;
  this.update();
};

HRuler.prototype.update = function () {
  var fontSize = this.getFontSize();
  var measureBound;
  var bound = this.getBoundingClientRect();
  var contentBound = {
    left: bound.left + 1,
    right: bound.right - 1,
    top: bound.top + 1,
    bottom: bound.bottom - 1,
    width: bound.width - 2,
    height: bound.height - 2
  };

  if (this.$measureTarget) {
    measureBound = this.$measureTarget.getBoundingClientRect();
  } else {
    measureBound = contentBound;
  }

  var startOfset = (measureBound[this._valueFloat] - contentBound[this._valueFloat]) * (this.inverse ? -1 : 1) % this._spacing;
  if (startOfset < 0) startOfset += this._spacing;
  var lineIndexOfset = Math.round(((contentBound[this._valueFloat] - measureBound[this._valueFloat]) * (this.inverse ? -1 : 1) + startOfset) / this._spacing);
  var lineCount = Math.floor((contentBound.width - startOfset) / this._spacing) + 1;

  while (this.$lines.length < lineCount) {
    this.$lines.push(_('.as-hruler-line'));
  }

  var i;
  var lineElt;

  for (i = 0; i < lineCount; ++i) {
    lineElt = this.$lines[i];

    if ((i + lineIndexOfset) % this._major == 0) {
      lineElt.addClass('major');
    } else {
      lineElt.removeClass('major');
    }

    lineElt.addStyle(this._valueFloat, startOfset + this._spacing * i - 0.5 + 'px');
  }

  while (this._viewingLineCount < lineCount) {
    this.$lines[this._viewingLineCount++].addTo(this);
  }

  while (this._viewingLineCount > lineCount) {
    this.$lines[--this._viewingLineCount].remove();
  }

  var numberCount = Math.floor((lineCount + lineIndexOfset - 1) / this._major) - Math.ceil(lineIndexOfset / this._major) + 1;

  while (this.$numbers.length < numberCount) {
    this.$numbers.push(_('.as-hruler-major-number'));
  }

  var numberElt;
  var number;
  var majorStartOfset = startOfset;

  if (lineIndexOfset > 0) {
    majorStartOfset += (this._major - lineIndexOfset % this._spacing) * this._spacing;
  } else {
    majorStartOfset += (this._major - (this._spacing + lineIndexOfset % this._spacing)) * this._spacing;
  }

  for (i = 0; i < numberCount; ++i) {
    number = (Math.ceil(lineIndexOfset / this._major) + i) * this._spacing * this._major;
    numberElt = this.$numbers[i];

    if (numberElt.__cacheNumber__ != number) {
      numberElt.__cacheNumber__ = number;
      numberElt.innerHTML = number + '';
    }

    numberElt.addStyle(this._valueFloat, majorStartOfset + this._major * i * this._spacing - 0.7 * 2.5 * fontSize + 'px');
  }

  while (this._viewingNumberCount < numberCount) {
    this.$numbers[this._viewingNumberCount++].addTo(this);
  }

  while (this._viewingNumberCount > numberCount) {
    this.$numbers[--this._viewingNumberCount].remove();
  }
};

HRuler.property = {};
HRuler.property.major = {
  set: function (value) {
    if (value > 0) {
      this._major = value;
      this.update();
    }
  },
  get: function () {
    return this._major;
  }
};
HRuler.property.spacing = {
  set: function (value) {
    if (value > 0) {
      this._spacing = value;
      this.update();
    }
  },
  get: function () {
    return this._spacing;
  }
};
HRuler.property.inverse = {
  set: function (value) {
    this._valueFloat = value ? 'right' : 'left';
    this.update();
  },
  get: function () {
    return this._valueFloat == 'right';
  }
};

_ACore.default.install(HRuler);

var _default = HRuler;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/HexaSectionLabel.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/HexaSectionLabel.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/hexasectionlabel.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Svg = _interopRequireDefault(require("absol/src/HTML5/Svg"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
var _g = _Svg.default.ShareInstance._;
var $g = _Svg.default.ShareInstance.$;
var Design = {
  hexaHeight: 425,
  textBoxHeight: 286,
  textHeight: 96,
  indexHeight: 110,
  textBoxPaddingLeft: 127,
  borderWidth: 38
};
var StyleSheet = {
  '.as-hexa-section-label-text': {
    height: Design.textBoxHeight / Design.textHeight + 'em',
    'padding-left': Design.textBoxPaddingLeft / Design.textHeight + 'em',
    'line-height': Design.textBoxHeight / Design.textHeight + 'em'
  },
  '.as-hexa-section-label-index': {
    'font-size': Design.indexHeight / Design.textHeight + 'em',
    height: Design.hexaHeight / Design.indexHeight + 'em',
    'line-height': Design.hexaHeight / Design.indexHeight + 'em',
    width: (Design.hexaHeight + Design.borderWidth) / Math.cos(Math.PI / 6) / Design.indexHeight + 'em'
  }
};

_({
  tag: 'style',
  id: 'hexa-section-label-style',
  props: {
    innerHTML: Object.keys(StyleSheet).map(function (key) {
      var style = StyleSheet[key];
      return key + ' {\n' + Object.keys(style).map(function (propName) {
        return propName + ': ' + style[propName] + ';';
      }).join('\n') + '}';
    }).join('\n')
  }
}).addTo(document.head);
/***
 * @extends AElement
 * @constructor
 */


function HexaSectionLabel() {
  this.$background = $('.as-hexa-section-label-background', this);
  this.$index = $('.as-hexa-section-label-index', this);
  this.$text = $('.as-hexa-section-label-text', this);
  this.$attachhook = _('attachhook').addTo(this).on('error', function () {
    _Dom.default.addToResizeSystem(this);

    this.requestUpdateSize();
  });
  this.$attachhook.requestUpdateSize = this.redrawBackground.bind(this);
  this.$svg = _g({
    tag: 'svg',
    attr: {
      width: '0',
      height: '0'
    },
    child: ['path.as-hexa-section-label-text-box', 'path.as-hexa-section-label-index-box']
  }).addTo(this.$background);
  this.$indexBox = $g('path.as-hexa-section-label-index-box', this.$svg);
  this.$textBox = $g('path.as-hexa-section-label-text-box', this.$svg);
}

HexaSectionLabel.prototype.redrawBackground = function () {
  var indexBound = this.$index.getBoundingClientRect();
  var textBound = this.$text.getBoundingClientRect();
  var cHeight = indexBound.height;
  var cWidth = textBound.right - indexBound.left;
  this.$svg.attr({
    height: cHeight + '',
    width: cWidth + '',
    viewBox: [0, 0, cWidth, cHeight].join(' ')
  });
  var borderWidth = cHeight * Design.borderWidth / Design.hexaHeight;
  var radius = cHeight / Math.cos(Math.PI / 6) / 2 - borderWidth / 2;
  var x0 = indexBound.width / 2;
  var y0 = cHeight / 2;
  this.$indexBox.attr('d', Array(6).fill(0).map(function (u, i) {
    var angle = Math.PI / 3 + i * Math.PI / 3;
    var x = radius * Math.cos(angle) + x0;
    var y = radius * Math.sin(angle) + y0;
    return (i == 0 ? 'M' : 'L') + x + ' ' + y;
  }).join(' ') + 'Z').addStyle({
    strokeWidth: borderWidth + ''
  });
  var skewX = 18 / 45;
  var textBoxHeight = textBound.height;
  this.$textBox.attr('d', [[x0, (cHeight - textBoxHeight) / 2], [cWidth - 1, (cHeight - textBoxHeight) / 2], [cWidth - 1 - textBoxHeight * skewX, (cHeight - textBoxHeight) / 2 + textBoxHeight], [x0, (cHeight - textBoxHeight) / 2 + textBoxHeight]].map(function (point, i) {
    return (i == 0 ? 'M' : 'L') + point.join(' ');
  }).join(' ') + 'Z');
};

HexaSectionLabel.tag = 'HexaSectionLabel'.toLowerCase();

HexaSectionLabel.render = function () {
  return _({
    class: 'as-hexa-section-label',
    child: [{
      class: 'as-hexa-section-label-background'
    }, '.as-hexa-section-label-index', '.as-hexa-section-label-text']
  });
};

HexaSectionLabel.property = {};
HexaSectionLabel.property.index = {
  set: function (value) {
    this._index = value;
    this.$index.clearChild().addChild(_({
      text: value + ''
    }));
  },
  get: function () {
    return this._index;
  }
};
HexaSectionLabel.property.text = {
  set: function (value) {
    this._text = value;
    this.$text.clearChild().addChild(_({
      text: value + ''
    }));
  },
  get: function () {
    return this._text;
  }
};

_ACore.default.install(HexaSectionLabel);

var _default = HexaSectionLabel;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/IconSprite.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/IconSprite.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function IconSprite() {
  this.$attachhook = _('attachhook').addTo(this).on('error', this.eventHandler.attached);
  this.on('frame', this.eventHandler.frame);
  this._checkRootTimeout = 30;
  this.loop = true;
}

IconSprite.tag = 'iconsprite';

IconSprite.render = function () {
  return _('sprite', true);
};
/**
 * @type {IconSprite}
 */


IconSprite.eventHandler = {};

IconSprite.eventHandler.attached = function () {
  var thisAS = this;
  this._checkRootTimeout = 30;
  this.afterReady().then(function () {
    thisAS.width = thisAS.texture.naturalWidth;
    thisAS.height = thisAS.width;
    thisAS.frames = {
      type: 'grid',
      col: 1,
      row: thisAS.texture.naturalHeight / thisAS.texture.naturalWidth
    };
    thisAS.drawFrame(0);
    thisAS.play();
  });
};

IconSprite.eventHandler.frame = function () {
  this._checkRootTimeout--;

  if (this._checkRootTimeout == 0) {
    if (this.isDescendantOf(document.body)) {
      this._checkRootTimeout = 30;
    } else {
      this.stop();
      this.remove();
    }
  }
};

_ACore.default.install(IconSprite);

var _default = IconSprite;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/assets/icon/spinner.tpl"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/assets/icon/spinner.tpl ***/
module.exports = "<svg class=\"as-spinner-ico\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"margin:auto;background:#fff;display:block;\" width=\"200px\" height=\"200px\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMidYMid\">\r\n    <g><circle cx=\"73.801\" cy=\"68.263\" fill=\"#e15b64\" r=\"4\">\r\n        <animateTransform attributeName=\"transform\" type=\"rotate\" calcMode=\"spline\" values=\"0 50 50;360 50 50\" times=\"0;1\" keySplines=\"0.5 0 0.5 1\" repeatCount=\"indefinite\" dur=\"1.4925373134328357s\" begin=\"0s\"></animateTransform>\r\n    </circle><circle cx=\"68.263\" cy=\"73.801\" fill=\"#f47e60\" r=\"4\">\r\n        <animateTransform attributeName=\"transform\" type=\"rotate\" calcMode=\"spline\" values=\"0 50 50;360 50 50\" times=\"0;1\" keySplines=\"0.5 0 0.5 1\" repeatCount=\"indefinite\" dur=\"1.4925373134328357s\" begin=\"-0.062s\"></animateTransform>\r\n    </circle><circle cx=\"61.481\" cy=\"77.716\" fill=\"#f8b26a\" r=\"4\">\r\n        <animateTransform attributeName=\"transform\" type=\"rotate\" calcMode=\"spline\" values=\"0 50 50;360 50 50\" times=\"0;1\" keySplines=\"0.5 0 0.5 1\" repeatCount=\"indefinite\" dur=\"1.4925373134328357s\" begin=\"-0.125s\"></animateTransform>\r\n    </circle><circle cx=\"53.916\" cy=\"79.743\" fill=\"#abbd81\" r=\"4\">\r\n        <animateTransform attributeName=\"transform\" type=\"rotate\" calcMode=\"spline\" values=\"0 50 50;360 50 50\" times=\"0;1\" keySplines=\"0.5 0 0.5 1\" repeatCount=\"indefinite\" dur=\"1.4925373134328357s\" begin=\"-0.187s\"></animateTransform>\r\n    </circle><circle cx=\"46.084\" cy=\"79.743\" fill=\"#849b87\" r=\"4\">\r\n        <animateTransform attributeName=\"transform\" type=\"rotate\" calcMode=\"spline\" values=\"0 50 50;360 50 50\" times=\"0;1\" keySplines=\"0.5 0 0.5 1\" repeatCount=\"indefinite\" dur=\"1.4925373134328357s\" begin=\"-0.25s\"></animateTransform>\r\n    </circle><circle cx=\"38.519\" cy=\"77.716\" fill=\"#6492ac\" r=\"4\">\r\n        <animateTransform attributeName=\"transform\" type=\"rotate\" calcMode=\"spline\" values=\"0 50 50;360 50 50\" times=\"0;1\" keySplines=\"0.5 0 0.5 1\" repeatCount=\"indefinite\" dur=\"1.4925373134328357s\" begin=\"-0.312s\"></animateTransform>\r\n    </circle><circle cx=\"31.737\" cy=\"73.801\" fill=\"#637cb5\" r=\"4\">\r\n        <animateTransform attributeName=\"transform\" type=\"rotate\" calcMode=\"spline\" values=\"0 50 50;360 50 50\" times=\"0;1\" keySplines=\"0.5 0 0.5 1\" repeatCount=\"indefinite\" dur=\"1.4925373134328357s\" begin=\"-0.375s\"></animateTransform>\r\n    </circle><circle cx=\"26.199\" cy=\"68.263\" fill=\"#6a63b6\" r=\"4\">\r\n        <animateTransform attributeName=\"transform\" type=\"rotate\" calcMode=\"spline\" values=\"0 50 50;360 50 50\" times=\"0;1\" keySplines=\"0.5 0 0.5 1\" repeatCount=\"indefinite\" dur=\"1.4925373134328357s\" begin=\"-0.437s\"></animateTransform>\r\n    </circle><animateTransform attributeName=\"transform\" type=\"rotate\" calcMode=\"spline\" values=\"0 50 50;0 50 50\" times=\"0;1\" keySplines=\"0.5 0 0.5 1\" repeatCount=\"indefinite\" dur=\"1.4925373134328357s\"></animateTransform></g>\r\n</svg>";

return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Icons.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Icons.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpinnerIco = SpinnerIco;

var _ACore = _interopRequireDefault(require("../ACore"));

var _spinner = _interopRequireDefault(require("../assets/icon/spinner.tpl"));


function SpinnerIco() {
  return _ACore.default._(_spinner.default);
}

SpinnerIco.tag = 'SpinnerIco'.toLowerCase();

_ACore.default.install(SpinnerIco);
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/LinearColorBar.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/LinearColorBar.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/linearcolorbar.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _Svg = _interopRequireDefault(require("absol/src/HTML5/Svg"));

var _utils = require("./utils");


var _ = _ACore.default._;
var $ = _ACore.default.$;
var _g = _Svg.default.ShareInstance._;
var $g = _Svg.default.ShareInstance.$;
var Design = {
  textHeight: 56,
  barHeight: 97,
  barBlockWidth: 79,
  barBlockMargin: 19,
  valueTextHeight: 70,
  valueStrokeWidth: 5,
  valueHeight: 99,
  valueWidth: 52,
  valueTripHeight: 32,
  height: 430,
  barY: 201
};
var SyleSheet = {
  '.as-linear-color-bar': {
    height: Design.height / Design.textHeight + 'em'
  },
  '.as-linear-color-value-text': {
    'font-size': Design.valueTextHeight / Design.textHeight + 'em'
  }
};
(0, _utils.buildCss)(SyleSheet);

function LinearColorBar() {
  this._indent = (Math.random() + '').replace(/[^0-9]/g, '_');
  this._extendValue = 0;
  this._value = 0;
  this._valueText = '';
  this.$valueText = $('.as-linear-color-value-text', this);
  this.$minValueText = $('.as-linear-color-min-value-text', this);
  this.$maxValueText = $('.as-linear-color-max-value-text', this);
  this.$background = $('svg.as-linear-color-background', this);
  this._attached = false;
  var thisBar = this;
  this.$attachhook = _('attachhook').addTo(this).on('error', function () {
    thisBar._attached = true;

    _Dom.default.addToResizeSystem(this);

    this.requestUpdateSize();
  });
  this.$background.attr({
    height: 0,
    width: 0
  });
  this.$attachhook.requestUpdateSize = this.redraw.bind(this);
  this.$defs = _g('defs').addTo(this.$background);
  this.$gradient = _g('linearGradient#gradient_' + this._indent).attr({
    x1: "0%",
    y1: "0%",
    x2: "100%",
    y2: "0%"
  }).addTo(this.$defs);
  this.$rect = _g('rect.as-linear-color-bar-rect').attr({
    fill: 'url(#gradient_' + this._indent + ')'
  }).addTo(this.$background);
  this.$splitLine = _g('path.as-linear-color-split-line').addTo(this.$background);
  this.$valueArrow = _g('path.as-linear-color-value-arrow').addTo(this.$background);
  this.colorMapping = 'rainbow';
}

LinearColorBar.prototype.redraw = function () {
  var bBound = this.getBoundingClientRect();
  var cWidth = bBound.width;
  var cHeight = bBound.height;
  var maxTextBound = this.$maxValueText.getBoundingClientRect();
  var minTextBound = this.$minValueText.getBoundingClientRect();
  var valueTextBound = this.$valueText.getBoundingClientRect();
  var valueWidth = Design.valueWidth / Design.height * cHeight;
  var minValueX = valueWidth / 1.5;
  this.$minValueText.addStyle('left', Math.max((minValueX - minTextBound.width) / 2, 0) + 'px');
  var maxValueX = (cWidth - Design.valueWidth) / (1 + this._extendValue);
  var extendX = cWidth - valueWidth / 1.5;
  var valueX = minValueX + this._value * (maxValueX - minValueX);
  this.$valueText.addStyle('left', valueX - valueTextBound.width / 2 + 'px');
  this.$maxValueText.addStyle('left', maxValueX - maxTextBound.width / 2 + 'px');
  var barY = Design.barY / Design.height * cHeight;
  var barHeight = Design.barHeight / Design.height * cHeight;
  this.$rect.attr({
    x: '' + minValueX,
    y: '' + barY,
    width: extendX - minValueX + '',
    height: barHeight
  });
  this.$background.attr({
    height: cHeight + '',
    width: cWidth + '',
    viewBox: [0, 0, cWidth, cHeight].join(' ')
  });
  var valueTripHeight = Design.valueTripHeight / Design.height * cHeight;
  var valueHeight = Design.valueHeight / Design.height * cHeight;
  this.$valueArrow.addStyle('stroke-width', Design.valueStrokeWidth / Design.height * cHeight + '').attr('d', [[[valueX, barY], [valueX - valueWidth / 2, barY - valueTripHeight], [valueX - valueWidth / 2, barY - valueHeight], [valueX + valueWidth / 2, barY - valueHeight], [valueX + valueWidth / 2, barY - valueTripHeight]]].map(function (point, i) {
    return (i == 0 ? 'M' : 'L') + point.join(' ');
  }).join(' ') + 'Z');
  var splitDistMin = (Design.barBlockWidth + Design.barBlockMargin) / Design.height * cHeight;
  var splitCounts = [100, 50, 20, 10, 5, 2, 1];
  var splitDist = maxValueX - minValueX;
  var splitCount = 1;

  for (var i = 0; i < splitCounts.length; ++i) {
    splitDist = (maxValueX - minValueX) / splitCounts[i];

    if (splitDist >= splitDistMin) {
      splitCount = splitCounts[i];
      break;
    }
  }

  this.$splitLine.addStyle('stroke-width', Design.barBlockMargin / Design.height * cHeight + '').attr({
    d: Array(splitCount + 1).fill(0).map(function (u, i) {
      return 'M' + (maxValueX - i * splitDist) + ' ' + (barY - 1) + 'v' + (barHeight + 2);
    }).join(' ')
  });
};

LinearColorBar.prototype._updateGradient = function () {
  var barMax = 1 + this._extendValue;
  var gradientElt = this.$gradient.clearChild();

  this._colorMapping.forEach(function (it) {
    _g({
      tag: 'stop',
      attr: {
        offset: (it.value <= 1 ? it.value / barMax * 100 : 100) + '%'
      },
      style: {
        'stop-color': it.color + '',
        'stop-opacity': '1'
      }
    }).addTo(gradientElt);
  });
};

LinearColorBar.prototype.BUILDIN_COLORS_RANGE = {
  'rainbow': [{
    value: 0,
    color: 'red'
  }, {
    value: 1 / 6,
    color: 'orange'
  }, {
    value: 1 / 3,
    color: 'yellow'
  }, {
    value: 1 / 2,
    color: 'green'
  }, {
    value: 2 / 3,
    color: 'blue'
  }, {
    value: 5 / 6,
    color: 'indigo'
  }, {
    value: 1,
    color: 'violet'
  }, {
    value: Infinity,
    color: 'violet'
  }],
  'rainbow-invert': [{
    value: 0,
    color: 'violet'
  }, {
    value: 1 / 6,
    color: 'indigo'
  }, {
    value: 1 / 3,
    color: 'blue'
  }, {
    value: 1 / 2,
    color: 'green'
  }, {
    value: 2 / 3,
    color: 'yellow'
  }, {
    value: 5 / 6,
    color: 'orange'
  }, {
    value: 1,
    color: 'red'
  }, {
    value: Infinity,
    color: 'violet'
  }],
  'performance': [{
    value: 0,
    color: 'red'
  }, {
    value: 0.5,
    color: 'orange'
  }, {
    value: 1,
    color: 'green'
  }, {
    value: Infinity,
    color: 'green'
  }],
  'performance-invert': [{
    value: 0,
    color: 'green'
  }, {
    value: 0.5,
    color: 'orange'
  }, {
    value: 1,
    color: 'red'
  }, {
    value: Infinity,
    color: 'red'
  }]
};
LinearColorBar.tag = 'LinearColorBar'.toLowerCase();

LinearColorBar.render = function () {
  return _({
    class: 'as-linear-color-bar',
    child: ['svg.as-linear-color-background', '.as-linear-color-value-text', '.as-linear-color-min-value-text', '.as-linear-color-max-value-text']
  });
};

LinearColorBar.property = {};
LinearColorBar.property.valueText = {
  set: function (value) {
    value = value + '';
    this._valueText = value;
    this.$valueText.clearChild().addChild(_({
      text: value
    }));
  },
  get: function () {
    return this._valueText;
  }
};
LinearColorBar.property.minValueText = {
  set: function (value) {
    value = value + '';
    this._minValueText = value;
    this.$minValueText.clearChild().addChild(_({
      text: value
    }));
  },
  get: function () {
    return this._valueText;
  }
};
LinearColorBar.property.maxValueText = {
  set: function (value) {
    value = value + '';
    this._maxValueText = value;
    this.$maxValueText.clearChild().addChild(_({
      text: value
    }));
  },
  get: function () {
    return this._valueText;
  }
};
LinearColorBar.property.value = {
  set: function (value) {
    this._value = value;
  },
  get: function () {
    return this._value;
  }
};
LinearColorBar.property.extendValue = {
  set: function (value) {
    this._extendValue = value;

    this._updateGradient();
  },
  get: function () {
    return this._extendValue;
  }
};
LinearColorBar.property.colorMapping = {
  set: function (value) {
    if (typeof value == "string") value = this.BUILDIN_COLORS_RANGE[value];
    this._colorMapping = value.slice();

    this._colorMapping.sort(function (a, b) {
      return a.value - b.value;
    });

    this._updateGradient();
  },
  get: function () {
    return this._colorMapping;
  }
};

_ACore.default.install(LinearColorBar);

var _default = LinearColorBar;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/Converter/file.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/Converter/file.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.blobToFile = blobToFile;
exports.dataURItoBlob = dataURItoBlob;
exports.blobToArrayBuffer = blobToArrayBuffer;
exports.stringToBlob = stringToBlob;

function blobToFile(theBlob, fileName) {
  return new File([theBlob], fileName);
}

function dataURItoBlob(dataURI) {
  var byteString = atob(dataURI.split(',')[1]);
  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
  var ab = new ArrayBuffer(byteString.length);
  var ia = new Uint8Array(ab);

  for (var i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }

  var blob = new Blob([ab], {
    type: mimeString
  });
  return blob;
}

function blobToArrayBuffer(blob) {
  var fileReader = new FileReader();
  return new Promise(function (rs) {
    fileReader.onload = function (event) {
      var arrayBuffer = event.target.result;
      rs(arrayBuffer);
    };

    fileReader.readAsArrayBuffer(blob);
  });
}

function stringToBlob(text, type) {
  return new Blob([text], {
    type: type || 'text/plain'
  });
}
return module.exports;
};

moduleFactories["node_modules/absol/src/HTML5/Text.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/HTML5/Text.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTextNodesIn = getTextNodesIn;
exports.setSelectionRangeStart = setSelectionRangeStart;
exports.setSelectionRangeEnd = setSelectionRangeEnd;
exports.setSelectionRange = setSelectionRange;
exports.getTextIn = getTextIn;
exports.textToNodes = textToNodes;
exports.getCaretPosition = getCaretPosition;
exports.setCaretPosition = setCaretPosition;
exports.measureText = measureText;

var _Dom = _interopRequireDefault(require("./Dom"));


function getTextNodesIn(node) {
  var textNodes = [];

  if (node.nodeType == 3) {
    textNodes.push(node);
  } else {
    var children = node.childNodes;

    for (var i = 0, len = children.length; i < len; ++i) {
      textNodes.push.apply(textNodes, getTextNodesIn(children[i]));
    }
  }

  return textNodes;
}
/**
 * 
 * @param {Element} el 
 * @param {Range} range 
 * @param {Number} start 
 * @returns {Number} -1: ok,  ret >= 0(is length of text) : need move to next element
 * 
 */


function setSelectionRangeStart(el, range, start) {
  if (start > 0) {
    if (el.nodeType == Node.TEXT_NODE) {
      var text = el.data;

      if (start <= text.length) {
        range.setStart(el, start);
        return -1;
      } else return text.length;
    }

    if (el.tagName.toLowerCase() == 'br') {
      return 0;
    } else {
      var delta = 0;
      var i = 0;
      var textLength = 0;
      var newLine = false;

      while (delta >= 0 && i < el.childNodes.length) {
        var childElt = el.childNodes[i];

        if (newLine) {
          newLine = false;
          ++textLength;
        }

        delta = setSelectionRangeStart(childElt, range, start - textLength);
        if (delta >= 0) textLength += delta;

        if (childElt.nodeType != Node.TEXT_NODE && (window.getComputedStyle(childElt).display == 'block' || childElt.tagName.toLowerCase() == 'br')) {
          newLine = true;
        }

        ++i;
      }

      if (delta >= 0) return textLength;
      return -1;
    }
  } else {
    range.setStart(el, 0);
    return -1;
  }
}
/**
 * 
 * @param {Element} el 
 * @param {Range} range 
 * @param {Number} end 
 * @returns {Number} -1: ok,  ret >= 0(is length of text) : need move to next element
 * 
 */


function setSelectionRangeEnd(el, range, end) {
  if (end > 0) {
    if (el.nodeType == Node.TEXT_NODE) {
      var text = el.data;

      if (end <= text.length) {
        range.setEnd(el, end);
        return -1;
      } else return text.length;
    }

    if (el.tagName.toLowerCase() == 'br') {
      return 0;
    } else {
      var delta = 0;
      var i = 0;
      var textLength = 0;
      var newLine = false;

      while (delta >= 0 && i < el.childNodes.length) {
        var childElt = el.childNodes[i];

        if (newLine) {
          newLine = false;
          ++textLength;
        }

        delta = setSelectionRangeEnd(childElt, range, end - textLength);
        if (delta >= 0) textLength += delta;

        if (childElt.nodeType != Node.TEXT_NODE && (window.getComputedStyle(childElt).display == 'block' || childElt.tagName.toLowerCase() == 'br')) {
          newLine = true;
        }

        ++i;
      }

      if (delta >= 0) return textLength;
      return -1;
    }
  } else {
    range.setEnd(el, 0);
    return -1;
  }
}

function setSelectionRange(el, start, end) {
  if (document.createRange && window.getSelection) {
    var range = document.createRange();
    range.selectNodeContents(el);
    var delta;

    if (start >= 0) {
      delta = setSelectionRangeStart(el, range, start);
      if (delta >= 0) range.setStart(el, el.childNodes.length);
    } else {
      start = 0;
      range.setStart(el, 0);
    }

    if (end >= start) {
      delta = setSelectionRangeEnd(el, range, end);
      if (delta >= 0) range.setEnd(el, el.childNodes.length);
    }

    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (document.selection && document.body.createTextRange) {
    var textRange = document.body.createTextRange();
    textRange.moveToElementText(el);
    textRange.collapse(true);
    textRange.moveEnd("character", end);
    textRange.moveStart("character", start);
    textRange.select();
  }
}

function getTextIn(e) {
  if (e.nodeType == Node.TEXT_NODE) {
    return e.data;
  }

  if (e.tagName && e.tagName.toLowerCase() == 'br') return '';
  var texts = [];
  var newLine = false;

  for (var i = 0; i < e.childNodes.length; ++i) {
    if (newLine) {
      newLine = false;
      texts.push('\n');
    }

    var childElt = e.childNodes[i];
    texts.push(getTextIn(childElt));

    if (childElt.nodeType != Node.TEXT_NODE && (window.getComputedStyle(childElt).display == 'block' || childElt.tagName.toLowerCase() == 'br')) {
      newLine = true;
    }
  }

  return texts.join('');
}

function textToNodes(text) {
  var lines = text.split(/\r?\n/);
  return lines.map(function (text) {
    if (text.length == 0) {
      return _Dom.default.ShareInstance._({
        child: {
          tag: 'br'
        }
      });
    } else {
      return _Dom.default.ShareInstance._({
        child: {
          text: text
        }
      });
    }
  });
}
/*
** Returns the caret (cursor) position of the specified text field (oField).
** Return value range is 0-oField.value.length.
*/


function getCaretPosition(oField) {
  // Initialize
  var iCaretPos = 0; // IE Support

  if (document.selection) {
    // Set focus on the element
    oField.focus(); // To get cursor position, get empty selection range

    var oSel = document.selection.createRange(); // Move selection start to 0 position

    oSel.moveStart('character', -oField.value.length); // The caret position is selection length

    iCaretPos = oSel.text.length;
  } // Firefox support
  else if (oField.selectionStart || oField.selectionStart == '0') iCaretPos = oField.selectionDirection == 'backward' ? oField.selectionStart : oField.selectionEnd; // Return results


  return iCaretPos;
}

function setCaretPosition(oField, caretPos) {
  if (oField.createTextRange) {
    var range = oField.createTextRange();
    range.move('character', caretPos);
    range.select();
  } else {
    if (oField.selectionStart) {
      oField.focus();
      oField.setSelectionRange(caretPos, caretPos);
    } else oField.focus();
  }
}

function measureText(text, font) {
  // re-use canvas object for better performance
  var canvas = measureText.canvas || (measureText.canvas = document.createElement("canvas"));
  var context = canvas.getContext("2d");
  if (font) context.font = font;
  var metrics = context.measureText(text);
  return metrics;
}
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/MediaInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/MediaInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/mediainput.css");

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _file = require("absol/src/Converter/file");

var _Svg = _interopRequireDefault(require("absol/src/HTML5/Svg"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _Text = require("absol/src/HTML5/Text");

var _BScroller = _interopRequireDefault(require("./BScroller"));


var MediACore = new _Dom.default();
MediACore.install(_ACore.default);
var _ = MediACore._;
var $ = MediACore.$;

function openFileDialog(props) {
  if (!MediACore.$fileInput) {
    MediACore.$fileInput = _({
      tag: 'input',
      class: 'vmedia-no-show',
      attr: {
        type: 'file'
      },
      props: {}
    }).addTo(document.body);
  }

  props = props || {};

  if (props.accept) {
    if (props.accept instanceof Array) MediACore.$fileInput.attr('accept', props.accept.join(','));else MediACore.$fileInput.attr('accept', props.accept);
  } else {
    MediACore.$fileInput.attr('accept', null);
  }

  if (props.multiple) {
    MediACore.$fileInput.attr('multiple', 'true');
  } else {
    MediACore.$fileInput.attr('multiple');
  }

  MediACore.$fileInput.value = null;
  MediACore.$fileInput.click();
  return new Promise(function (resolve, reject) {
    var finish = false;
    var body = $('body');
    MediACore.$fileInput.once('change', function () {
      finish = true;
      resolve(Array.prototype.map.call(this.files, function (file) {
        return file;
      }));
    });
    body.once('mousedown', function () {
      if (finish) return;
      resolve();
    });
  });
}

function MediaInput() {
  this.$editor = $('.vmedia-media-input-text-container-editor', this);
  this.$editor.on('paste', this.eventHandler.paste);
  this.$editor.on('keydown', this.eventHandler.keydown, true);
  this.$addImagebtn = $('#add-image-btn', this);
  this.$addImagebtn.on('click', this.eventHandler.clickAddImage);
  this.$addFilebtn = $('#add-file-btn', this);
  this.$addFilebtn.on('click', this.eventHandler.clickAddFile);
  this.$imagePreviewContainer = $('.vmedia-media-input-imagepreview-container', this);
  this.on('dragover', this.eventHandler.dragOver);
  this.on('drop', this.eventHandler.drop);
  this.$sendbtn = $('#send-btn', this);
  this.$sendbtn.on('click', this.eventHandler.send);
  this.$toolLeftCtn = $('.vmedia-media-input-tool-container-left', this);
  this.$pluginContentCtn = $('.vmedia-media-input-plugin-content-container', this);
  this.snapData = [];
  this.snapDataHead = 0;
  this.sync = this.afterAttached();
  this.snapText();
}

MediaInput.tag = 'MediaInput'.toLowerCase();

MediaInput.render = function () {
  return _({
    class: 'vmedia-media-input',
    extendEvent: ['send', 'update', 'releaseplugin'],
    child: {
      class: 'vmedia-media-input-text-container',
      child: [{
        class: 'vmedia-media-input-imagepreview-container',
        child: {
          class: 'vmedia-media-input-dropover',
          child: 'download-ico'
        }
      }, {
        class: 'vmedia-media-input-text-container-editor',
        attr: {
          contenteditable: 'true'
        },
        on: {}
      }, {
        class: 'vmedia-media-input-text-container-buttons',
        attr: {
          title: 'Send'
        }
      }, {
        class: 'vmedia-media-input-tool-container',
        child: [{
          class: 'vmedia-media-input-tool-container-left',
          child: [{
            tag: 'button',
            attr: {
              id: 'add-image-btn',
              title: 'Add image'
            },
            child: 'add-image-ico'
          }, {
            tag: 'button',
            attr: {
              id: 'add-file-btn',
              title: 'Add file'
            },
            child: 'add-file-ico'
          }]
        }, {
          class: 'vmedia-media-input-tool-container-right',
          child: [{
            tag: 'button',
            id: 'send-btn',
            attr: {
              title: 'Send'
            },
            child: 'send-ico'
          }]
        }]
      }, '.vmedia-media-input-plugin-content-container.blur']
    }
  });
};

MediaInput.prototype.addImage = function (url, title, data) {
  _({
    tag: 'imagepreview',
    attr: {
      title: title
    },
    props: {
      data: data,
      imgSrc: url
    },
    on: {
      pressremove: function () {
        this.selfRemove();
      }
    }
  }).addTo(this.$imagePreviewContainer);
};

MediaInput.prototype.addFile = function (url, ext, title, data) {
  _({
    tag: 'filepreview',
    attr: {
      title: title
    },
    props: {
      fileSrc: url,
      ext: ext,
      data: data
    },
    on: {
      pressremove: function () {
        this.selfRemove();
      }
    }
  }).addTo(this.$imagePreviewContainer);
};

MediaInput.property = {};
MediaInput.property.text = {
  set: function (value) {
    this.$editor.clearChild();
    value = value || '';
    var lines = value.split(/\r*\n/);
    if (lines.length < 1) return;
    this.$editor.addChild(document.createTextNode(lines[0]));
    lines.shift();
    lines.forEach(function (line) {
      this.$editor.addChild(_({
        child: document.createTextNode(line)
      }));
    }.bind(this));
    this.snapText();
  },
  get: function () {
    return this.getTextFromElements(this.$editor);
  }
};
MediaInput.property.files = {
  get: function () {
    return Array.prototype.filter.call(this.$imagePreviewContainer.childNodes, function (e) {
      return e._azar_extendTags && e._azar_extendTags.filepreview;
    }).map(function (e) {
      return e.data;
    });
  }
};
MediaInput.property.images = {
  get: function () {
    return Array.prototype.filter.call(this.$imagePreviewContainer.childNodes, function (e) {
      return e._azar_extendTags && e._azar_extendTags.imagepreview;
    }).map(function (e) {
      return e.data;
    });
  }
}; // MediaInput.property

MediaInput.property.plugins = {
  set: function (value) {
    this.sync = this.sync.then(this._dettachPlugins.bind(this, this._plugins));

    if (value) {
      if (!(value instanceof Array)) value = [value];
      this._plugins = value;
      this.addClass('has-plugin');
    } else {
      //remove plugin
      this.sync.then(this._dettachPlugins.bind(this));
      this._plugins = null;
      this.removeClass('has-plugin');
    }

    this.sync = this.sync.then(this._attachPlugins.bind(this, this._plugins));
  },
  get: function () {
    return this._plugins || null;
  }
};

MediaInput.prototype.appendText = function (text) {
  var lastBr = null;

  if (this.$editor.childNodes && this.$editor.childNodes.length > 0 && this.$editor.childNodes[this.$editor.childNodes.length - 1].tagName && this.$editor.childNodes[this.$editor.childNodes.length - 1].tagName.toLowerCase() == 'br') {
    lastBr = this.$editor.childNodes[this.$editor.childNodes.length - 1];
  }

  var lines = text.split(/\r?\n/);

  if (lastBr) {
    for (var i = 0; i < lines.length; ++i) {
      if (i > 0) this.$editor.addChild(_('br'));

      var e = _({
        text: lines[i]
      });

      this.$editor.addChild(e);
    }
  } else {
    for (var i = 0; i < lines.length; ++i) {
      if (i > 0) this.$editor.addChildBefore(_('br'), lastBr);

      var e = _({
        text: lines[i]
      });
    }

    this.$editor.addChildBefore(e, lastBr);
  }

  (0, _Text.setSelectionRange)(this.$editor, Infinity);
};

MediaInput.prototype._attachPlugins = function (plugins) {
  if (!plugins) return;
  var self = this;
  plugins.forEach(function (plugin) {
    var oldContent = null;

    var $button = _('button').addTo(self.$toolLeftCtn).on('click', function () {
      if (self._lastActivePlugin == plugin) return;
      self.releasePlugin();
      self._lastActivePlugin = plugin;
      self.$pluginContentCtn.removeClass('blur');
      self.$pluginContentCtn.clearChild();

      if (plugin.getContent) {
        var newContent = plugin.getContent(self, _, $, self.$pluginContentCtn, oldContent);
        oldContent = newContent;
        self.$pluginContentCtn.addChild(newContent);
      }

      var buttonBound = $button.getBoundingClientRect();
      var rootBound = self.$pluginContentCtn.parentNode.getBoundingClientRect();
      self.$pluginContentCtn.addStyle({
        left: buttonBound.left + buttonBound.width / 2 - rootBound.left + 'px',
        bottom: rootBound.bottom - buttonBound.top + 'px'
      });
      if (plugin.onActive) plugin.onActive(self);
      setTimeout(function () {
        var outListener = function (event) {
          if (_EventEmitter.default.hitElement(self.$pluginContentCtn, event)) {} else if (self._lastActivePlugin == plugin) {
            var prevented = true;
            if (plugin.onBlur) plugin.onBlur({
              preventDefault: function () {
                prevented = false;
              }
            });

            if (prevented) {
              self.releasePlugin();
              $(document.body).off('click', outListener);
            }
          } else {
            $(document.body).off('click', outListener);
          }
        };

        $(document.body).on('click', outListener);
        self.once('releaseplugin', function (ev) {
          if (ev.plugin == plugin) {
            $(document.body).off('click', outListener);
          }
        });
      }, 100);
    });

    var btnInners = plugin.getTriggerInner(self, _, $, $button);
    if (!(btnInners instanceof Array)) btnInners = [btnInners];
    btnInners.forEach(function (e) {
      if (typeof e == 'string') {
        e = _({
          text: e
        });
      }

      $button.addChild(e);
    });
    if (plugin.onAttached) plugin.onAttached(self);
  }); //todo

  return true;
};

MediaInput.prototype.releasePlugin = function () {
  if (this._lastActivePlugin) {
    var plugin = this._lastActivePlugin;
    plugin.onDeactived && plugin.onDeactived(self);
    this.$pluginContentCtn.addClass('blur');
    this.emit('releaseplugin', {
      target: this,
      plugin: plugin
    }, this);
    this._lastActivePlugin = null;
  }
};

MediaInput.prototype._dettachPlugins = function (plugins) {
  if (!plugins) return;
  var self = this;
  plugins.forEach(function (plugin) {
    if (plugin.onAttached) plugin.onAttached(self);
  }); //todo

  this._lastActivePlugin = null;
  return true;
};

MediaInput.prototype.focus = function () {
  this.$editor.focus();
  (0, _Text.setSelectionRange)(this.$editor, Infinity);
};

MediaInput.prototype.clear = function () {
  Array.prototype.filter.call(this.$imagePreviewContainer.childNodes, function (e) {
    return e._azar_extendTags && e._azar_extendTags.imagepreview;
  }).forEach(function (e) {
    e.selfRemove();
  });
  Array.prototype.filter.call(this.$imagePreviewContainer.childNodes, function (e) {
    return e._azar_extendTags && e._azar_extendTags.filepreview;
  }).forEach(function (e) {
    return e.selfRemove();
  });
  this.$editor.innerHTML = "";
  this.emit('update', {
    target: this
  }, this);
};

MediaInput.prototype.escapeSpace = function (s) {
  return s.replace(/\s/g, '&nbsp');
};

MediaInput.prototype.unescapeSpace = function (s) {
  return s.replace(/&nbsp/g, ' ');
};

MediaInput.prototype.getTextFromElements = function (element) {
  return (0, _Text.getTextIn)(element); // var self = this;
  // function visit(e, prevE) {
  //     var ac = '';
  //     var isNewLine = false;
  //     if (prevE && prevE.nodeType != Node.TEXT_NODE) {
  //         if (prevE.tagName && prevE.tagName.toLowerCase() == 'br') {
  //             isNewLine = true;
  //         }
  //         else if (Element.prototype.getComputedStyleValue.call(prevE, 'display') == 'block') {
  //             isNewLine = true;
  //         }
  //     }
  //     if (e.nodeType == Node.TEXT_NODE) {
  //         if (isNewLine) ac += '\n';
  //         ac += e.data;
  //     }
  //     else {
  //         var lastE = undefined;
  //         for (var i = 0; i < e.childNodes.length; ++i) {
  //             ac += visit(e.childNodes[i], i > 0 ? e.childNodes[i - 1] : null);
  //         }
  //     }
  //     return ac;
  // }
  // return visit(element);
};

MediaInput.prototype.getElementsFromText = function (text) {
  var newElements = text.split('\n').map(function (text) {
    return document.createTextNode(text);
  }).reduce(function (ac, cr, i, arr) {
    if (i > 0) ac.push(_('br'));
    ac.push(cr);
    return ac;
  }, []);
  return newElements;
}; // MediaInput.prototype.textOnly = function(e) {
//     if (e.nodeType == Node.TEXT_NODE) return e.textContent;
//     if (!e.tagName) return '';
//     if (e.tagName.toLowerCase() == 'br') return '\n';
//     return ($(e).getComputedStyleValue('display') == 'block' ? '\n' : '') + Array.prototype.map.call(e.childNodes, this.textOnly.bind(this)).join('')
// };


MediaInput.prototype.makeTextOnly = function () {
  var self = this;
  var editor = this.$editor;
  Array.apply(null, this.$editor.childNodes).forEach(function (e) {
    e = $(e);
    if (e.nodeType == Node.TEXT_NODE) return;

    if (e.tagName) {
      var tagName = e.tagName.toLowerCase();
      if (tagName == 'br') return;

      if (tagName.match(/img|script|svg|button|iframe|hr|video|canvas/)) {
        e.selfRemove(e);
      }

      if (tagName.match(/select|input|textarea/)) {
        e.selfReplace(document.createTextNode(e.value));
        return;
      }

      var newElements = self.getElementsFromText(self.getTextFromElements(e));
      var lastElement;

      if (e.getComputedStyleValue('display') == 'block') {
        lastElement = _('br');
      } else {
        lastElement = newElements.pop();
      }

      e.selfReplace(lastElement);
      newElements.forEach(function (nE) {
        editor.addChildBefore(nE, lastElement);
      });
    }
  });
  this.emit('update', {
    target: editor
  }, this);
};

MediaInput.eventHandler = {};

MediaInput.eventHandler.keydown = function (event) {
  if (event.key == "Enter") {
    if (!event.ctrlKey && !event.altKey && !event.shiftKey) {
      event.preventDefault();
      this.eventHandler.send(event);
      this.snapText();
    }
  }

  if (event.ctrlKey && event.key == 'z') {
    event.preventDefault();
    this.undoText();
  }

  if (event.ctrlKey && event.key == 'x') {
    setTimeout(this.snapText.bind(this), 100);
  }

  setTimeout(this.emit.bind(this, 'update', event, this), 1);
};

MediaInput.eventHandler.send = function (event) {
  if (this.images.length == 0 && this.text.trim().length == 0 && this.files.length == 0) {
    return;
  }

  this.emit('send', event, this);
  this.snapText();
};

MediaInput.eventHandler.clickAddImage = function (event) {
  openFileDialog({
    accept: 'image/*',
    multiple: true
  }).then(function (files) {
    if (!files) return;
    files.map(function (file) {
      var url = (window.URL || window.webkitURL).createObjectURL(file);
      this.addImage(url, file.name, {
        file: file,
        name: file.name,
        url: url
      });
      this.emit('update', event, this);
    }.bind(this));
  }.bind(this));
};

MediaInput.eventHandler.clickAddFile = function (event) {
  openFileDialog({
    multiple: true
  }).then(function (files) {
    if (!files) return;
    files.map(function (file) {
      var url = (window.URL || window.webkitURL).createObjectURL(file);

      if (file.type.match(/^image/)) {
        this.addImage(url, file.name, {
          file: file,
          name: file.name,
          url: url
        });
      } else {
        var p = file.name.split('.');
        var ext = p.length > 1 ? p[p.length - 1] : '';
        this.addFile(url, ext.toUpperCase(), file.name, {
          file: file,
          name: file.name,
          url: url
        });
      }
    }.bind(this));
    this.emit('update', event, this);
  }.bind(this));
};

MediaInput.eventHandler.dragOver = function (event) {
  event.preventDefault();
  this._lastDragOver = new Date().getTime();
  var currentDragOver = this._lastDragOver;

  if (!this.dragOver) {
    this.dragOver = true;
    this.addClass('dragover');
    this.emit('update', event, this);
  }

  setTimeout(function () {
    this._waitDragFileOut;

    if (this._lastDragOver == currentDragOver) {
      this.removeClass('dragover');
      this.dragOver = false;
      this.emit('update', event, this);
    }
  }.bind(this), 200);
};

MediaInput.eventHandler.drop = function (event) {
  event.preventDefault();

  if (event.dataTransfer.items) {
    for (var i = 0; i < event.dataTransfer.items.length; i++) {
      if (event.dataTransfer.items[i].kind === 'file') {
        var file = event.dataTransfer.items[i].getAsFile();

        if (!file.type && file.size % 4096 == 0) {//todo: folder
        } else {
          this.addSystemFile(file);
          this.emit('update', event, this);
        }
      }
    }
  } else {
    for (var i = 0; i < event.dataTransfer.files.length; i++) {
      var file = event.dataTransfer.files[i];

      if (!file.type && file.size % 4096 == 0) {} else {
        this.addSystemFile(file);
        this.emit('update', event, this);
      }
    }
  }
};

MediaInput.prototype.addSystemFile = function (file) {
  var url = (window.URL || window.webkitURL).createObjectURL(file);

  if (file.type.match(/^image/)) {
    this.addImage(url, file.name, {
      file: file,
      name: file.name,
      url: url
    });
  } else {
    var p = file.name.split('.');
    var ext = p.length > 1 ? p[p.length - 1] : '';
    this.addFile(url, ext.toUpperCase(), file.name, {
      file: file,
      name: file.name,
      url: url
    });
  }
};

MediaInput.eventHandler.paste = function (event) {
  var pasteData = event.clipboardData || window.clipboardData;
  var beforePasteElement = [];
  var self = this;

  function visit(e, ac) {
    ac.push(e);

    if (e.childNodes) {
      for (var i = 0; i < e.childNodes.length; ++i) {
        visit(e.childNodes[i], ac);
      }
    }
  }

  visit(this.$editor, beforePasteElement);

  function relocalCursor() {
    var afterPasteElement = [];
    visit(self.$editor, afterPasteElement);
    var diffElts = afterPasteElement.filter(function (e) {
      return beforePasteElement.indexOf(e) < 0;
    });

    if (diffElts.length > 0) {
      var last = diffElts.pop();

      if (last.nodeType == Node.TEXT_NODE) {
        var range = document.createRange();
        range.selectNodeContents(last);
        range.setStart(last, last.data.length);
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      } else {
        (0, _Text.setSelectionRange)(last, Infinity);
      }
    }
  }
  /**Safari bug */


  if (pasteData && pasteData.items) {
    var items = pasteData.items;
    var isAddImage = false;

    for (var i = 0; i < items.length; i++) {
      if (items[i].type.indexOf('image') !== -1) {
        var blob = items[i].getAsFile();
        var URLObj = window.URL || window.webkitURL;
        var source = URLObj.createObjectURL(blob);
        var file = (0, _file.blobToFile)(blob);
        var buffer = (0, _file.blobToArrayBuffer)(blob).then(function (arrayBuffer) {
          this.addImage(source, 'Clipboard', {
            file: blob,
            name: null,
            url: source,
            blob: blob,
            arrayBuffer: arrayBuffer
          });
          this.emit('update', event, this);
        }.bind(this));
        isAddImage = true;
        this.emit('update', event, this);
      }
    }

    if (isAddImage) event.preventDefault();
    requestAnimationFrame(function () {
      self.makeTextOnly();
      relocalCursor();
    });
  } else {
    requestAnimationFrame(function () {
      var img = $('img', this.$editor, function (img) {
        if (img) {
          img = $(img);
          var source = img.getAttribute('src');
          img.selfRemove();

          _Dom.default.imageToCanvas(img).then(function (canvas) {
            var dataURI = canvas.toDataURL();
            var blob = (0, _file.dataURItoBlob)(dataURI);
            var file = (0, _file.blobToFile)(blob);
            var buffer = (0, _file.blobToArrayBuffer)(blob).then(function (arrayBuffer) {
              this.addImage(source, 'Clipboard', {
                dataURI: dataURI,
                file: blob,
                name: null,
                url: source,
                blob: blob,
                arrayBuffer: arrayBuffer
              });
              this.emit('update', event, this);
            }.bind(this));
          }.bind(this), function (e) {}).catch(function (e) {});
        }
      }.bind(this));
      this.makeTextOnly();
      relocalCursor();
    }.bind(this));
  }
};

MediaInput.prototype.undoText = function () {
  if (this.snapDataHead <= 1) return;
  this.snapDataHead--;
  if (this.snapDataHead <= 0) return;
  var newText = this.snapData[this.snapDataHead - 1];
  this.text = newText;
  (0, _Text.setSelectionRange)(this.$editor, Infinity);
};

MediaInput.prototype.redoText = function () {
  if (this.snapData.length <= this.snapDataHead) return;
  this.snapDataHead++;
  var newText = this.snapData[this.snapDataHead - 1];
  var currentText = this.text;
  this.text = newText;
  (0, _Text.setSelectionRange)(this.$editor, Infinity);
};

MediaInput.prototype.snapText = function () {
  while (this.snapData.length > this.snapDataHead && this.snapData.length > 0) this.snapData.pop();

  var oldText = this.snapData[this.snapDataHead - 1];
  var newText = this.text;
  if (newText == oldText) return;
  this.snapData.push(this.text);
  this.snapDataHead++;
};

function ImagePreview() {
  var res = _({
    extendEvent: 'pressremove',
    class: ['vmedia-media-input-imagepreview', 'vmedia-no-select'],
    child: ['img', 'times-ico']
  });

  res.$img = $('img', res);
  res.$timesIco = $('times-ico', res);
  res.$timesIco.on('click', function (event) {
    res.emit('pressremove', event, res);
  });

  _OOP.default.drillProperty(res, res.$img, 'imgSrc', 'src');

  return res;
}

;

function FilePreview() {
  var res = _({
    extendEvent: 'pressremove',
    class: ['vmedia-media-input-filepreview', 'vmedia-no-select'],
    child: ['attachment-ico', 'times-ico']
  });

  res.$img = $('attachment-ico', res);

  _OOP.default.drillProperty(res, res.$img, 'ext');

  res.$timesIco = $('times-ico', res);
  res.$timesIco.on('click', function (event) {
    res.emit('pressremove', event, res);
  });
  return res;
}

;
MediACore.creator.mediainput = MediaInput;
MediACore.creator.imagepreview = ImagePreview;
MediACore.creator.filepreview = FilePreview;

MediACore.creator['send-ico'] = function () {
  return _(['<svg class="send" width="100" height="100" version="1.1" viewBox="0 0 26.458 26.458">', '    <g transform="translate(0 -270.54)">', '        <path d="m0.64298 272.44 3.1712 9.5402 22.152 1.7742-22.152 1.7482-3.1712 9.4749 25.323-11.223z" />', '    </g>', '</svg>'].join(''));
};

MediACore.creator['add-file-ico'] = function () {
  return _(['<svg class="add-file" width="100" height="100" version="1.1" viewBox="0 0 26.458 26.458" xmlns="http://www.w3.org/2000/svg">', '    <g transform="translate(0 -270.54)">', '        <path d="m4.2431 295.69c-0.74006-0.0759-1.4136-0.33772-2.0047-0.77942-0.19965-0.14919-0.60549-0.55475-0.75233-0.75182-0.45099-0.60524-0.7154-1.2913-0.77699-2.016-0.01275-0.15007-0.01628-2.6111-0.01252-8.7468 0.0049-8.0504 0.0068-8.5472 0.03338-8.6986 0.0883-0.50391 0.22692-0.91024 0.44705-1.3104 0.52794-0.95973 1.452-1.6645 2.5119-1.9158 0.44319-0.10508 0.12729-0.0972 4.1445-0.10308 2.5538-4e-3 3.6864-1e-4 3.7795 0.0121 0.38853 0.0508 0.80777 0.24687 1.2709 0.59434 0.44102 0.33085 0.68272 0.55272 1.7227 1.5813 0.46507 0.45998 1.2812 1.2664 1.8136 1.7921 0.96172 0.94958 1.3847 1.3824 1.696 1.7354 0.61073 0.69257 0.92 1.2063 1.0441 1.7344 0.02613 0.11122 0.02875 0.28598 0.03409 2.2731 0.0047 1.7451 0.0018 2.1574-0.01502 2.178-0.01424 0.0174-0.10685 0.0394-0.2936 0.0699-0.45695 0.0745-1.0078 0.22363-1.4356 0.38862-0.10025 0.0387-0.1888 0.0663-0.19678 0.0613-0.0085-5e-3 -0.01461-0.7983-0.01475-1.9156-2.09e-4 -1.6438-0.0036-1.9208-0.0245-2.0096-0.06972-0.29578-0.28642-0.50043-0.63767-0.60222-0.32942-0.0955-0.31104-0.0947-2.4299-0.10482l-1.9437-9e-3 -0.12495-0.0442c-0.25474-0.0901-0.45899-0.26526-0.5666-0.48578-0.10853-0.22238-0.10356-0.127-0.10407-1.9994-4.63e-4 -1.7153-0.01031-2.1544-0.05446-2.4288-0.06935-0.43095-0.22893-0.69171-0.5027-0.82138l-0.10904-0.0516h-3.1807c-3.4262 0-3.27-4e-3 -3.5482 0.0835-0.68034 0.21325-1.1718 0.754-1.3329 1.4666l-0.0345 0.15261v8.5059c0 8.1045 0.0014 8.5125 0.02871 8.6468 0.08088 0.39719 0.25808 0.72858 0.53956 1.0091 0.28082 0.27984 0.576 0.44186 0.98191 0.53896 0.11389 0.0273 0.36156 0.0293 4.5294 0.0374l4.409 9e-3 0.02019 0.0402c0.0111 0.0221 0.07695 0.15943 0.14632 0.30521s0.17519 0.3518 0.23515 0.45783c0.14341 0.25357 0.43703 0.69284 0.61725 0.92343 0.0793 0.10148 0.14077 0.19003 0.13659 0.19679-0.0073 0.0118-9.9306 0.0132-10.046 1e-3z" />', '        <path transform="matrix(.26458 0 0 .26458 0 270.54)" d="m72.469 65.742v7.4062h-7.4062v7.2852h7.4062v7.2812h7.2793v-7.2812h7.3535v-7.2852h-7.3535v-7.4062zm24.948 11.119a21.371 21.371 0 0 1-21.371 21.371 21.371 21.371 0 0 1-21.371-21.371 21.371 21.371 0 0 1 21.371-21.371 21.371 21.371 0 0 1 21.371 21.371z" style="fill-rule:evenodd;" />', '        <path d="m17.256 283.76 1.921-0.47607-0.04725-4.2884c0-0.50159-0.29516-1.2441-1.0789-2.0168l-4.6989-4.6324c-0.73814-0.72769-1.5947-0.97084-2.1519-0.97084h-7.0235c-2.1533 0.0144-3.4601 2.6226-3.4778 3.4778v17.284c0 2.121 2.2409 3.5346 3.5346 3.5346h10.058l-1.1146-1.9305h-8.6658c-1.1271 0-1.8503-1.1115-1.8503-1.8503v-16.867c0-1.0721 1.1373-1.6977 1.6977-1.6977h6.2175c0.43142 0 0.8103 0.28958 0.8103 1.1742v3.714c0 0.24768 0.36442 0.90967 0.90968 0.90967h3.2537c1.2453 0 1.6905 0.32876 1.6905 1.1613z"  />', '    </g>', '</svg>'].join(''));
};

MediACore.creator['add-image-ico'] = function () {
  return _(['<svg class="add-image" width="100" height="100" version="1.1" viewBox="0 0 26.458 26.458" xmlns="http://www.w3.org/2000/svg" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="absol/src/HTML5/Elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">', '    <g transform="translate(0 -270.54)">', '        <path d="m24.73 288.69a5.9808 5.9808 0 0 1-5.9808 5.9808 5.9808 5.9808 0 0 1-5.9808-5.9808 5.9808 5.9808 0 0 1 5.9808-5.9808 5.9808 5.9808 0 0 1 5.9808 5.9808zm1.503-0.037a7.5843 7.5843 0 0 1-7.5843 7.5843 7.5843 7.5843 0 0 1-7.5843-7.5843 7.5843 7.5843 0 0 1 7.5843-7.5843 7.5843 7.5843 0 0 1 7.5843 7.5843z" style="fill-rule:evenodd;fill:#414141"/>', '        <path d="m17.869 284.42v3.4127h-3.4081v1.6066h3.4081v3.438h1.6061v-3.438h3.4432v-1.6066h-3.4432v-3.4127z" style="fill-rule:evenodd;fill:#414141"/>', '        <path d="m24.614 281.39v-6.1305c0-1.6957-1.2841-2.6602-2.6602-2.6602h-18.412c-1.4547 0-2.7249 1.0223-2.7249 2.7249v14.986c0 1.2346 0.99768 2.6028 2.586 2.586h6.9542c-0.36184-0.63963-0.51495-1.0286-0.69323-1.6506h-6.4562c-0.29938 0-0.72246-0.40379-0.72246-0.72247v-1.8082l6.0428-6.7569 2.0296 2.0129 0.9605-1.3029-2.9734-3.1488-5.9885 6.7736v-11.426c0-0.24935 0.30766-0.63476 0.63476-0.63476h18.934c0.3592 0 0.84357 0.19284 0.84357 0.84357v5.2285c0.61147 0.22444 1.1564 0.59412 1.6454 1.0858z" style="fill:#414141"/>', '        <circle cx="17.869" cy="277.61" r="1.6891" style="fill-rule:evenodd;fill:#414141"/>', '    </g>', '</svg>'].join(''));
};

MediACore.creator['attachment-ico'] = function () {
  return _(['<svg class="attachment" width="1024" height="1024"  version="1.1" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" >', '    <path d="M145.6 0C100.8 0 64 35.2 64 80v862.4C64 987.2 100.8 1024 145.6 1024h732.8c44.8 0 81.6-36.8 81.6-81.6V324.8L657.6 0h-512z" fill="#8199AF"/>', '    <path d="M960 326.4v16H755.2s-100.8-20.8-99.2-108.8c0 0 4.8 92.8 97.6 92.8H960z" fill="#617F9B"/>', '    <path d="M657.6 0v233.6c0 25.6 17.6 92.8 97.6 92.8H960L657.6 0z" fill="#fff"/>', '    <path d="m491.77 770.31c17.6-19.2 17.6-48 0-67.2s-48-17.6-65.6 0l-147.2 147.2c-17.6 17.6-17.6 48 0 65.6s48 19.2 65.6 0l91.2-89.6c4.8-4.8 4.8-12.8 0-17.6s-14.4-6.4-19.2 0l-57.6 56c-8 8-19.2 8-27.2 0s-8-20.8 0-28.8l56-56c20.8-20.8 54.4-20.8 75.2 0s20.8 54.4 0 75.2l-89.6 89.6c-33.6 33.6-88 33.6-123.2 0-33.6-33.6-33.6-88 0-121.6l147.2-147.2c33.6-33.6 89.6-33.6 123.2 0s33.6 88 0 121.6l-14.4 14.4c-1.6-14.4-6.4-28.8-16-41.6z" style="fill:#fff"/>', '    <path d="m130.09 23.864h504.75v182.93h-545.65v-140.08c0.34155-16.845 13.608-42.414 40.9-42.847z" style="fill-opacity:.29648;fill-rule:evenodd;fill:#fff"/>', '</svg>'].join(''));
};

MediACore.creator['attachment-ico'].property = {
  ext: {
    set: function (value) {
      value = value || '';

      if (this.$ext) {
        this.$ext.selfRemove();
      }

      this.$ext = _Svg.default.ShareInstance._('<text text-anchor="middle" x="321.39" y="170" font-size="145.76" style="fill:white;" >' + value + '</text>').addTo(this);
    },
    get: function () {
      return this._ext || '';
    }
  }
};

MediACore.creator['times-ico'] = function () {
  return _(['<svg class="times" width="100" height="100" version="1.1" viewBox="0 0 26.458 26.458" xmlns="http://www.w3.org/2000/svg">', '    <g transform="translate(0 -270.54)">', '        <path d="m7.7013 276.49 5.4832 5.4832 5.5494-5.5494 1.7874 1.7874-5.5291 5.5291 5.4957 5.4957-1.754 1.754-5.5124-5.5124-5.5542 5.5542-1.7623-1.7623 5.5375-5.5375-5.5208-5.5208zm17.103 7.3351a11.558 11.558 0 0 1-11.558 11.558 11.558 11.558 0 0 1-11.558-11.558 11.558 11.558 0 0 1 11.558-11.558 11.558 11.558 0 0 1 11.558 11.558z" style="fill-rule:evenodd;"/>', '    </g>'].join(''));
};

MediACore.creator['download-ico'] = function () {
  return _(['<svg class="download" width="100mm" height="100mm" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">', '    <g transform="translate(0,-197)">', '        <path d="m44.888 209.14h13.982c1.1087 0.0459 2.2328 0.74137 2.317 2.3612v23.694h13.622c1.9742-0.18801 3.004 2.6244 1.9175 4.1118l-23.469 23.918c-0.876 0.77477-1.9993 0.77232-2.9362 0l-23.559-24.009c-0.86532-1.0422 0.11658-4.1953 2.3821-4.2047h13.268v-22.939c-0.08167-1.1772 0.78292-2.9507 2.4768-2.9312z" style="fill:#00c3e5"/>', '        <path d="m86.97 276.99a3.5027 3.5696 0 0 1-3.5027 3.5696 3.5027 3.5696 0 0 1-3.5027-3.5696 3.5027 3.5696 0 0 1 3.5027-3.5696 3.5027 3.5696 0 0 1 3.5027 3.5696zm-12.768 0a3.5027 3.5696 0 0 1-3.5027 3.5696 3.5027 3.5696 0 0 1-3.5027-3.5696 3.5027 3.5696 0 0 1 3.5027-3.5696 3.5027 3.5696 0 0 1 3.5027 3.5696zm-60.003-16.135h24.609c9.1206 13.508 17.573 12.942 26.609 0h23.839c2.8529 5e-3 3.5087 2.3205 3.4679 3.8227v18.953c0.04867 1.3083-1.5145 2.9901-2.7505 2.9832h-76.253c-1.049 0.0441-2.6554-1.4851-2.6306-3.1451l-1.56e-4 -18.792c0.0024-1.3549 0.50958-3.7927 3.1091-3.8227z" style="fill-rule:evenodd;fill:#00c3e5"/>', '    </g>', '</svg>'].join(''));
};

MediACore.creator['plus-ico'] = function () {
  return _('<svg class="_7oal" height="24" width="24" viewBox="0 0 24 24"><g fill="none" fill-rule="evenodd"><polygon points="-6,30 30,30 30,-6 -6,-6 "></polygon><path d="m18,11l-5,0l0,-5c0,-0.552 -0.448,-1 -1,-1c-0.5525,0 -1,0.448 -1,1l0,5l-5,0c-0.5525,0 -1,0.448 -1,1c0,0.552 0.4475,1 1,1l5,0l0,5c0,0.552 0.4475,1 1,1c0.552,0 1,-0.448 1,-1l0,-5l5,0c0.552,0 1,-0.448 1,-1c0,-0.552 -0.448,-1 -1,-1m-6,13c-6.6275,0 -12,-5.3725 -12,-12c0,-6.6275 5.3725,-12 12,-12c6.627,0 12,5.3725 12,12c0,6.6275 -5.373,12 -12,12" ></path></g></svg>');
};

_ACore.default.install(MediaInput);

var _default = MediaInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/AppPattern/CMDRunner.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/AppPattern/CMDRunner.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function CMDRunner(_this, commands) {
  this._this = _this;
  this.commands = {};
  this.assign(commands);
}

CMDRunner.prototype.has = function (cmdName) {
  return !!this.commands[cmdName];
};

CMDRunner.prototype.add = function (cmdName, handler) {
  this.commands[cmdName] = handler;
  return this;
};

CMDRunner.prototype.remove = function (cmdName) {
  delete this.commands[cmdName];
  return this;
};

CMDRunner.prototype.assign = function (obj) {
  for (var cmdName in obj) {
    if (typeof obj[cmdName] == 'function') {
      this.add(cmdName, obj[cmdName]);
    }
  }
};

CMDRunner.prototype.invoke = function () {
  if (this.commands[arguments[0]]) {
    var args = Array.prototype.slice.call(arguments, 1);
    return this.commands[arguments[0]].apply(this._this, args);
  } else {
    throw new Error('No command: ' + arguments[0]);
  }
};

var _default = CMDRunner;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/Input/keyboard.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/Input/keyboard.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFnKey = isFnKey;
exports.isSpaceKey = isSpaceKey;
exports.isCtrlKey = isCtrlKey;
exports.isAltKey = isAltKey;
exports.isShiftKey = isShiftKey;
exports.isMetaKey = isMetaKey;
exports.normalizeKeyBindingIdent = normalizeKeyBindingIdent;
exports.keyboardEventToKeyBindingIdent = keyboardEventToKeyBindingIdent;

function isFnKey(name) {
  return name.match(/^[fF]([2-9]|(1([0-2]?)))$/);
}

function isSpaceKey(name) {
  return name === ' ' || name.match(/^[sS]pace$/);
}

function isCtrlKey(name) {
  return name.match(/(^([cC]ontrol)|ctrl)$/);
}

function isAltKey(name) {
  return name.match(/^[aA]lt$/);
}

function isShiftKey(name) {
  return name.match(/^[sS]hift$/);
}

function isMetaKey(name) {
  return name.toLowerCase().match(/^(command|windows|meta)$/);
}
/***
 *
 * @param {string} text
 * @return {string}
 */


function normalizeKeyBindingIdent(text) {
  var keys = text.trim().toLowerCase().split(/[-+\s_.]+/).filter(function (w) {
    return w.length > 0;
  });
  var values = {
    meta: 1,
    ctrl: 2,
    alt: 3,
    shift: 4
  };
  keys.sort(function (a, b) {
    var va, vb;
    va = values[a] || 100;
    vb = values[b] || 100;
    return va - vb;
  });
  return keys.join('-');
}
/***
 *
 * @param {KeyboardEvent} event
 * @return {string}
 */


function keyboardEventToKeyBindingIdent(event) {
  var keys = [];

  if (event.metaKey) {
    keys.push('meta');
  }

  if (event.ctrlKey) keys.push('ctrl');
  if (event.altKey) keys.push('alt');
  if (event.shiftKey) keys.push('shift');

  if (isSpaceKey(event.key)) {
    keys.push('space');
  } else if (isFnKey(event.key)) {
    keys.push(event.key.toLowerCase());
  } else if (!isMetaKey(event.key) && !isAltKey(event.key) && !isCtrlKey(event.key) && !isShiftKey(event.key)) keys.push(event.key.toLowerCase());

  return keys.join('-');
}
return module.exports;
};

moduleFactories["node_modules/absol/src/Network/XHR.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/Network/XHR.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var XHR = {};

XHR.makeHttpObject = function () {
  try {
    return new XMLHttpRequest();
  } catch (error) {}

  try {
    return new ActiveXObject("Msxml2.XMLHTTP");
  } catch (error) {}

  try {
    return new ActiveXObject("Microsoft.XMLHTTP");
  } catch (error) {}

  throw new Error("Could not create HTTP request object.");
};
/***
 * 
 * @param {String} url
 * @param {String} body
 * @param {String} responseType
 * @param {Function} success
 * @param {Function} failure
 * @returns {Promise}
 */


XHR.getRequest = function (url, props, success, failure) {
  return new Promise(function (rs, rj) {
    var request = XHR.makeHttpObject();
    request.open("GET", url, true);
    if (typeof props == 'string') request.responseType = props || '';else if (props && typeof props == 'object') {
      Object.assign(request, props);
    }
    request.send(null);

    request.onreadystatechange = function () {
      if (request.readyState == 4) {
        if (request.status == 200) {
          var response = request.response;
          success && success(response);
          rs(response);
        } else {
          failure && failure(request.status, request.statusText);
          rj(request.status);
        }
      }
    };

    request.onerror = function () {
      failure && failure(request.status, request.statusText);
      rj(new Error(request.status + request.statusText));
    };
  });
};

XHR.postRepquest = function (url, payload, props, headers, success, failure) {
  return new Promise(function (rs, rj) {
    var method = "POST";
    var shouldBeAsync = true;
    var request = XHR.makeHttpObject();

    request.onreadystatechange = function () {
      if (request.readyState == 4) {
        if (request.status == 200) {
          success && success(request.response);
          rs(request.response);
        } else if (failure) {
          failure && failure(request.status, request.statusText);
          rj({
            status: request.status,
            statusText: request.statusText
          });
        }
      }
    };

    request.onerror = function () {
      failure && failure(request.status, request.statusText);
      rj(new Error(request.status + request.statusText));
    };

    request.open(method, url, shouldBeAsync);
    if (typeof props == 'string') request.responseType = props || '';else if (props && typeof props == 'object') {
      Object.assign(request, props);
    }
    headers = headers || {};
    headers["Content-Type"] = headers["Content-Type"] || "application/json;charset=UTF-8";
    Object.keys(headers).forEach(function (key) {
      request.setRequestHeader(key, headers[key]);
    });
    request.send(payload);
  });
};

XHR.request = function (method, url, props, headers, body, successCallback, failureCallback) {
  return new Promise(function (rs, rj) {
    var shouldBeAsync = true;
    var request = new XMLHttpRequest();

    request.onreadystatechange = function () {
      if (request.readyState == 4) {
        if (request.status == 200) {
          successCallback && successCallback(request.response);
          rs(request.response);
        } else {
          failureCallback && failureCallback(request.status, request.statusText);
          rj({
            status: request.status,
            statusText: request.statusText
          });
        }
      }
    };

    request.onerror = function () {
      var error = new Error("Network Error!");
      if (failureCallback) failureCallback(error);
      rj(error);
    };

    request.open(method, url, shouldBeAsync);
    if (typeof props == 'string') request.responseType = props || '';else if (props && typeof props == 'object') {
      Object.assign(request, props);
    }
    headers = headers || {};
    headers["Content-Type"] = headers["Content-Type"] || "application/json;charset=UTF-8";
    Object.keys(headers).forEach(function (key) {
      request.setRequestHeader(key, headers[key]);
    });
    request.send(body);
  });
};

var _default = XHR;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/MessageInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/MessageInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMessage = parseMessage;
exports.prepareIcon = prepareIcon;
exports.MessageQuote = MessageQuote;
exports.MessageInputPlugin = MessageInputPlugin;
exports.default = exports.MODE_EDIT = exports.MODE_NEW = void 0;

require("../css/messageinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _utils = require("./utils");

var _XHR = _interopRequireDefault(require("absol/src/Network/XHR"));

var _EmojiAnims = _interopRequireDefault(require("./EmojiAnims"));

var _EmojiPicker = _interopRequireDefault(require("./EmojiPicker"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _BrowserDetector = _interopRequireDefault(require("absol/src/Detector/BrowserDetector"));

var _stringGenerate = require("absol/src/String/stringGenerate");

var _CMDRunner = _interopRequireDefault(require("absol/src/AppPattern/CMDRunner"));

var _keyboard = require("absol/src/Input/keyboard");


var _ = _ACore.default._;
var $ = _ACore.default.$;
var $$ = _ACore.default.$$;
/***
 *
 * @typedef {{text:string, desc: string, img?:string, file?:string}|string} MessageInputQuote
 */

var iconCatalogCaches = {};
var MODE_NEW = 0;
exports.MODE_NEW = MODE_NEW;
var MODE_EDIT = 1;
exports.MODE_EDIT = MODE_EDIT;
var isMobile = _BrowserDetector.default.isMobile;
/***
 * @extends AElement
 * @constructor
 */

function MessageInput() {
  this._cmdRunner = new _CMDRunner.default(this);
  this._keyMaps = {};
  this._plugins = [];
  this._mode = MODE_NEW; //edit

  this._editingText = "";
  prepareIcon();
  /**
   * @type {import('./PreInput').default}
   */

  this.$preInput = $('preinput', this);
  this.$preInput.on('change', this.eventHandler.preInputChange).on('keyup', this.eventHandler.preInputKeyUp).on('keydown', this.eventHandler.preInputKeyDown).on('pasteimg', this.eventHandler.preInputPasteImg).on('focus', this.eventHandler.preInputFocus).on('blur', this.eventHandler.preInputBlur); // //every can make size change

  this._imageFiles = [];
  this._files = [];
  this._latBound = {};
  this.$quote = $('messagequote.as-message-input-quote', this).on('pressremove', this.eventHandler.clickQuoteRemoveBtn);
  this.$right = $('.as-message-input-right', this);
  this.$attachmentCtn = $('.as-message-input-attachment-ctn', this);
  this.$emojiBtn = $('.as-message-input-plugin-emoji', this).on('click', this.eventHandler.clickEmojiBtn);
  this.$fileBtn = $('.as-message-input-plugin-file', this).on('click', this.openFileDialog.bind(this));
  this.$attachmentAddBtn = $('.as-message-input-attachment-add-btn', this).on('click', this.openFileDialog.bind(this));
  this.$sendBtn = $('.as-message-input-plugin-send', this).on('click', this.notifySend.bind(this));
  this.$cancelBtn = $('.as-message-input-plugin-cancel', this).on('click', this.notifyCancel.bind(this));
  this.$emojiPickerCtn = _('.as-message-input-external-tools-popup');
  this.$emojiPicker = _('emojipicker').addTo(this.$emojiPickerCtn).on('pick', this.eventHandler.pickEmoji);
  this.$attachhook = _('attachhook').addTo(this).on('error', this.notifySizeChange.bind(this));
  this.on('drop', this.eventHandler.drop).on('dragover', this.eventHandler.dragover);
  this.autoSend = false;
  /***
   *
   * @type {MessageInputQuote|null}
   */

  this.quote = null;
}

MessageInput.MODE_EDIT = MODE_EDIT;
MessageInput.MODE_NEW = MODE_NEW;

MessageInput.iconAssetRoot = function () {
  if (location.hostname.match(/^.+\.absol.cf$/)) return 'https://absol.cf/exticons/vivid';
  return '/vivid_exticons';
}();

MessageInput.tag = 'MessageInput'.toLowerCase();

MessageInput.render = function (data) {
  data = data || {};
  data.iconAssetRoot = data.iconAssetRoot || MessageInput.iconAssetRoot;
  return _({
    attr: {
      'data-icon-asset-root': MessageInput.iconAssetRoot
    },
    class: 'as-message-input',
    extendEvent: ['sendtext', 'sendimage', 'sendfile', 'sendquote', 'cancel', 'change', 'sizechange', 'send', 'useraddfile'],
    child: [{
      class: 'as-message-input-right',
      child: [{
        tag: 'button',
        class: ['as-message-input-plugin-btn', 'as-message-input-plugin-file'],
        child: 'span.mdi.mdi-attachment.mdi-rotate-90'
      }, {
        tag: 'button',
        class: ['as-message-input-plugin-btn', 'as-message-input-plugin-send'],
        child: 'span.mdi.mdi-send'
      }, {
        tag: 'button',
        class: ['as-message-input-plugin-btn', 'as-message-input-plugin-cancel'],
        child: 'span.mdi.mdi-close'
      }]
    }, {
      class: 'as-message-input-pre-ctn',
      child: ['messagequote.as-message-input-quote.as-removable.as-shorten-text', {
        class: 'as-message-input-emoji-btn-ctn',
        child: {
          tag: 'button',
          class: ['as-message-input-plugin-btn', 'as-message-input-plugin-emoji'],
          child: 'span.mdi.mdi-emoticon-happy-outline'
        }
      }, {
        class: ['as-message-input-attachment-ctn', 'as-bscroller'],
        child: [{
          tag: 'button',
          class: 'as-message-input-attachment-add-btn',
          child: ['span.mdi.mdi-arrow-down-bold.as-message-input-attachment-add-btn-drop', {
            tag: 'span',
            class: 'as-message-input-attachment-add-btn-plus',
            child: {
              text: "+"
            }
          }]
        }]
      }, 'preinput.as-message-input-pre.absol-bscroller']
    }]
  });
};

MessageInput.prototype.toggleEmoji = function () {
  if (this.containsClass('as-message-input-show-emoji')) this.closeEmoji();else this.showEmoji();
};

MessageInput.prototype.showEmoji = function () {
  if (this.containsClass('as-message-input-show-emoji')) return;
  var value = this.$preInput.value;
  this._lastInputSelectPosion = this.$preInput.getSelectPosition() || {
    start: value.length,
    end: value.length
  };
  this.addClass('as-message-input-show-emoji');
  this.addChild(this.$emojiPickerCtn);
  var thisMi = this;
  setTimeout(function () {
    $(document.body).on('mousedown', thisMi.eventHandler.mousedownOutEmoji);
  }, 100);
  this.$preInput.focus();
};

MessageInput.prototype.notifyChange = function () {
  this.emit('change', {
    name: 'change',
    target: this
  }, this);

  if (this.autoSend) {
    if (this.files.length > 0 || this.images.length > 0) this.notifySend();
  }
};

MessageInput.prototype.notifySend = function () {
  var eventData = {
    imageRemovePrevented: false,
    fileRemovePrevented: false,
    textRemovePrevented: false,
    quoteRemovePrevented: false,
    target: this,
    files: this.files,
    images: this.images,
    text: this.text
  };

  if (eventData.files.length > 0) {
    this.emit('sendfile', Object.assign(eventData, {
      type: 'sendfile',
      preventDefault: function () {
        this.fileRemovePrevented = true;
      }
    }), this);
  }

  if (eventData.images.length > 0) {
    this.emit('sendimage', Object.assign(eventData, {
      type: 'sendimage',
      preventDefault: function () {
        this.imageRemovePrevented = true;
      }
    }), this);
  }

  if (typeof this.quote === "string" || this.quote) {
    this.emit('sendquote', Object.assign(eventData, {
      type: 'sendquote',
      preventDefault: function () {
        this.quoteRemovePrevented = true;
      }
    }), this);
  }

  if (this.files.length > 0 || eventData.images.length > 0 || eventData.text || typeof this.quote === "string" || this.quote) {
    if (eventData.text) this.$preInput.focus();
    this.emit('send', Object.assign(eventData, {
      type: 'send',
      preventDefault: function () {
        this.imageRemovePrevented = true;
        this.fileRemovePrevented = true;
        this.imageRemovePrevented = true;
        this.quoteRemovePrevented = true;
      }
    }), this);
  }

  if (!eventData.fileRemovePrevented) this.files = [];
  if (!eventData.imageRemovePrevented) this.images = [];
  if (!eventData.textRemovePrevented) this.text = '';
  if (!eventData.quoteRemovePrevented) this.quote = null;
};

MessageInput.prototype.notifyCancel = function () {
  this.emit('cancel', {
    type: 'cancel',
    name: 'send',
    target: this,
    clearAllContent: this.clearAllContent.bind(this)
  }, this);
};

MessageInput.prototype.clearAllContent = function () {
  this.text = '';
  this.quote = null;
  this.files = [];
  this.images = [];
};

MessageInput.prototype.focus = function () {
  var value = this.$preInput.value;
  var range = this.$preInput.getSelectPosition() || {
    start: value.length,
    end: value.length
  };
  this.$preInput.focus();
  this.$preInput.applyData(value, range);
};

MessageInput.prototype.blur = function () {
  this.$preInput.blur();
};

MessageInput.prototype._updateAttachmentClass = function () {
  if (this._imageFiles.length + this._files.length) {
    this.addClass("as-has-attachment");
  } else {
    this.removeClass("as-has-attachment");
  }
};

MessageInput.prototype.addImageFiles = function (imageFiles, urls) {
  var thisMi = this;
  Array.prototype.forEach.call(imageFiles, function (file, index) {
    thisMi._imageFiles.push(file);

    var src;

    if (urls) {
      src = urls[index];
    }

    if (!src) {
      src = URL.createObjectURL(file);
    }

    var itemElt = _({
      class: ['as-message-input-attach-preview', 'as-image'],
      attr: {
        title: file.name
      },
      child: [{
        class: 'as-message-input-attach-preview-image',
        style: {
          backgroundImage: 'url(' + src + ')'
        }
      }, {
        tag: 'button',
        class: 'as-message-input-attach-preview-close-btn',
        child: 'span.mdi.mdi-close',
        attr: {
          title: 'remove'
        },
        on: {
          click: function () {
            thisMi._imageFiles = thisMi._imageFiles.filter(function (it) {
              return it !== file;
            });
            itemElt.remove();

            thisMi._updateAttachmentClass();

            thisMi.notifySizeChange();
            thisMi.notifyChange();
          }
        }
      }, {
        class: 'as-message-input-attach-preview-info',
        child: [{
          class: 'as-message-input-attach-preview-name',
          child: {
            text: file.name
          }
        }, {
          class: 'as-message-input-attach-preview-size',
          child: {
            text: (0, _utils.fileSize2Text)(file.size)
          }
        }]
      }]
    }).addTo(thisMi.$attachmentCtn);

    thisMi.$attachmentCtn.addChildBefore(itemElt, thisMi.$attachmentAddBtn);
  });

  this._updateAttachmentClass();

  this.notifySizeChange();
};

MessageInput.prototype.addFiles = function (files) {
  var thisMi = this;
  Array.prototype.forEach.call(files, function (file, index) {
    thisMi._files.push(file);

    MessageInput.iconSupportAsync.then(function (ExtensionIcons) {
      var src;
      var ext = file.name.split('.').pop().toLowerCase();

      if (ExtensionIcons.indexOf(ext) > 0) {
        src = MessageInput.iconAssetRoot + '/' + ext + '.svg';
      } else {
        src = MessageInput.iconAssetRoot + '/' + 'default' + '.svg';
      }

      var itemElt = _({
        class: ['as-message-input-attach-preview', 'as-file'],
        attr: {
          title: file.name
        },
        child: [{
          tag: 'img',
          class: 'as-message-input-attach-preview-file',
          props: {
            src: src
          }
        }, {
          tag: 'button',
          class: 'as-message-input-attach-preview-close-btn',
          child: 'span.mdi.mdi-close',
          attr: {
            title: 'remove'
          },
          on: {
            click: function () {
              thisMi._files = thisMi._files.filter(function (it) {
                return it !== file;
              });
              itemElt.remove();

              thisMi._updateAttachmentClass();

              thisMi.notifySizeChange();
              thisMi.notifyChange();
            }
          }
        }, {
          class: 'as-message-input-attach-preview-info',
          child: [{
            class: 'as-message-input-attach-preview-name',
            child: {
              text: file.name
            }
          }, {
            class: 'as-message-input-attach-preview-size',
            child: {
              text: (0, _utils.fileSize2Text)(file.size)
            }
          }]
        }]
      });

      thisMi.$attachmentCtn.addChildBefore(itemElt, thisMi.$attachmentAddBtn);
    });
  });

  this._updateAttachmentClass();

  thisMi.notifySizeChange();
};

MessageInput.prototype.closeEmoji = function () {
  if (!this.containsClass('as-message-input-show-emoji')) return;
  this.removeClass('as-message-input-show-emoji');
  this.removeChild(this.$emojiPickerCtn);
  $(document.body).off('mousedown', this.eventHandler.mousedownOutEmoji);
};

MessageInput.prototype.notifyAddFiles = function (files) {
  var event = {
    resolvedAsync: Promise.resolve(files),
    files: files,
    resolve: function (result) {
      if (!result) {
        this.resolvedAsync = Promise.resolve(undefined);
      } else if (result.then) {
        this.resolvedAsync = result;
      } else {
        this.resolvedAsync = Promise.resolve(result);
      }
    }
  };
  this.emit('useraddfile', event);
  return event.resolvedAsync;
};

MessageInput.prototype.openFileDialog = function () {
  var thisMi = this;
  (0, _utils.openFileDialog)({
    multiple: true
  }).then(function (files) {
    if (!thisMi.autoSend) thisMi.$preInput.focus();
    thisMi.notifyAddFiles(files).then(function (files) {
      if (files && files.length > 0) thisMi.handleAddingFileByType(files);
    });
  });
};

MessageInput.prototype.handleAddingFileByType = function (files) {
  if (files.length > 0) {
    var imageFiles = [];
    var otherFiles = [];
    var file;

    for (var i = 0; i < files.length; ++i) {
      file = files[i];

      if (!!file.type && file.type.match && file.type.match(/^image\//)) {
        imageFiles.push(file);
      } else {
        otherFiles.push(file);
      }
    }

    this.addImageFiles(imageFiles);
    this.addFiles(otherFiles);
    this.notifyChange();
  }
};

MessageInput.prototype.notifySizeChange = function () {
  var bound = this.getBoundingClientRect();

  if (this._latBound.width != bound.width || this._latBound.height != bound.height) {
    this._latBound.width = bound.width;
    this._latBound.height = bound.height;
    this.emit('sizechange', {
      name: 'sizechange',
      bound: bound,
      target: this
    }, this);
  }
};

MessageInput.prototype.addPlugin = function (option) {
  var plugin = new this.PluginConstructor(this, option);

  this._plugins.push(plugin);

  this.addStyle('--plugin-buttons-width', this._plugins.length * 45 + 'px');
  return plugin;
};
/***
 *
 * @param {{name?:string, exec:function(_this:MessageInput):void, keyBiding?:string}} option
 */


MessageInput.prototype.addCommand = function (option) {
  option.name = option.name || (0, _stringGenerate.randomIdent)(20);

  this._cmdRunner.add(option.name, option.exec);

  if (option.keyBiding && option.keyBiding.trim) {
    var keyBindingIdent = (0, _keyboard.normalizeKeyBindingIdent)(option.keyBiding);
    this._keyMaps[keyBindingIdent] = option.name;
  }
};

MessageInput.prototype.exeCmd = function (name) {
  var args = Array.prototype.slice.call(arguments);
  args[0] = this;
  args.unshift(name);

  this._cmdRunner.invoke.apply(this._cmdRunner, args);
};

MessageInput.prototype._updateQuote = function () {
  this.$quote.data = this._quote;
  if (this._quote) this.addClass('as-has-quote');else this.removeClass('as-has-quote');
  this.notifySizeChange();
};
/**
 * @type {MessageInput}
 */


MessageInput.eventHandler = {};

MessageInput.eventHandler.preInputChange = function (event) {
  var text = this.$preInput.value;

  if (text.length > 0) {
    this.addClass('as-has-text');
  } else {
    this.removeClass('as-has-text');
  }

  if (text === this._editingText) {
    this.removeClass('as-text-changed');
  } else {
    this.addClass('as-text-changed');
  }

  this.notifySizeChange();
  this.notifyChange();
};

MessageInput.eventHandler.preInputKeyDown = function (event) {
  if (!(event.shiftKey || event.ctrlKey || event.altKey) && event.key === 'Enter') {
    this.notifySend();
    event.preventDefault();
  } else if ((event.shiftKey || event.ctrlKey || event.altKey) && event.key === 'Enter') {
    event.preventDefault();
    var text = this.$preInput.value;
    var selectedPos = this.$preInput.getSelectPosition();
    var newText = text.substr(0, selectedPos.start) + '\n' + text.substr(selectedPos.end);
    this.$preInput.applyData(newText, selectedPos.start + 1);
    this.notifySizeChange();
    this.$preInput.commitChange(newText, selectedPos.start + 1);
  } else if (event.key === "Escape" && this._mode === MODE_EDIT) {
    this.notifyCancel();
    event.preventDefault();
  }

  var keyBindingIdent = (0, _keyboard.keyboardEventToKeyBindingIdent)(event);

  if (this._keyMaps[keyBindingIdent]) {
    event.preventDefault();
    this.exeCmd(this._keyMaps[keyBindingIdent]);
  }

  setTimeout(this.notifySizeChange.bind(this), 1);
};

MessageInput.eventHandler.preInputKeyUp = function (event) {
  var value = this.$preInput.value;
  this._lastInputSelectPosion = this.$preInput.getSelectPosition() || {
    start: value.length,
    end: value.length
  };
  this.notifySizeChange();
};

MessageInput.eventHandler.preInputPasteImg = function (event) {
  if (this._mode == 'edit') return;
  var files = Array.prototype.slice.call(event.imageFiles);
  var urls = event.urls && Array.prototype.slice.call(event.urls);
  this.notifyAddFiles(files).then(function (newFiles) {
    if (!newFiles || newFiles.length === 0) return;
    var newUrls = urls && newFiles.map(function (file) {
      return urls[files.indexOf(file)];
    });
    this.addImageFiles(newFiles, newUrls);
    this.notifyChange();
  }.bind(this));
};

MessageInput.eventHandler.preInputFocus = function () {
  this.addClass('as-focus');
};

MessageInput.eventHandler.preInputBlur = function () {
  this.removeClass('as-focus');
};

MessageInput.eventHandler.clickEmojiBtn = function () {
  this.toggleEmoji();
};

MessageInput.eventHandler.mousedownOutEmoji = function (event) {
  if (_EventEmitter.default.hitElement(this.$emojiPicker, event) || _EventEmitter.default.hitElement(this.$emojiBtn, event)) return;
  this.closeEmoji();
};

MessageInput.eventHandler.pickEmoji = function (event) {
  var text = this.$preInput.value;
  var newText = text.substr(0, this._lastInputSelectPosion.start) + event.key + text.substr(this._lastInputSelectPosion.end);
  var selected = this._lastInputSelectPosion;
  var newOffset = selected.start + event.key.length;
  this._lastInputSelectPosion = {
    start: newOffset,
    end: newOffset
  };
  this.$preInput.focus();
  this.$preInput.applyData(newText, newOffset);
  this.$preInput.commitChange(newText, newOffset);
  this.notifySizeChange();
  this.$preInput.focus(); //older firefox version will be lost focus
  // this.notifyChange();//not need
};

MessageInput.eventHandler.dragover = function (event) {
  event.preventDefault();
  this.addClass('as-drag-hover');
  this.notifySizeChange();
  if (this._hoverTimeout > 0) clearTimeout(this._hoverTimeout);
  var thisMi = this;
  this._hoverTimeout = setTimeout(function () {
    thisMi._hoverTimeout = -1;
    thisMi.removeClass('as-drag-hover');
    thisMi.notifySizeChange();
  }, 200); //todo:
};

MessageInput.eventHandler.drop = function (event) {
  event.preventDefault();
  var files = [];
  var file;

  if (event.dataTransfer.items) {
    for (var i = 0; i < event.dataTransfer.items.length; i++) {
      if (event.dataTransfer.items[i].kind === 'file') {
        file = event.dataTransfer.items[i].getAsFile();

        if (!file.type && file.size % 4096 == 0) {//todo: folder
        } else {
          files.push(file);
        }
      }
    }
  } else {
    for (var i = 0; i < event.dataTransfer.files.length; i++) {
      file = event.dataTransfer.files[i];

      if (!file.type && file.size % 4096 == 0) {} else {
        files.push(file);
      }
    }
  }

  this.notifyAddFiles(files).then(function (files) {
    this.handleAddingFileByType(files);
  }.bind(this));
};

MessageInput.eventHandler.clickQuoteRemoveBtn = function () {
  this.quote = null;
  this.notifyChange();
};

MessageInput.property = {};
MessageInput.property.files = {
  set: function (value) {
    $$('.as-file', this.$attachmentCtn).forEach(function (elt) {
      elt.remove();
    });
    value = value || [];
    this._files = [];
    this.addFiles(value);
  },
  get: function () {
    return this._files;
  }
};
MessageInput.property.images = {
  set: function (value) {
    $$('.as-image', this.$attachmentCtn).forEach(function (elt) {
      elt.remove();
    });
    value = value || [];
    this._imageFiles = [];
    this.addImageFiles(value);
  },
  get: function () {
    return this._imageFiles;
  }
};
MessageInput.property.text = {
  set: function (text) {
    this.$preInput.value = '' + text;

    if (text.length > 0) {
      this.addClass('as-has-text');
    } else {
      this.removeClass('as-has-text');
    }

    if (this._mode === MODE_EDIT) {
      this._editingText = text;
    }

    this.removeClass('as-text-changed');
  },
  get: function () {
    return this.$preInput.value;
  }
};
/**
 * @type {MessageInput}
 */

MessageInput.property.mode = {
  set: function (value) {
    value = value || MODE_NEW;

    if (value === MODE_EDIT || value.toLowerCase && value.toLowerCase() === 'edit') {
      this.addClass('as-mode-edit');
      value = MODE_EDIT;
      this._editingText = this.$preInput.value;
    } else {
      value = MODE_NEW;
      this._editingText = '';
      this.removeClass('as-mode-edit');
    }

    this.removeClass('as-text-changed');
    this._mode = value;
  },
  get: function () {
    return this._mode === MODE_EDIT ? 'edit' : 'new';
  }
};
MessageInput.property.autoSend = {
  set: function (value) {
    if (value) {
      this.addClass('as-auto-send');
    } else {
      this.removeClass('as-auto-send');
    }
  },
  get: function () {
    return this.containsClass('as-auto-send');
  }
};
MessageInput.property.quote = {
  set: function (quote) {
    this._quote = quote;

    this._updateQuote();
  },
  get: function () {
    return this._quote;
  }
};

_ACore.default.install(MessageInput);

var _default = MessageInput;
exports.default = _default;
var urlRex = /^(firefox|opera|chrome|https|http|wss|ws):\/\/[^\s]+$/;

function parseMessage(text, data) {
  data = data || {};
  data.emojiAssetRoot = data.emojiAssetRoot || _EmojiPicker.default.assetRoot;
  data.staticSize = data.staticSize || 20;
  data.animSize = data.animSize || 60;
  var textLines = text.split(/\r?\n/);
  var lines = textLines.map(function (textLine) {
    var longTokenTexts = textLine.split(/\s/);
    var tokenGroups = longTokenTexts.map(function (longTokenText, longTokenIndex) {
      var tokens = [];
      if (longTokenIndex > 0) tokens.push({
        type: 'text',
        value: ' '
      });
      var emojiKey, emojiKeyTemp;
      var subIndex, subIndexTemp;
      var leftToken;
      var found;
      var emoji;

      while (longTokenText.length > 0) {
        found = false;
        subIndex = 10000000;

        for (var i = 0; i < _EmojiAnims.default.length; ++i) {
          emojiKeyTemp = _EmojiAnims.default[i][0];
          subIndexTemp = longTokenText.indexOf(emojiKeyTemp);

          if (subIndexTemp >= 0 && subIndexTemp < subIndex) {
            subIndex = subIndexTemp;
            emojiKey = emojiKeyTemp;
            emoji = _EmojiAnims.default[i];
            found = true;
          }
        }

        if (found) {
          if (subIndex >= 0) {
            leftToken = longTokenText.substr(0, subIndex);
            longTokenText = longTokenText.substr(subIndex + emojiKey.length);

            if (leftToken.length > 0) {
              tokens.push({
                type: 'text',
                value: leftToken
              });
            }

            tokens.push({
              type: 'emoji',
              value: emoji
            });
            found = true;
          }
        } else {
          tokens.push({
            type: 'text',
            value: longTokenText
          });
          longTokenText = '';
        }
      }

      tokens.forEach(function (token) {
        if (token.type == 'text') {
          var urlMatched = token.value.match(urlRex);

          if (urlMatched) {
            token.type = 'url';
            token.protocal = urlMatched[1];
          }
        }
      });
      return tokens;
    });
    var tokens = [];

    for (var i = 0; i < tokenGroups.length; ++i) {
      tokens.push.apply(tokens, tokenGroups[i]);
    }

    return tokens.reduce(function (ac, token) {
      if (token.type == 'text' && ac.last.type == 'text') {
        ac.last.value += token.value;
      } else {
        ac.last = token;
        ac.result.push(token);
      }

      return ac;
    }, {
      result: [],
      last: {
        type: 'null'
      }
    }).result;
  });
  var res = lines.reduce(function (ac, line, lineIndex, lines) {
    line.reduce(function (ac, token) {
      if (token.type == 'text') {
        ac.push({
          tag: 'span',
          child: {
            text: token.value
          }
        });
      } else if (token.type == 'url') {
        ac.push({
          tag: 'a',
          class: 'as-protocal-' + token.protocal,
          child: {
            text: token.value
          },
          props: {
            href: token.value
          }
        });
      } else if (token.type == 'emoji') {
        ac.push({
          tag: 'span',
          class: 'as-emoji-text',
          child: {
            text: token.value[0]
          }
        });
        ac.push({
          tag: 'img',
          class: 'as-emoji',
          props: {
            src: data.emojiAssetRoot + '/static/x' + data.staticSize + '/' + token.value[1]
          }
        });
      }

      return ac;
    }, ac);
    if (lineIndex < lines.length - 1 || line.length == 0) ac.push('br');
    return ac;
  }, []);

  if (res.length == 2 && res[1].class == 'as-emoji') {
    res[1].tag = 'iconsprite', res[1].props.fps = 30;
    res[1].props.src = res[1].props.src.replace('/static/x' + data.staticSize, '/anim/x' + data.animSize);
  }

  return res;
}

MessageInput.parseMessage = parseMessage;

function prepareIcon() {
  if (!MessageInput.iconSupportAsync) {
    var catalogiUrl = MessageInput.iconAssetRoot + '/catalog.json';
    MessageInput.iconSupportAsync = MessageInput.iconSupportAsync || iconCatalogCaches[catalogiUrl] ? Promise.resolve(iconCatalogCaches[catalogiUrl]) : _XHR.default.getRequest(catalogiUrl).then(function (result) {
      iconCatalogCaches[catalogiUrl] = JSON.parse(result);
      return iconCatalogCaches[catalogiUrl];
    });
  }

  return MessageInput.iconSupportAsync;
}
/***
 * @typedef MessageInputPluginOption
 * @property {string} [id]
 * @property {string|Object|AElement} icon
 * @property {function(_thisAdapter: MessageInputPlugin, _:Dom._, Dom.$):AElement} createContent
 * @property {function(_thisAdapter:MessageInputPlugin):void} onPressTrigger
 */


function MessageQuote() {
  prepareIcon();
  /***
   *
   * @type {null|MessageInputQuote}
   * @private
   */

  this._data = null;
  this.$img = $('.as-message-quote-img', this);
  this.$text = $('.as-message-quote-text', this);
  this.$desc = $('.as-message-quote-desc', this);
  this.$removeBtn = $('.as-message-quote-remove-btn', this).on('click', this.eventHandler.clickRemoveBtn);
  Object.defineProperty(this, '$text', {
    set: function () {
      console.trace();
    },
    get: function () {
      return $('.as-message-quote-text', this);
    }
  });
}

MessageQuote.tag = 'MessageQuote'.toLowerCase();

MessageQuote.render = function () {
  return _({
    extendEvent: 'pressremove',
    class: 'as-message-quote-box',
    child: [{
      class: 'as-message-quote-img'
    }, {
      class: 'as-message-quote-sym',
      child: 'span.mdi.mdi-format-quote-open-outline'
    }, {
      class: 'as-message-quote-content',
      child: [{
        class: 'as-message-quote-text',
        child: {
          text: ''
        }
      }, {
        class: 'as-message-quote-desc',
        child: {
          text: ''
        }
      }]
    }, {
      tag: 'button',
      class: 'as-message-quote-remove-btn',
      child: 'span.mdi.mdi-close'
    }]
  });
};

MessageQuote.property = {};
MessageQuote.eventHandler = {};
MessageQuote.property.removable = {
  set: function (val) {
    if (val) {
      this.addClass('as-removable');
    } else {
      this.removeClass('as-removable');
    }
  },
  get: function () {
    return this.containsClass('as-removable');
  }
};
MessageQuote.property.shortenText = {
  set: function (val) {
    if (val) {
      this.addClass('as-shorten-text');
    } else {
      this.removeClass('as-shorten-text');
    }
  },
  get: function () {
    return this.containsClass('as-shorten-text');
  }
};
MessageQuote.property.data = {
  set: function (quote) {
    this._data = quote;
    var text, desc;
    var file, img;

    if (typeof quote === "string") {
      text = quote;
      desc = '';
    } else if (quote && typeof quote === "object") {
      text = quote.text;
      desc = quote.desc;
      file = quote.file;
      img = quote.img;
    }

    if (text === undefined) {
      this.$text.clearChild();
      this.$desc.firstChild.data = '';
      this.removeClass('as-has-file');
      this.removeClass('as-has-img');
    } else {
      if (file) {
        file = file.toLowerCase().split('.').pop();
        MessageInput.iconSupportAsync.then(function (iconSupport) {
          if (iconSupport.indexOf(file) < 0) file = 'default';
          this.$img.addStyle('background-image', 'url(' + MessageInput.iconAssetRoot + '/' + file + '.svg)');
        }.bind(this));
        this.addClass('as-has-file');
      } else this.removeClass('as-has-file');

      if (img) {
        this.$img.addStyle('background-image', 'url(' + img + ')');
        this.addClass('as-has-img');
      } else this.removeClass('as-has-img');

      if (this.shortenText) text = text.split(/\r?\n/).shift();
      var parsedText = parseMessage(text);
      var textEltChain = parsedText.map(function (c) {
        return _(c);
      });
      this.$text.clearChild().addChild(textEltChain);
      this.$desc.firstChild.data = desc;
    }
  },
  get: function () {
    return this.data;
  }
};

MessageQuote.eventHandler.clickRemoveBtn = function () {
  this.emit('pressremove', {
    target: this,
    type: 'pressclose'
  }, this);
};

_ACore.default.install(MessageQuote);
/***
 *
 * @param {MessageInput} inputElt
 * @param {MessageInputPluginOption} option
 * @constructor
 */


function MessageInputPlugin(inputElt, option) {
  this.inputElt = inputElt;
  this.icon = option.icon;
  this.id = option.id || (0, _stringGenerate.randomIdent)(16);
  this.$icon = null;
  this.$triggerBtn = null;
  this.$content = null;
  this.$popup = null;
  if (option.createContent) this.createContent = option.createContent;
  if (option.onPressTrigger) this.onPressTrigger = option.onPressTrigger;
  this.ev_pressTrigger = this.ev_pressTrigger.bind(this);
  this.ev_pressOut = this.ev_pressOut.bind(this);
  this.attach();
}

MessageInputPlugin.prototype.attach = function () {
  this.inputElt.$right.addChildBefore(this.getTriggerButton(), this.inputElt.$right.firstChild);
};

MessageInputPlugin.prototype.ev_pressTrigger = function (event) {
  var value = this.inputElt.$preInput.value;
  this._lastInputSelectPosion = this.inputElt.$preInput.getSelectPosition() || {
    start: value.length,
    end: value.length
  };

  if (this.onPressTrigger) {
    this.onPressTrigger(this);
  } else {
    if (this.isPopupOpened()) {
      this.closePopup();
    } else {
      this.openPopup();
    }
  }
};

MessageInputPlugin.prototype.insertText = function (itext) {
  if (!this._lastInputSelectPosion) {
    throw new Error('Invalid call');
  }

  var text = this.inputElt.$preInput.value;
  var newText = text.substr(0, this._lastInputSelectPosion.start) + itext + text.substr(this._lastInputSelectPosion.end);
  var selected = this._lastInputSelectPosion;
  var newOffset = selected.start + itext.length;
  this.inputElt.$preInput.focus();
  this.inputElt.$preInput.applyData(newText, newOffset);
  this.inputElt.$preInput.commitChange(newText, newOffset);
  this.inputElt.notifySizeChange();
  this.inputElt.$preInput.focus();
};

MessageInputPlugin.prototype.appendText = function (itext) {
  if (!this._lastInputSelectPosion) {
    throw new Error('Invalid call');
  }

  var text = this.inputElt.$preInput.value;
  var newText = text + itext;
  var newOffset = newText.length;
  this.inputElt.$preInput.focus();
  this.inputElt.$preInput.applyData(newText, newOffset);
  this.inputElt.$preInput.commitChange(newText, newOffset);
  this.inputElt.notifySizeChange();
  this.inputElt.$preInput.focus();
};

MessageInputPlugin.prototype.replaceText = function (itext) {
  if (!this._lastInputSelectPosion) {
    throw new Error('Invalid call');
  }

  var newText = itext;
  var newOffset = newText.length;
  this.inputElt.$preInput.focus();
  this.inputElt.$preInput.applyData(newText, newOffset);
  this.inputElt.$preInput.commitChange(newText, newOffset);
  this.inputElt.notifySizeChange();
  this.inputElt.$preInput.focus();
};

MessageInputPlugin.prototype.ev_pressOut = function (event) {
  if (_EventEmitter.default.hitElement(this.getTriggerButton(), event)) return;
  if (_EventEmitter.default.hitElement(this.getPopup(), event)) return;
  this.closePopup();
};

MessageInputPlugin.prototype.getIconElt = function () {
  if (!this.$icon) this.$icon = _(this.icon);
  return this.$icon;
};

MessageInputPlugin.prototype.getTriggerButton = function () {
  if (!this.$triggerBtn) {
    this.$triggerBtn = _({
      tag: 'button',
      class: ['as-message-input-plugin-btn', 'as-message-input-plugin-' + this.id],
      child: this.getIconElt(),
      on: {
        click: this.ev_pressTrigger
      }
    });
  }

  return this.$triggerBtn;
};

MessageInputPlugin.prototype.createContent = function (_thisAdapter, _, $) {
  throw new Error("Not implement!");
};
/***
 *
 * @type {null|function(_thisAdapter:MessageInputPlugin):void}
 */


MessageInputPlugin.prototype.onPressTrigger = null;

MessageInputPlugin.prototype.getContent = function () {
  if (!this.$content) this.$content = this.createContent(this.inputElt, _, $);
  return this.$content;
};

MessageInputPlugin.prototype.getPopup = function () {
  if (!this.$popup) {
    this.$popup = _({
      class: 'as-message-input-external-tools-popup',
      child: this.getContent()
    });
  }

  return this.$popup;
};

MessageInputPlugin.prototype.openPopup = function () {
  if (this.isPopupOpened()) return;
  this.inputElt.appendChild(this.getPopup());
  document.body.addEventListener('click', this.ev_pressOut);
};

MessageInputPlugin.prototype.closePopup = function () {
  if (!this.isPopupOpened()) return;
  this.getPopup().remove();
  document.body.removeEventListener('click', this.ev_pressOut);
};

MessageInputPlugin.prototype.isPopupOpened = function () {
  return !!this.getPopup().parentElement;
};

MessageInput.prototype.PluginConstructor = MessageInputPlugin;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Modal.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Modal.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/modal.css");

var _ACore = _interopRequireDefault(require("../ACore"));


var $ = _ACore.default.$;
var _ = _ACore.default._;

function Modal() {
  this._contentAlign = [];
  this.contentAlign = 'middle center';
  this.$content = $('.as-modal-content', this);
}

Modal.tag = 'modal';

Modal.render = function () {
  return _({
    class: 'as-modal',
    child: '.as-modal-content'
  });
};

['findChildBefore', 'findChildAfter', 'removeChild', 'clearChild', 'addChild'].forEach(function (key) {
  Modal.prototype[key] = function () {
    this.$content[key].apply(this.$content, arguments);
  };
});
Modal.property = {};
Modal.property.show = {
  set: function (value) {
    if (value) this.removeClass('as-hidden');else this.addClass('as-hidden');
  },
  get: function () {
    return !this.containsClass('as-hidden');
  }
};
Modal.property.contentAlign = {
  set: function (value) {
    var thisM = this;

    this._contentAlign.forEach(function (name) {
      thisM.removeClass('as-' + name);
    });

    value = value || '';

    if (typeof value === 'string') {
      this._contentAlign = value.split(/\s+/);
    } else if (value instanceof Array) {
      this._contentAlign = value;
    } else {
      throw new Error("Invalid contentAlign!");
    }

    var thisM = this;

    this._contentAlign.forEach(function (name) {
      thisM.addClass('as-' + name);
    });
  },
  get: function () {
    return this._contentAlign.join(' ');
  }
};

_ACore.default.install(Modal);

var _default = Modal;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SelectListItem.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SelectListItem.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/selectlist.css");

var _ACore = _interopRequireDefault(require("../ACore"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function SelectListItem() {
  var res = _({
    class: 'absol-selectlist-item',
    child: [{
      tag: 'span',
      class: 'absol-selectlist-item-text',
      child: {
        text: ''
      }
    }, {
      class: 'absol-selectlist-item-desc-container',
      child: {
        tag: 'span',
        class: 'absol-selectlist-item-desc',
        child: {
          text: ''
        }
      }
    }]
  });

  res.$text = $('span.absol-selectlist-item-text', res);
  res.$textValue = res.$text.childNodes[0];
  res.$descCtn = $('.absol-selectlist-item-desc-container', res);
  res.$desc = $('span.absol-selectlist-item-desc', res.$descCtn);
  res.$descValue = res.$desc.childNodes[0];
  res._extendClasses = [];
  res._extendStyle = {};
  res._data = "";
  res._level = 0;
  return res;
} //bold 14pt arial


SelectListItem.property = {};
SelectListItem.property.extendClasses = {
  set: function (value) {
    var i;

    for (i = 0; i < this._extendClasses.length; ++i) {
      this.removeClass(this._extendClasses[i]);
    }

    this._extendClasses = [];
    if (typeof value == 'string') value = value.trim().split(/\s+/);
    value = value || [];

    for (i = 0; i < value.length; ++i) {
      this._extendClasses.push(value[i]);

      this.addClass(value[i]);
    }
  },
  get: function () {
    return this._extendClasses;
  }
};
SelectListItem.property.extendStyle = {
  set: function (value) {
    this.removeStyle(this._extendStyle);
    this._extendStyle = Object.assign({}, value || {});
    this.addStyle(this._extendStyle);
  },
  get: function () {
    return this._extendClasses;
  }
};
SelectListItem.property.data = {
  set: function (value) {
    this._data = value;

    if (typeof value == 'string') {
      this.$textValue.data = value;
      this.$descValue.data = '';
      this.level = 0;
      this.extendClasses = '';
      this.extendStyle = {};
      this.lastInGroup = false;
      this.isLeaf = false;
      this.selected = false;
    } else {
      this.$textValue.data = value.text || '';
      this.$descValue.data = value.desc || '';
      this.level = value.level || 0;
      this.extendClasses = value.extendClasses;
      this.extendStyle = value.extendStyle;
      this.lastInGroup = !!value.lastInGroup;
      this.isLeaf = !!value.isLeaf;
      this.selected = !!value.selected;
    }
  },
  get: function () {
    return this._data;
  }
};
SelectListItem.property.value = {
  get: function () {
    return typeof this._data == "string" ? this._data : this._data.value;
  }
};
SelectListItem.property.text = {
  get: function () {
    return typeof this._data == "string" ? this._data : this._data.text;
  }
};
SelectListItem.property.desc = {
  get: function () {
    return typeof this._data == "string" ? undefined : this._data.desc;
  }
};
SelectListItem.property.level = {
  set: function (value) {
    value = value || 0;
    this._level = value;
    this.$text.addStyle('margin-left', value * 0.9 + 'em');
  },
  get: function () {
    return this._level;
  }
};
SelectListItem.property.lastInGroup = {
  set: function (value) {
    if (value) {
      this.addClass('as-last-in-group');
    } else {
      this.removeClass('as-last-in-group');
    }
  },
  get: function () {
    return this.containsClass('as-last-in-group');
  }
};
SelectListItem.property.isLeaf = {
  set: function (value) {
    if (value) {
      this.addClass('as-is-leaf');
    } else {
      this.removeClass('as-is-leaf');
    }
  },
  get: function () {
    return this.containsClass('as-is-leaf');
  }
};
SelectListItem.property.selected = {
  set: function (value) {
    if (value) {
      this.addClass('as-selected');
    } else {
      this.removeClass('as-selected');
    }
  },
  get: function () {
    return this.containsClass('as-selected');
  }
};

_ACore.default.install('SelectListItem'.toLowerCase(), SelectListItem);

var _default = SelectListItem;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SelectList.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SelectList.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeItem = makeItem;
exports.requireItem = requireItem;
exports.releaseItem = releaseItem;
exports.measureMaxDescriptionWidth = measureMaxDescriptionWidth;
exports.measureMaxTextWidth = measureMaxTextWidth;
exports.measureListHeight = measureListHeight;
exports.measureListSize = measureListSize;
exports.default = void 0;

require("../css/selectlist.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _utils = require("./utils");

require("./SelectListItem");

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
var isSupportedVar = window.CSS && window.CSS.supports && window.CSS.supports('--fake-var', 'red');
/**
 * Setup css
 */

if (isSupportedVar) {
  SelectList.$dynamicStyle = function () {
    var cssElt = _('style#selectlist-dynamic-style');

    var cssCode = ['.absol-selectlist-item>span {', '    margin-right: calc(0.35em + var(--select-list-desc-width));', '}', '.absol-selectlist-item-desc-container {', '    width: var(--select-list-desc-width);', '}'];
    cssElt.innerHTML = cssCode.join('\n');
    cssElt.addTo(document.head);
    return cssElt;
  }();
}

var itemPool = [];

function onMousedownItem(event) {
  if (_EventEmitter.default.isMouseRight(event)) return;
  var thisSL = this.$parent;

  if (thisSL) {
    thisSL.value = this.value;
    thisSL.emit('pressitem', {
      type: 'pressitem',
      target: thisSL,
      itemElt: this,
      value: this.value,
      data: this.data
    });
  }
}

function makeItem() {
  return _({
    tag: 'selectlistitem',
    on: {
      mousedown: onMousedownItem
    }
  });
}

function requireItem($parent) {
  var item;

  if (itemPool.length > 0) {
    item = itemPool.pop();
  } else {
    item = makeItem();
  }

  item.$parent = $parent;
  return item;
}

function releaseItem(item) {
  item.$parent = null;
  item.removeClass('selected');
  itemPool.push(item);
}

;

function measureMaxDescriptionWidth(items) {
  var maxDescWidth = 0;
  var maxText = 0;
  var maxEst = 0;
  var est;

  for (var i = 0; i < items.length; ++i) {
    if (items[i].desc) {
      est = (0, _utils.estimateWidth14)(items[i].desc);

      if (est > maxEst) {
        maxEst = est;
        maxText = items[i].desc;
      }
    }
  }

  if (maxText) maxDescWidth = (0, _utils.measureText)(maxText, 'italic 14px  sans-serif').width;
  return maxDescWidth;
}

;

function measureMaxTextWidth(items) {
  var maxTextWidth = 0;
  var maxText = 0;
  var maxEst = 0;
  var maxLv = 0;
  var est;
  var text;
  var item;

  for (var i = 0; i < items.length; ++i) {
    item = items[i];

    if (item.text) {
      text = item.text;
      est = (0, _utils.estimateWidth14)(text) + 14 * 0.9 * (item.level || 0);

      if (est > maxEst) {
        maxEst = est;
        maxText = text;
        maxLv = item.level || 0;
      }
    }
  }

  if (maxText) maxTextWidth = 14 * 0.9 * maxLv + (0, _utils.measureText)(maxText, '14px Arial, Helvetica, sans-serif').width + 14; //padding left, right 7px

  return maxTextWidth;
}

function measureListHeight(items) {
  var border = 0;
  var n = items.length - 1;
  return items.length * 20 + border;
}

function measureListSize(items) {
  var descWidth = measureMaxDescriptionWidth(items);
  var textWidth = measureMaxTextWidth(items);
  var width = textWidth;

  if (descWidth > 0) {
    width += descWidth + 14;
  }

  var height = measureListHeight(items);
  return {
    width: width,
    height: height,
    descWidth: descWidth,
    textWidth: textWidth
  };
}
/*global absol*/

/***
 * @extends AElement
 * @constructor
 */


function SelectList() {
  var thisSL = this;
  this.defineEvent(['pressitem', 'cancelasync', 'valuevisibilityasync', 'finishasync', 'sizechangeasync']);
  this.$attachhook = _('attachhook').addTo(this);
  this.sync = new Promise(function (rs) {
    thisSL.$attachhook.once('error', rs);
  });
  this.$items = [];
  this.$itemByValue = {}; //quick find element

  this.$selectedItem = undefined;
  this.measuredSize = {
    width: 0,
    height: 0,
    descWidth: 0,
    textWidth: 0
  };
  this._itemSession = 0;
  this._finished = true;
}

;
SelectList.tag = "SelectList".toLowerCase();

SelectList.render = function () {
  return _('.absol-selectlist');
};

SelectList.prototype._updateSelectedItem = function () {
  var newSelectedItemElt = this.$itemByValue[this._selectValue];

  if (newSelectedItemElt != this.$selectedItem) {
    if (this.$selectedItem) {
      this.$selectedItem.removeClass('selected');
    }

    if (newSelectedItemElt) {
      newSelectedItemElt.addClass('selected');
      this.$selectedItem = newSelectedItemElt;
    }
  }
};

SelectList.prototype._requireItems = function (itemCout) {
  var item;

  while (this.$items.length < itemCout) {
    item = requireItem(this);
    this.$items.push(item);
    this.addChild(item);
  }

  while (this.$items.length > itemCout) {
    item = this.$items.pop();
    item.remove();
    releaseItem(item);
  }
};

SelectList.prototype._assignItems = function (from, to) {
  var foundSelected = false;
  var itemElt;
  var item;

  for (var i = from; i < to; ++i) {
    itemElt = this.$items[i];
    item = this._items[i];
    itemElt.data = item;
    itemElt.__index__ = i;

    if (this.$itemByValue[item.value]) {
      console.warn('Value  ' + this.$items[i].value + ' is duplicated!');
    } else {
      this.$itemByValue[item.value] = itemElt;

      if (this._selectValue == item.value) {
        itemElt.addClass('selected');
        this.$selectedItem = itemElt;
        foundSelected = true;
      } else {
        itemElt.removeClass('selected');
      }
    }
  }

  return foundSelected;
};

SelectList.prototype.setItemsAsync = function (items) {
  //start process
  this._finished = false;
  var session = Math.floor(Math.random() * 1000000);
  this._itemSession = session;
  this._items = items || [];
  this.$itemByValue = {};
  this.measuredSize = measureListSize(items);
  this.style.setProperty('--select-list-desc-width', this.measuredSize.descWidth + 'px'); //addStyle notWork because of convert to cameCase 

  var thisSL = this;
  var i = 0;
  var limit = 20;

  function tick() {
    if (thisSL._itemSession != session) {
      thisSL.emit('cancelasync', {
        session: session,
        type: 'cancelasync'
      }, this);
      return;
    }

    if (i >= items.length) {
      thisSL._updateSelectedItem();

      thisSL._finished = false;
      thisSL.emit('finishasync', {
        session: session,
        type: 'finishasync'
      }, this);
      return;
    }

    var n = Math.min(items.length - i, limit);
    var itemCout = i + n;

    thisSL._requireItems(itemCout);

    i = itemCout;

    var foundSelected = thisSL._assignItems(itemCout - n, itemCout);

    if (foundSelected) {
      thisSL.emit('valuevisibilityasync', {
        session: session,
        type: 'valuevisibilityasync',
        itemElt: thisSL.$items[i]
      }, thisSL);
    }

    thisSL.emit('sizechangeasync', {
      session: session,
      type: 'sizechangeasync'
    }, this);
    setTimeout(tick, 2);
  }

  setTimeout(tick, 2);
  return Object.assign({
    session: session
  }, this.measuredSize);
};

SelectList.prototype.setItems = function (items) {
  this._finished = false;
  var session = Math.floor(Math.random() * 1000000);
  this._itemSession = session;
  this._items = items || [];
  this.$itemByValue = {};
  this.measuredSize = measureListSize(items);
  this.style.setProperty('--select-list-desc-width', this.measuredSize.descWidth + 'px'); //addStyle notWork because of convert to cameCase 

  var itemCount = items.length;

  this._requireItems(itemCount);

  this._assignItems(0, itemCount);

  this._finished = true;
  return {
    session: this._itemSession,
    width: this._descWidth + this._textWidth + 14,
    height: this._height
  };
};

SelectList.property = {};
/**
 * @type {SelectList}
 */

SelectList.property.items = {
  set: function (value) {
    value = value || [];
    this.setItems(value);
  },
  get: function () {
    return this._items || [];
  }
};
SelectList.property.value = {
  set: function (value) {
    this._selectValue = value;

    this._updateSelectedItem();
  },
  get: function () {
    return this._selectValue;
  }
};
SelectList.property.item = {
  get: function () {
    if (this.$selectedItem) return this.$selectedItem.data;
    return undefined;
  }
};
SelectList.property.selectedIndex = {
  get: function () {
    throw new Error("selectedIndex getter is deprecated");
  }
};

SelectList.prototype.init = function (props) {
  props = props || {};
  var value = props.value;
  delete props.value;
  this.super(props);
  if (value !== undefined) this.value = value;
};

SelectList.eventHandler = {};

_ACore.default.install(SelectList);

var _default = SelectList;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/String/stringMatching.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/String/stringMatching.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wordLike = wordLike;
exports.wordsMatch = wordsMatch;
exports.phraseMatch = phraseMatch;
exports.phraseLike = phraseLike;

var _int = require("absol/src/Math/int");

/**
 *
 * @param {String} a
 * @param {String} b
 */
function wordLike(a, b) {
  var m = a.length;
  var n = b.length;

  function map(i, j) {
    return i * (n + 1) + j;
  }

  var Q = Array((m + 1) * (n + 1)).fill(0);

  for (var i = 0; i < m; ++i) for (var j = 0; j < n; ++j) if (a.charAt(i) == b.charAt(j)) {
    if (Q[map(i + 1, j + 1)]) {
      if (Q[map(i + 1, j + 1)] < Q[map(i, j)] + 1) Q[map(i + 1, j + 1)] = Q[map(i, j)] + 1;
    } else Q[map(i + 1, j + 1)] = Q[map(i, j)] + 1;
  } else Q[map(i + 1, j + 1)] = Math.max(Q[map(i + 1, j)], Q[map(i, j + 1)]);

  return Q[map(m, n)] / (0, _int.harmonicMean)(m, n);
}
/**
 *
 * @param {Array<String>} sq1
 * @param {Array<String>} sq2
 */


function wordsMatch(sq1, sq2, matchWordPow) {
  matchWordPow = matchWordPow === undefined ? 1 : matchWordPow;
  var m = sq1.length;
  var n = sq2.length;

  function map(i, j) {
    return i * (n + 1) + j;
  }

  var Q = Array((m + 1) * (n + 1)).fill(0);
  var e = 0.0;

  for (var i = 0; i < m; ++i) for (var j = 0; j < n; ++j) {
    e = Math.pow(wordLike(sq1[i], sq2[j]), matchWordPow);

    if (Q[map(i + 1, j + 1)]) {
      if (Q[map(i + 1, j + 1)] < Q[map(i, j)] + e) Q[map(i + 1, j + 1)] = Q[map(i, j)] + e;
    } else Q[map(i + 1, j + 1)] = Q[map(i, j)] + e;

    e = Math.max(Q[map(i + 1, j)], Q[map(i, j + 1)]);
    if (e > Q[map(i + 1, j + 1)]) Q[map(i + 1, j + 1)] = e;
  }

  return Q[map(m, n)];
}

function phraseMatch(a, b, matchWordPow) {
  matchWordPow = matchWordPow || 1;
  var spliter = /[\s,-\.+?\_]+/;

  var notEmp = function (e) {
    return e.length > 0;
  };

  var sq1 = a.toLowerCase().split(spliter).filter(notEmp);
  var sq2 = b.toLowerCase().split(spliter).filter(notEmp);
  var wordsMatchScore = wordsMatch(sq1, sq2);
  var m = sq1.length;
  var n = sq2.length;
  return wordsMatchScore / Math.max((0, _int.harmonicMean)(m, n), 1);
}

;

function phraseLike(a, b, matchWordPow) {
  matchWordPow = matchWordPow || 1;
  var spliter = /[\s,-\.+?\_]+/;

  var notEmp = function (e) {
    return e.length > 0;
  };

  var sq1 = a.toLowerCase().split(spliter).filter(notEmp);
  var sq2 = b.toLowerCase().split(spliter).filter(notEmp);
  var m = sq1.length;
  var n = sq2.length;
  var wordsMatchScore = wordsMatch(sq1, sq2);
  return wordsMatchScore / Math.max((0, _int.harmonicMean)(m, n), 1);
}
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/list/search.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/list/search.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = prepareSearchForItem;
exports.prepareSearchForList = prepareSearchForList;
exports.calcItemMatchScore = calcItemMatchScore;
exports.searchListByText = searchListByText;
exports.searchTreeListByText = searchTreeListByText;

var _stringFormat = require("absol/src/String/stringFormat");

var _stringMatching = require("absol/src/String/stringMatching");

var EXTRA_MATCH_SCORE = 7;
var UNCASE_MATCH_SCORE = 4;
var UVN_MATCH_SCORE = 3;
var EQUAL_MATCH_SCORE = 4;
var WORD_MATCH_SCORE = 3;
/***
 *
 * @param {SelectionItem} item
 * @returns {*}
 */

function prepareSearchForItem(item) {
  if (!item.text || !item.text.charAt) item.text = item.text + '';
  var spliter = /\s+/;

  var __text__ = item.text.replace(/([\s\b\-()\[\]]|&#8239;|&nbsp;|&#xA0;|\s)+/g, ' ').trim();

  var __textNoneCase__ = __text__.toLowerCase();

  var __nvnText__ = (0, _stringFormat.nonAccentVietnamese)(__text__);

  var __nvnTextNoneCase__ = __nvnText__.toLowerCase();

  Object.defineProperties(item, {
    __text__: {
      configurable: true,
      enumerable: false,
      writable: true,
      value: __text__
    },
    __words__: {
      configurable: true,
      enumerable: false,
      writable: true,
      value: __text__.split(spliter)
    },
    __textNoneCase__: {
      configurable: true,
      enumerable: false,
      writable: true,
      value: __textNoneCase__
    },
    __wordsNoneCase__: {
      configurable: true,
      enumerable: false,
      writable: true,
      value: __textNoneCase__.split(spliter)
    },
    __nvnText__: {
      configurable: true,
      enumerable: false,
      writable: true,
      value: __nvnText__
    },
    __nvnWords__: {
      configurable: true,
      enumerable: false,
      writable: true,
      value: __nvnText__.split(spliter)
    },
    __nvnTextNoneCase__: {
      configurable: true,
      enumerable: false,
      writable: true,
      value: __nvnTextNoneCase__
    },
    __nvnWordsNoneCase__: {
      configurable: true,
      enumerable: false,
      writable: true,
      value: __nvnTextNoneCase__.split(spliter)
    }
  });
  return item;
}

function prepareSearchForList(items) {
  var item;

  for (var i = 0; i < items.length; ++i) {
    if (typeof items[i] == 'string') {
      items[i] = {
        text: items[i],
        value: items[i]
      };
    }

    item = items[i];
    prepareSearchForItem(item);
    if (item.items) prepareSearchForList(item.items);
  }

  return items;
}

function calcItemMatchScore(queryItem, item) {
  var score = 0;
  if (item.__text__ == queryItem.__text__) score += EQUAL_MATCH_SCORE * queryItem.__text__.length;

  var extraIndex = item.__text__.indexOf(queryItem.__text__);

  if (extraIndex >= 0) {
    score += EXTRA_MATCH_SCORE * queryItem.__text__.length - extraIndex / item.__text__.length;
  }

  extraIndex = item.__textNoneCase__.indexOf(queryItem.__textNoneCase__);

  if (extraIndex >= 0) {
    score += UNCASE_MATCH_SCORE * queryItem.__text__.length - extraIndex / item.__text__.length;
  }

  extraIndex = item.__nvnTextNoneCase__.indexOf(queryItem.__nvnTextNoneCase__);

  if (extraIndex >= 0) {
    score += UNCASE_MATCH_SCORE * queryItem.__text__.length - extraIndex / item.__text__.length;
  }

  score += (0, _stringMatching.wordsMatch)(queryItem.__nvnWordsNoneCase__, item.__nvnWordsNoneCase__) / (queryItem.__nvnWordsNoneCase__.length + 1 + item.__nvnWordsNoneCase__.length) * 2 * WORD_MATCH_SCORE;
  score += (0, _stringMatching.wordsMatch)(queryItem.__wordsNoneCase__, item.__wordsNoneCase__) / (queryItem.__wordsNoneCase__.length + 1 + item.__wordsNoneCase__.length) * 2 * WORD_MATCH_SCORE;
  return score;
}
/***
 *
 * @param  {String} query
 * @param {Array<SelectionItem>} items
 */


function searchListByText(query, items) {
  query = (query || '').trim();
  if (query.length == 0 || items.length == 0) return items;
  var queryItem = prepareSearchForItem({
    text: query
  });
  var its = items.map(function (item) {
    return {
      item: item,
      score: calcItemMatchScore(queryItem, item)
    };
  });
  its.sort(function (a, b) {
    if (b.score - a.score == 0) {
      if (b.item.__nvnText__ > a.item.__nvnText__) return -1;
      return 1;
    }

    return b.score - a.score;
  });
  var midValue = (its[0].score + its[its.length - 1].score) / 2;
  if (midValue === 0) midValue += 0.1;
  if (midValue < 1) midValue = 1;
  return its.filter(function (it) {
    return it.score >= midValue;
  }).map(function (it) {
    return it.item;
  });
}
/***
 *
 * @param  {String} query
 * @param {Array<SelectionItem>} items
 */


function searchTreeListByText(query, items) {
  query = (query || '').trim();
  if (query.length == 0 || items.length == 0) return items;
  var queryItem = prepareSearchForItem({
    text: query
  });
  var gmaxScore = 0;
  var gminScore = 1000;

  function makeScoreRecursive(item) {
    var score = calcItemMatchScore(queryItem, item);
    gmaxScore = Math.max(score, gmaxScore);
    gminScore = Math.min(score, gminScore);
    var children = (item.items || []).map(function (item) {
      return makeScoreRecursive(item);
    });
    var maxScore = children.reduce(function (ac, cr) {
      return Math.max(ac, cr.maxScore);
    }, score);
    return {
      score: score,
      maxScore: maxScore,
      item: item,
      children: children
    };
  }

  function sortcmp(a, b) {
    return b.maxScore - a.maxScore;
  }

  function filterItems(nodes, medScore) {
    nodes.sort(sortcmp);
    return nodes.filter(function (node) {
      return node.maxScore >= medScore;
    }).map(function (node) {
      var res;

      if (typeof node.item == 'string') {
        res = node.item;
      } else {
        res = Object.assign({}, node.item);

        if (node.children && node.children.length > 0) {
          res.items = filterItems(node.children, medScore);
          if (res.items.length == 0) delete res.items;
        }
      }

      return res;
    });
  }

  var scoredItems = items.map(makeScoreRecursive);
  var medianScore = (gminScore + gmaxScore) / 2;
  var items = filterItems(scoredItems, medianScore);
  return items;
}
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SelectListBox.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SelectListBox.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.VALUE_NORMAL = exports.VALUE_HIDDEN = void 0;

require("../css/selectlistbox.css");

var _search = require("./list/search");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Follower = _interopRequireDefault(require("./Follower"));

var _SelectList = require("./SelectList");

var _DomSignal = _interopRequireDefault(require("absol/src/HTML5/DomSignal"));

var _Dom = require("absol/src/HTML5/Dom");


var _ = _ACore.default._;
var $ = _ACore.default.$;
var $$ = _ACore.default.$$;
var VALUE_HIDDEN = -1;
exports.VALUE_HIDDEN = VALUE_HIDDEN;
var VALUE_NORMAL = 1;
/***
 * @extends Follower
 * @constructor
 */

exports.VALUE_NORMAL = VALUE_NORMAL;

function SelectListBox() {
  this._initDomHook();

  this._initControl();

  this._initScroller();

  this._initProperty();
}

SelectListBox.tag = 'SelectListBox'.toLowerCase();

SelectListBox.render = function () {
  return _({
    tag: 'follower',
    attr: {
      tabindex: 0
    },
    class: 'as-select-list-box',
    extendEvent: ['pressitem'],
    child: [{
      class: 'as-select-list-box-search-ctn',
      child: 'searchtextinput'
    }, {
      class: ['as-bscroller', 'as-select-list-box-scroller'],
      child: [{
        class: ['as-select-list-box-content'],
        child: Array(SelectListBox.prototype.preLoadN).fill('.as-select-list-box-page')
      }]
    }, 'attachhook.as-dom-signal']
  });
};

SelectListBox.prototype.toLoadNextY = 200;
SelectListBox.prototype.preLoadN = 3;

SelectListBox.prototype._initDomHook = function () {
  this.$domSignal = $('attachhook.as-dom-signal', this);
  this.domSignal = new _DomSignal.default(this.$domSignal);
  this.domSignal.on('viewListAt', this.viewListAt.bind(this));
  this.domSignal.on('viewListAtFirstSelected', this.viewListAtFirstSelected.bind(this));
  this.domSignal.on('viewListAtCurrentScrollTop', this.viewListAtCurrentScrollTop.bind(this));
};

SelectListBox.prototype._initControl = function () {
  this._currentOffset = 0;
  this._startItemIdx = 0;
  this.$searchInput = $('searchtextinput', this).on('stoptyping', this.eventHandler.searchModify);
};

SelectListBox.prototype._initScroller = function () {
  this.$content = $('.as-select-list-box-content', this);
  this._estimateHeight = 0;
  this._pageOffsets = Array(this.preLoadN + 1).fill(0);
  this.$listPages = $$('.as-select-list-box-page', this);
  this.$listScroller = $('.as-select-list-box-scroller', this).on('scroll', this.eventHandler.scroll);
};

SelectListBox.prototype._initProperty = function () {
  /***
   *   items  =(search, filler)=> filteredItems =(list to list, tree to list)=>  preDisplayItems =(remove hidden item)=> displayItem
   *
   */
  this._items = [];
  this._itemNodeList = []; // use for tree

  this._values = [];
  this._valueDict = {};
  this._itemNodeHolderByValue = {}; // this._filteredItems = [];// not need , only use when search

  this._preDisplayItems = [];
  this._displayItems = [];
  this._searchCache = {};
  this._displayValue = VALUE_NORMAL;
  this.displayValue = VALUE_NORMAL;
  this.items = [];
};

SelectListBox.prototype._requireItem = function (pageElt, n) {
  var itemElt;

  while (pageElt.childNodes.length > n) {
    itemElt = pageElt.lastChild;
    itemElt.selfRemove();
    (0, _SelectList.releaseItem)(itemElt);
  }

  while (pageElt.childNodes.length < n) {
    itemElt = (0, _SelectList.requireItem)(this);
    pageElt.addChild(itemElt);
  }
};

SelectListBox.prototype._assignItems = function (pageElt, offset) {
  var n = Math.min(this._displayItems.length - offset, pageElt.childNodes.length);
  var itemElt, value;

  for (var i = 0; i < n; ++i) {
    itemElt = pageElt.childNodes[i];
    itemElt.data = this._displayItems[offset + i];
    value = itemElt.value + '';
  }
};

SelectListBox.prototype._itemsToNodeList = function (items) {
  return items;
};
/***
 *
 * @param {Array<{value:String|Number}>} items
 * @return {Array<{value:String|Number}>}
 */


SelectListBox.prototype._filterDisplayItems = function (items) {
  if (this._displayValue === VALUE_NORMAL) return items;
  var dict = this._valueDict;
  return items.filter(function (item) {
    return !dict[item.value + ''];
  });
};

SelectListBox.prototype._updateSelectedItem = function () {
  var valueDict = this._valueDict;
  this.$listPages.forEach(function (pageElt) {
    Array.prototype.forEach.call(pageElt.childNodes, function (itemElt) {
      var value = itemElt.value + '';

      if (valueDict[value]) {
        itemElt.selected = true;
      } else {
        itemElt.selected = false;
      }
    });
  });
};
/***
 *
 * @param {number} offset
 */


SelectListBox.prototype.viewListAt = function (offset) {
  if (!this.isDescendantOf(document.body)) {
    this.domSignal.emit('viewListAt', offset);
    return;
  }

  var fontSize = this.$listScroller.getFontSize() || 14;
  offset = Math.max(0, Math.min(offset, this._displayItems.length - 1));
  var screenSize = (0, _Dom.getScreenSize)();
  var maxItem = Math.ceil(Math.max(window.screen.height, screenSize.height) / 20);
  var contentBound = this.$content.getBoundingClientRect();
  this._pageOffsets[0] = Math.max(offset - maxItem, 0);

  for (var i = 1; i <= this.preLoadN; ++i) {
    this._pageOffsets[i] = Math.min(this._pageOffsets[i - 1] + maxItem, this._displayItems.length);
  }

  var sIdx, nItem, pageBound;
  var pageElt;

  for (var pageIndex = 0; pageIndex < this.preLoadN; ++pageIndex) {
    sIdx = this._pageOffsets[pageIndex];
    nItem = this._pageOffsets[pageIndex + 1] - sIdx;
    pageElt = this.$listPages[pageIndex];
    pageElt.addStyle('top', this._pageOffsets[pageIndex] * 20 + 'px');

    this._requireItem(pageElt, nItem);

    this._assignItems(pageElt, sIdx);

    pageBound = pageElt.getBoundingClientRect();
  }

  this._updateSelectedItem();
};

SelectListBox.prototype.viewListAtFirstSelected = function () {
  if (!this.isDescendantOf(document.body)) {
    this.domSignal.emit('viewListAtFirstSelected');
    return;
  }

  if (this._displayValue == VALUE_HIDDEN) {
    return false;
  } else if (this._values.length > 0) {
    var value = this._values[0];
    var itemHolders = this._displayItemHolderByValue[value + ''];

    if (itemHolders) {
      this.domSignal.once('scrollIntoSelected', function () {
        var holder = itemHolders[0];
        this.viewListAt(holder.idx);
        var itemElt = $('.as-selected', this.$listScroller);

        if (itemElt) {
          var scrollBound = this.$listScroller.getBoundingClientRect();
          var itemBound = itemElt.getBoundingClientRect();
          this.$listScroller.scrollTop += itemBound.top - scrollBound.top;
        }
      }.bind(this));
      this.domSignal.emit('scrollIntoSelected');
      return true;
    } else return false;
  } else return false;
};

SelectListBox.prototype.viewListAtCurrentScrollTop = function () {
  if (!this.isDescendantOf(document.body)) {
    this.emit('viewListAtCurrentScrollTop');
    return;
  }

  this.viewListAt(Math.floor(this.$listScroller.scrollTop / 20));
};

SelectListBox.prototype.searchItemByText = function (text) {
  text = text.trim();
  if (text.length == 0) return this._items;
  if (this._searchCache[text]) return this._searchCache[text];
  this._searchCache[text] = (0, _search.searchListByText)(text, this._items);
  return this._searchCache[text];
};

SelectListBox.prototype.resetSearchState = function () {
  this.$searchInput.value = '';
  this._preDisplayItems = this._itemsToNodeList(this._items);

  this._updateDisplayItem();

  this.domSignal.emit('viewListAt', 0);
  this.$listScroller.scrollTop = 0;
};

SelectListBox.prototype.notifyPressOut = function () {
  this.emit('pressout', {
    target: this,
    type: 'pressout'
  }, this);
};

SelectListBox.prototype.notifyPressClose = function () {
  this.emit('pressclose', {
    target: this,
    type: 'pressclose'
  }, this);
};

SelectListBox.prototype._findFirstPageIdx = function () {
  for (var i = 0; i < this.preLoadN; ++i) {
    if (this._pageOffsets[i + 1] - this._pageOffsets[i] > 0) {
      return i;
    }
  }

  return -1;
};

SelectListBox.prototype._findLastPageIdx = function () {
  for (var i = this.preLoadN - 1; i >= 0; --i) {
    if (this._pageOffsets[i + 1] - this._pageOffsets[i] > 0) {
      return i;
    }
  }

  return -1;
};

SelectListBox.prototype._indexingByValue = function (items, dict) {
  var thisS = this;
  return items.reduce(function (ac, cr, idx) {
    var value = typeof cr === "string" ? cr : cr.value + '';
    ac[value] = ac[value] || [];
    ac[value].push({
      idx: idx,
      item: cr
    });
    return ac;
  }, dict || {});
};

SelectListBox.prototype._depthIndexingByValue = function (items, context) {
  context = context || {
    idx: 0,
    dict: {}
  };
  var thisS = this;
  return items.reduce(function (ac, cr, idx) {
    var value = typeof cr === "string" ? cr : cr.value + '';
    ac[value] = ac[value] || [];
    ac[value].push({
      idx: context.idx++,
      item: cr
    });

    if (cr && cr.items && cr.items.length > 0) {
      thisS._depthIndexingByValue(cr.items, context);
    }

    return ac;
  }, context.dict);
};

SelectListBox.prototype._updateDisplayItemIndex = function () {
  this._displayItemHolderByValue = this._indexingByValue(this._displayItems, {});
};

SelectListBox.prototype._updateItemNodeIndex = function () {
  this._itemNodeHolderByValue = this._depthIndexingByValue(this._items);
};

SelectListBox.prototype._updateDisplayItem = function () {
  this._displayItems = this._filterDisplayItems(this._preDisplayItems);

  this._updateDisplayItemIndex();

  this.$content.addStyle({
    'height': this._displayItems.length * 20 + 'px'
  });
};

SelectListBox.prototype._updateItems = function () {
  this._preDisplayItems = this._itemsToNodeList(this._items);
  this._searchCache = {};
  var estimateSize = (0, _SelectList.measureListSize)(this._itemNodeList);
  this._estimateSize = estimateSize;
  this._estimateWidth = estimateSize.width;
  this._estimateDescWidth = estimateSize.descWidth;
  this.addStyle('--select-list-estimate-width', estimateSize.width + 'px');
  this.addStyle('--select-list-desc-width', estimateSize.descWidth + 'px');

  this._updateDisplayItem();
};
/***
 *
 * @param value
 * @returns {{idx: number, item:{text:string, value:number|string}}[]}
 */


SelectListBox.prototype.findDisplayItemsByValue = function (value) {
  return (this._displayItemHolderByValue[value] || []).slice();
};
/***
 *
 * @param value
 * @returns {{idx: number, item:{text:string, value:number|string}}[]}
 */


SelectListBox.prototype.findItemsByValue = function (value) {
  return (this._itemNodeHolderByValue[value] || []).slice();
};

SelectListBox.property = {};
/***
 *
 * @type {SelectListBox|{}}
 */

SelectListBox.property.items = {
  set: function (items) {
    items = items || [];
    (0, _search.prepareSearchForList)(items);
    this._items = items;
    this._itemNodeList = this._itemsToNodeList(this._items);

    this._updateItemNodeIndex();

    this._updateItems();

    this.viewListAt(0);
  },
  get: function () {
    return this._items;
  }
};
SelectListBox.property.values = {
  set: function (values) {
    values = values || [];
    this._values = values;
    this._valueDict = values.reduce(function (ac, cr) {
      ac[cr + ''] = true;
      return ac;
    }, {});

    this._updateDisplayItem();

    this.viewListAtCurrentScrollTop(); //todo

    if (this._pageOffsets[this.preLoadN] > this._pageOffsets[0]) this._updateSelectedItem();
  },
  get: function () {
    return this._values;
  }
};
SelectListBox.property.displayValue = {
  set: function (value) {
    this._displayValue = value;
    this._displayItems = this._filterDisplayItems(this._preDisplayItems);

    this._updateItemNodeIndex();

    if (value === VALUE_HIDDEN) {
      this.addClass('as-value-hidden');
    } else {
      this.removeClass('as-value-hidden');
    }
  },
  get: function () {
    return this._displayValue;
  }
};
SelectListBox.property.enableSearch = {
  set: function (value) {
    if (value) this.addClass('as-enable-search');else this.removeClass('as-enable-search');
  },
  get: function () {
    return this.containsClass('as-enable-search');
  }
};
/***
 *
 * @type {SelectListBox|{}}
 */

SelectListBox.eventHandler = {};
/*
*
* @param {MouseEvent} event
*/

SelectListBox.eventHandler.click = function (event) {
  if (event.target === this) this.notifyPressOut();
};

SelectListBox.eventHandler.searchModify = function () {
  var text = this.$searchInput.value;
  var searchedItems = this.searchItemByText(text);
  this._preDisplayItems = this._itemsToNodeList(searchedItems);
  this._displayItems = this._filterDisplayItems(this._preDisplayItems);
  this.$content.addStyle({
    'height': this._displayItems.length * 20 + 'px'
  });

  this._updateItemNodeIndex();

  this.viewListAt(0);
  this.$listScroller.scrollTop = 0;
  this.updatePosition();
};

SelectListBox.eventHandler.scroll = function () {
  var scrollerBound = this.$listScroller.getBoundingClientRect();

  var topIdx = this._findFirstPageIdx();

  var screenSize = (0, _Dom.getScreenSize)();
  var maxItem = Math.ceil(Math.max(window.screen.height, screenSize.height) / 20);
  var topBound = this.$listPages[topIdx].getBoundingClientRect();

  var botIdx = this._findLastPageIdx();

  var botBound;
  botBound = this.$listPages[botIdx].getBoundingClientRect();

  if (topBound.top > scrollerBound.top || topBound.bottom < scrollerBound.bottom) {
    this.viewListAt(Math.floor(this.$listScroller.scrollTop / 20));
    return;
  }

  if (this._pageOffsets[topIdx] > 0) {
    if (topBound.top + this.toLoadNextY > scrollerBound.top) {
      this._pageOffsets.unshift(this._pageOffsets.pop());

      this.$listPages.unshift(this.$listPages.pop());
      this._pageOffsets[topIdx] = Math.max(0, this._pageOffsets[topIdx + 1] - maxItem);

      this._requireItem(this.$listPages[topIdx], this._pageOffsets[topIdx + 1] - this._pageOffsets[topIdx]);

      this._assignItems(this.$listPages[topIdx], this._pageOffsets[topIdx]);

      this._updateSelectedItem();

      this.$listPages[topIdx].addStyle('top', this._pageOffsets[topIdx] * 20 + 'px');
    }
  }

  if (this._pageOffsets[botIdx + 1] < this._displayItems.length) {
    if (botBound.bottom - this.toLoadNextY < scrollerBound.bottom) {
      this._pageOffsets.push(this._pageOffsets.shift());

      this.$listPages.push(this.$listPages.shift());
      this._pageOffsets[botIdx + 1] = Math.min(this._displayItems.length, this._pageOffsets[botIdx] + maxItem);
      this.$listPages[botIdx].addStyle('top', this._pageOffsets[botIdx] * 20 + 'px');

      this._requireItem(this.$listPages[botIdx], this._pageOffsets[botIdx + 1] - this._pageOffsets[botIdx]);

      this._assignItems(this.$listPages[botIdx], this._pageOffsets[botIdx]);

      this._updateSelectedItem();
    }
  }
};

_ACore.default.install(SelectListBox);

var _default = SelectListBox;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SelectMenu2.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SelectMenu2.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/selectmenu.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _Dom = _interopRequireWildcard(require("absol/src/HTML5/Dom"));

var _SelectListBox = _interopRequireDefault(require("./SelectListBox"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));




/*global absol*/
var _ = _ACore.default._;
var $ = _ACore.default.$;

_ACore.default.creator['dropdown-ico'] = function () {
  return _(['<svg class="dropdown" width="100mm" height="100mm" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">', '<g transform="translate(0,-197)">', '<path d="m6.3152 218.09a4.5283 4.5283 0 0 0-3.5673 7.3141l43.361 55.641a4.5283 4.5283 0 0 0 7.1421 7e-3l43.496-55.641a4.5283 4.5283 0 0 0-3.5673-7.3216z" />', '</g>', '</svg>'].join(''));
};
/***
 * @extends AElement
 * @constructor
 */


function SelectMenu() {
  var thisSM = this;
  this._items = [];
  this._value = null;
  this._lastValue = null;
  this.$holderItem = $('.absol-selectmenu-holder-item', this);
  this.$viewItem = $('.absol-selectmenu-holder-item selectlistitem', this);
  /***
   *
   * @type {SelectListBox}
   */

  this.$selectlistBox = _({
    tag: 'selectlistbox',
    props: {
      anchor: [1, 6, 2, 5]
    },
    on: {
      preupdateposition: this.eventHandler.preUpdateListPosition
    }
  });
  this.$selectlistBox.on('pressitem', this.eventHandler.selectListBoxPressItem);
  this.$selectlistBox.followTarget = this;

  _OOP.default.drillProperty(this, this.$selectlistBox, 'enableSearch');

  this._lastValue = "NOTHING_VALUE";
  this._isFocus = false;
  this.isFocus = false;
  this.on('mousedown', this.eventHandler.click, true);
}

SelectMenu.tag = 'selectmenu';

SelectMenu.render = function () {
  return _({
    class: ['absol-selectmenu', 'as-select-menu'],
    extendEvent: ['change'],
    attr: {
      tabindex: '1'
    },
    child: [{
      class: 'absol-selectmenu-holder-item',
      child: 'selectlistitem'
    }, {
      tag: 'button',
      class: 'absol-selectmenu-btn',
      child: ['dropdown-ico']
    }]
  });
};

SelectMenu.prototype.init = function (props) {
  props = props || {};
  Object.keys(props).forEach(function (key) {
    if (props[key] === undefined) delete props[key];
  });

  if (!('value' in props)) {
    if (props.items && props.items.length > 0) props.value = typeof props.items[0] == 'string' ? props.items[0] : props.items[0].value;
  }

  var value = props.value;
  delete props.value;
  this.super(props);
  this.value = value;
};

SelectMenu.prototype.updateItem = function () {
  var selectedItems = this.$selectlistBox.findDisplayItemsByValue(this._value);

  if (selectedItems.length >= 1) {
    this.$viewItem.data = selectedItems[0].item;
  } else {
    this.$viewItem.data = {
      text: '',
      value: null
    };
  }
};

SelectMenu.property = {};
SelectMenu.property.items = {
  set: function (items) {
    this.$selectlistBox.items = items || [];
    this.addStyle('--select-list-estimate-width', this.$selectlistBox._estimateWidth + 'px');
    this.addStyle('--select-list-desc-width', this.$selectlistBox._estimateDescWidth + 'px');
    if (items.length == 0) return;
    var selectedItems = this.$selectlistBox.findDisplayItemsByValue(this._value);

    if (selectedItems.length === 0) {
      this.value = items[0].value;
    } else if (selectedItems.length > 1) {
      console.warn(this, 'has duplicate item value');
    } else {
      this.updateItem();
    }
  },
  get: function () {
    return this.$selectlistBox.items;
  }
};
SelectMenu.property.value = {
  set: function (value) {
    this.$selectlistBox.values = [value];
    this._lastValue = value;
    this._value = value;
    this.updateItem();
  },
  get: function () {
    return this._value; //todo
  }
};
/***
 *
 * @type {SelectMenu|{}}
 */

SelectMenu.property.isFocus = {
  set: function (value) {
    var thisSM = this;
    if (!this.items || this.items.length === 0) value = false; //prevent focus

    if (this._isFocus === value) return;
    this._isFocus = !!value;

    if (this._isFocus) {
      document.body.appendChild(this.$selectlistBox);
      this.$selectlistBox.domSignal.$attachhook.emit('attached');
      var bound = this.getBoundingClientRect();
      this.$selectlistBox.addStyle('min-width', bound.width + 'px');
      this.$selectlistBox.refollow();
      this.$selectlistBox.updatePosition();
      setTimeout(function () {
        if (thisSM.enableSearch) {
          thisSM.$selectlistBox.$searchInput.focus();
        } else {
          thisSM.$selectlistBox.focus();
        }

        $(document.body).on('click', thisSM.eventHandler.bodyClick);
      }, 100);
      this.$selectlistBox.viewListAtFirstSelected();
    } else {
      $(document.body).off('click', thisSM.eventHandler.bodyClick);
      this.$selectlistBox.selfRemove();
      this.$selectlistBox.unfollow();
      this.$selectlistBox.resetSearchState();
    }
  },
  get: function () {
    return this._isFocus;
  }
};
SelectMenu.property.disabled = {
  set: function (value) {
    if (value) {
      this.addClass('as-disabled');
    } else {
      this.removeClass('as-disabled');
    }
  },
  get: function () {
    return this.containsClass('as-disabled');
  }
};
SelectMenu.property.hidden = {
  set: function (value) {
    if (value) {
      this.addClass('as-hidden');
    } else {
      this.removeClass('as-hidden');
    }
  },
  get: function () {
    return this.addClass('as-hidden');
  }
};
SelectMenu.property.selectedIndex = {
  get: function () {
    var selectedItems = this.$selectlistBox.findDisplayItemsByValue(this._value);

    if (selectedItems.length > 0) {
      return selectedItems[0].idx;
    }

    return -1;
  }
};
/**
 * @type {SelectMenu|{}}
 */

SelectMenu.eventHandler = {};

SelectMenu.eventHandler.click = function (event) {
  if (_EventEmitter.default.isMouseRight(event)) return;
  if (_EventEmitter.default.hitElement(this.$selectlistBox, event)) return;
  this.isFocus = !this.isFocus;
};

SelectMenu.eventHandler.bodyClick = function (event) {
  if (!_EventEmitter.default.hitElement(this, event) && !_EventEmitter.default.hitElement(this.$selectlistBox, event)) {
    setTimeout(function () {
      this.isFocus = false;
    }.bind(this), 5);
  }
};

SelectMenu.eventHandler.selectListBoxPressItem = function (event) {
  this._value = event.data.value;
  this.$selectlistBox.values = [this._value];
  this.updateItem();

  if (this._lastValue !== this.value) {
    event.lastValue = this._lastValue;
    event.value = this.value;
    setTimeout(function () {
      this.emit('change', event, this);
    }.bind(this), 1);
    this._lastValue = this.value;
  }

  setTimeout(function () {
    this.isFocus = false;
  }.bind(this), 50);
};

SelectMenu.eventHandler.preUpdateListPosition = function () {
  var bound = this.getBoundingClientRect();
  var screenSize = (0, _Dom.getScreenSize)();
  var availableTop = bound.top - 5;
  var availableBot = screenSize.height - 5 - bound.bottom;
  this.$selectlistBox.addStyle('--max-height', Math.max(availableBot, availableTop) + 'px');
  var outBound = (0, _Dom.traceOutBoundingClientRect)(this);

  if (bound.bottom < outBound.top || bound.top > outBound.bottom || bound.right < outBound.left || bound.left > outBound.right) {
    this.isFocus = false;
  }
};

_ACore.default.install(SelectMenu);

var _default = SelectMenu;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SelectBoxItem.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SelectBoxItem.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function SelectBoxItem() {
  this._themeClassName = null;
  this.$text = $('.absol-selectbox-item-text', this);
  this.$close = $('.absol-selectbox-item-close', this);
  this.$close.on('click', this.eventHandler.clickClose);
  this.on('click', this.eventHandler.click);
}

;
SelectBoxItem.tag = 'SelectBoxItem'.toLowerCase();

SelectBoxItem.render = function () {
  return _({
    class: ['absol-selectbox-item'],
    extendEvent: ['close', 'press'],
    child: ['.absol-selectbox-item-text', {
      class: 'absol-selectbox-item-close',
      child: '<span class="mdi mdi-close"></span>'
    }]
  });
};

SelectBoxItem.eventHandler = {};

SelectBoxItem.eventHandler.clickClose = function (event) {
  this.emit('close', event);
};

SelectBoxItem.eventHandler.click = function (event) {
  if (!_EventEmitter.default.hitElement(this.$close, event)) {
    this.emit('press', event, this);
  }
};

SelectBoxItem.property = {};
SelectBoxItem.property.data = {
  set: function (value) {
    this._data = value;
    this.$text.clearChild();
    this.$text.addChild(_('<span>' + this.text + '</span>'));
    if (this._themeClassName) this.removeClass(this._themeClassName);
    this._themeClassName = null;

    if (this.theme) {
      this._themeClassName = 'as-theme-' + this.theme;
      this.addClass(this._themeClassName);
    }
  },
  get: function () {
    return this._data;
  }
};
SelectBoxItem.property.text = {
  get: function () {
    if (typeof this._data == 'string') return this._data;else return this._data.text;
  }
};
SelectBoxItem.property.value = {
  get: function () {
    if (typeof this._data == 'string') return this._data;else return this._data.value;
  }
};
SelectBoxItem.property.theme = {
  get: function () {
    return this._data.theme || null;
  }
};
SelectBoxItem.property.active = {
  set: function (value) {
    if (value) {
      this.addClass('as-active');
    } else {
      this.removeClass('as-active');
    }
  },
  get: function () {
    return this.containsClass('as-active');
  }
};

_ACore.default.install(SelectBoxItem);

var _default = SelectBoxItem;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SelectBox.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SelectBox.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.requireItem = requireItem;
exports.releaseItem = releaseItem;
exports.default = void 0;

require("../css/selectbox.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _SelectMenu = _interopRequireDefault(require("./SelectMenu2"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _PositionTracker = _interopRequireDefault(require("./PositionTracker"));

var _SelectBoxItem = _interopRequireDefault(require("./SelectBoxItem"));

var _SelectListBox = require("./SelectListBox");

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _ResizeSystem = _interopRequireDefault(require("absol/src/HTML5/ResizeSystem"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function pressCloseEventHandler(event) {
  var parentElt = this.$parent;
  if (!parentElt) return;
  var value = this.value;
  var data = this.data;
  var currentValues = parentElt.$selectlistBox.values;
  var index = currentValues.indexOf(value);

  if (index >= 0) {
    currentValues.splice(index, 1);
  }

  parentElt.$selectlistBox.values = currentValues;
  parentElt.$selectlistBox.updatePosition();

  parentElt._updateItems();

  parentElt.emit('remove', Object.assign({}, event, {
    type: 'change',
    target: parentElt,
    data: data,
    value: value,
    itemData: data
  }), parentElt);
  parentElt.emit('change', Object.assign({}, event, {
    type: 'change',
    action: 'remove',
    target: parentElt,
    data: data,
    value: value,
    itemData: data
  }), parentElt);
}

function pressHandler(event) {
  var parentElt = this.$parent;
  if (!parentElt) return;
  var value = this.value;

  if (parentElt.itemFocusable) {
    var prevActiveValue = parentElt.activeValue;

    if (value !== prevActiveValue) {
      parentElt.activeValue = value;
      parentElt.emit('activevaluechange', {
        target: parentElt,
        originEvent: event,
        prevActiveValue: prevActiveValue,
        activeValue: value
      }, parentElt);
    }
  }
}
/***
 *
 * @returns {SelectBoxItem}
 */


function makeItem() {
  return _({
    tag: 'selectboxitem',
    on: {
      close: pressCloseEventHandler,
      press: pressHandler
    }
  });
}

var itemPool = [];

function requireItem($parent) {
  var item;

  if (itemPool.length > 0) {
    item = itemPool.pop();
  } else {
    item = makeItem();
  }

  item.$parent = $parent;
  return item;
}

function releaseItem(item) {
  item.$parent = null;
  itemPool.push(item);
}
/***
 * @extends PositionTracker
 * @return {SelectBox}
 * @constructor
 */


function SelectBox() {
  this.on('click', this.eventHandler.click);
  this.$selectlistBox = _({
    tag: 'selectlistbox',
    props: {
      anchor: [1, 6, 2, 5],
      displayValue: _SelectListBox.VALUE_HIDDEN
    },
    on: {
      preupdateposition: this.eventHandler.preUpdateListPosition,
      pressitem: this.eventHandler.selectListBoxPressItem
    }
  });

  _OOP.default.drillProperty(this, this.$selectlistBox, 'enableSearch');

  this.$items = [];
  this._values = [];
  this.items = [];
  this.values = [];
  this.$selectlistBox.followTarget = this;
  this.disableClickToFocus = false;
  this.orderly = true;
  this.itemFocusable = false;
  this._activeValue = undefined;
  return this;
}

SelectBox.tag = 'selectbox';

SelectBox.render = function () {
  return _({
    tag: 'bscroller',
    class: ['absol-selectbox', 'absol-bscroller'],
    extendEvent: ['change', 'add', 'remove', 'activevaluechange'],
    attr: {
      tabindex: '1'
    }
  }, true);
};

SelectBox.prototype._requireItem = function (n) {
  var itemElt;

  while (this.$items.length < n) {
    itemElt = requireItem(this);
    this.addChild(itemElt);
    this.$items.push(itemElt);
  }

  while (this.$items.length > n) {
    itemElt = this.$items.pop();
    this.removeChild(itemElt);
    releaseItem(itemElt);
  }
};

SelectBox.prototype._assignItems = function (items) {
  for (var i = 0; i < this.$items.length && i < items.length; ++i) {
    this.$items[i].data = items[i];
  }
};
/***
 *
 * @param {string[] | number[]} values
 * @private
 */


SelectBox.prototype._getItemsByValues = function (values) {
  var selectListBoxElt = this.$selectlistBox;
  var itemHolders = values.reduce(function (ac, cr) {
    ac.push.apply(ac, selectListBoxElt.findItemsByValue(cr));
    return ac;
  }, []);

  if (this.orderly) {
    itemHolders.sort(function (a, b) {
      return a.idx - b.idx;
    });
  }

  return itemHolders.map(function (holder) {
    return holder.item;
  });
};

SelectBox.prototype._updateItems = function () {
  var cBound = this.getBoundingClientRect();

  var items = this._getItemsByValues(this._values);

  this._requireItem(items.length);

  this._assignItems(items);

  if (this.itemFocusable) {
    this._updateFocusItem();
  }

  var nBound = this.getBoundingClientRect();

  if (nBound.width != cBound.width || nBound.height != cBound.height) {
    _ResizeSystem.default.updateUp(this);
  }
};

SelectBox.property = {};
SelectBox.property.disabled = _SelectMenu.default.property.disabled;
SelectBox.property.hidden = _SelectMenu.default.property.hidden;
SelectBox.property.isFocus = _SelectMenu.default.property.isFocus;

SelectBox.prototype.init = function (props) {
  props = props || [];
  Object.keys(props).forEach(function (key) {
    if (props[key] === undefined) delete props[key];
  });
  this.super(props);
};

SelectBox.prototype._updateFocusItem = function () {
  for (var i = 0; i < this.$items.length; ++i) {
    this.$items[i].active = this.$items[i].value == this._activeValue;
  }
};

SelectBox.prototype.init = _SelectMenu.default.prototype.init;
SelectBox.property.items = {
  set: function (items) {
    items = items || [];
    this.$selectlistBox.items = items;
    this.addStyle('--list-min-width', this.$selectlistBox._estimateWidth + 'px');

    this._updateItems();
  },
  get: function () {
    return this.$selectlistBox.items;
  }
};
SelectBox.property.values = {
  set: function (values) {
    values = values || [];
    values = values instanceof Array ? values : [values];
    this._values = values;
    this.$selectlistBox.values = values;

    this._updateItems();
  },
  get: function () {
    return this._values || [];
  }
};
SelectBox.property.orderly = {
  set: function (value) {
    var needUpdate = this._orderly === this._orderly;

    if (typeof value === 'function') {
      this._orderly;
    } else this._orderly = !!value;

    if (needUpdate) {
      this.values = this.values;
    }
  },
  get: function () {
    return !!this._orderly;
  }
};
SelectBox.property.disableClickToFocus = {
  set: function (value) {
    if (value) {
      this.addClass('as-disable-click-to-focus');
    } else {
      this.removeClass('as-disable-click-to-focus');
    }
  },
  get: function () {
    return this.containsClass('as-disable-click-to-focus');
  }
};
SelectBox.property.itemFocusable = {
  set: function (value) {
    if (value) {
      this.addClass('as-item-focusable');
    } else {
      this.removeClass('as-item-focusable');
    }

    this._updateFocusItem();
  },
  get: function () {
    return this.containsClass('as-item-focusable');
  }
};
SelectBox.property.activeValue = {
  set: function (value) {
    this._activeValue = value;

    if (this.itemFocusable) {
      this._updateFocusItem(); //todo

    }
  },
  get: function () {
    return this._activeValue;
  }
};
SelectBox.eventHandler = Object.assign({}, _SelectMenu.default.eventHandler);

SelectBox.eventHandler.click = function (event) {
  if (event.target === this && !this.disableClickToFocus) {
    this.isFocus = !this.isFocus;
  }
};

SelectBox.eventHandler.bodyClick = function (event) {
  if (!_EventEmitter.default.hitElement(this.$selectlistBox, event) && event.target !== this) {
    this.isFocus = false;
  }
};

SelectBox.eventHandler.selectListBoxPressItem = function (event) {
  var data = event.data;
  var currentValues = this.$selectlistBox.values;
  currentValues.push(data.value);
  this.$selectlistBox.values = currentValues;
  this.$selectlistBox.updatePosition();
  this._activeValue = data.value;

  this._updateItems();

  this.isFocus = false;
  this.emit('add', Object.assign({}, event, {
    type: 'add',
    target: this,
    value: data.value,
    data: data,
    itemData: data
  }), this);
  this.emit('change', Object.assign({}, event, {
    type: 'change',
    action: 'add',
    target: this,
    value: data.value,
    data: data,
    values: this.values
  }), this);
};

_ACore.default.install(SelectBox);

var _default = SelectBox;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/MultiSelectMenu.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/MultiSelectMenu.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/multiselectmenu.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _SelectMenu = _interopRequireDefault(require("./SelectMenu2"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _PositionTracker = _interopRequireDefault(require("./PositionTracker"));

require("./SelectBoxItem");

var _SelectListBox = require("./SelectListBox");

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _ResizeSystem = _interopRequireDefault(require("absol/src/HTML5/ResizeSystem"));

var _SelectBox = require("./SelectBox");


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends PositionTracker
 * @constructor
 */

function MultiSelectMenu() {
  this.on('click', this.eventHandler.click);
  this.$selectlistBox = _({
    tag: 'selectlistbox',
    props: {
      anchor: [1, 6, 2, 5],
      displayValue: _SelectListBox.VALUE_HIDDEN
    },
    on: {
      preupdateposition: this.eventHandler.preUpdateListPosition,
      pressitem: this.eventHandler.selectListBoxPressItem
    }
  });
  this.$itemCtn = $('.as-multi-select-menu-item-ctn', this);
  this.$attachhook = $('attachhook', this).on('attached', this.eventHandler.attached);

  _OOP.default.drillProperty(this, this.$selectlistBox, 'enableSearch');

  this.$items = [];
  this._values = [];
  this.items = [];
  this.values = [];
  this.$selectlistBox.followTarget = this;
  this.disableClickToFocus = false;
  this.orderly = true;
  this.itemFocusable = false;
  this._activeValue = undefined;
}

MultiSelectMenu.tag = 'MultiSelectMenu'.toLowerCase();

MultiSelectMenu.render = function () {
  return _({
    class: ['as-multi-select-menu'],
    extendEvent: ['change', 'add', 'remove', 'activevaluechange'],
    attr: {
      tabindex: '1'
    },
    child: [{
      class: ['as-multi-select-menu-item-ctn', 'as-bscroller']
    }, {
      tag: 'button',
      class: 'as-multi-select-menu-toggle-btn',
      child: 'dropdown-ico'
    }, 'attachhook']
  });
};

MultiSelectMenu.prototype._requireItem = function (n) {
  var itemElt;

  while (this.$items.length < n) {
    itemElt = (0, _SelectBox.requireItem)(this);
    this.$itemCtn.addChild(itemElt);
    this.$items.push(itemElt);
  }

  while (this.$items.length > n) {
    itemElt = this.$items.pop();
    this.$itemCtn.removeChild(itemElt);
    (0, _SelectBox.releaseItem)(itemElt);
  }
};

MultiSelectMenu.prototype._assignItems = function (items) {
  for (var i = 0; i < this.$items.length && i < items.length; ++i) {
    this.$items[i].data = items[i];
  }
};
/***
 *
 * @param {string[] | number[]} values
 * @private
 */


MultiSelectMenu.prototype._getItemsByValues = function (values) {
  var selectListBoxElt = this.$selectlistBox;
  var itemHolders = values.reduce(function (ac, cr) {
    ac.push.apply(ac, selectListBoxElt.findItemsByValue(cr));
    return ac;
  }, []);

  if (this.orderly) {
    if (typeof this.orderly === 'function') {
      itemHolders.sort(this.orderly);
    } else {
      itemHolders.sort(function (a, b) {
        return a.idx - b.idx;
      });
    }
  }

  return itemHolders.map(function (holder) {
    return holder.item;
  });
};

MultiSelectMenu.prototype._updateItems = function () {
  var cBound = this.getBoundingClientRect();

  var items = this._getItemsByValues(this._values);

  this._requireItem(items.length);

  this._assignItems(items);

  if (this.itemFocusable) {
    this._updateFocusItem();
  }

  var nBound = this.getBoundingClientRect();

  if (nBound.width != cBound.width || nBound.height != cBound.height) {
    _ResizeSystem.default.updateUp(this);
  }
};

MultiSelectMenu.property = {};
MultiSelectMenu.property.disabled = _SelectMenu.default.property.disabled;
MultiSelectMenu.property.hidden = _SelectMenu.default.property.hidden;
MultiSelectMenu.property.isFocus = _SelectMenu.default.property.isFocus;

MultiSelectMenu.prototype.init = function (props) {
  props = props || [];
  Object.keys(props).forEach(function (key) {
    if (props[key] === undefined) delete props[key];
  });
  this.super(props);
};

MultiSelectMenu.prototype._updateFocusItem = function () {
  for (var i = 0; i < this.$items.length; ++i) {
    this.$items[i].active = this.$items[i].value == this._activeValue;
  }
};

MultiSelectMenu.prototype.init = _SelectMenu.default.prototype.init;
MultiSelectMenu.property.items = {
  set: function (items) {
    items = items || [];
    this.$selectlistBox.items = items;
    this.addStyle('--list-min-width', this.$selectlistBox._estimateWidth + 'px');

    this._updateItems();
  },
  get: function () {
    return this.$selectlistBox.items;
  }
};
MultiSelectMenu.property.values = {
  set: function (values) {
    values = values || [];
    values = values instanceof Array ? values : [values];
    this._values = values;
    this.$selectlistBox.values = values;

    this._updateItems();
  },
  get: function () {
    return this._values || [];
  }
};
MultiSelectMenu.property.orderly = {
  set: function (value) {
    var needUpdate = this._orderly === this._orderly;

    if (typeof value === 'function') {
      this._orderly;
    } else this._orderly = !!value;

    if (needUpdate) {
      this.values = this.values;
    }
  },
  get: function () {
    return !!this._orderly;
  }
};
MultiSelectMenu.property.disableClickToFocus = {
  set: function (value) {
    if (value) {
      this.addClass('as-disable-click-to-focus');
    } else {
      this.removeClass('as-disable-click-to-focus');
    }
  },
  get: function () {
    return this.containsClass('as-disable-click-to-focus');
  }
};
MultiSelectMenu.property.itemFocusable = {
  set: function (value) {
    if (value) {
      this.addClass('as-item-focusable');
    } else {
      this.removeClass('as-item-focusable');
    }

    this._updateFocusItem();
  },
  get: function () {
    return this.containsClass('as-item-focusable');
  }
};
MultiSelectMenu.property.activeValue = {
  set: function (value) {
    this._activeValue = value;

    if (this.itemFocusable) {
      this._updateFocusItem(); //todo

    }
  },
  get: function () {
    return this._activeValue;
  }
};
MultiSelectMenu.eventHandler = Object.assign({}, _SelectMenu.default.eventHandler);

MultiSelectMenu.eventHandler.attached = function () {
  var maxHeightStyle = this.getComputedStyleValue('max-height') || 'none';

  if (maxHeightStyle.match(/[0-9-]+px/)) {
    this.addStyle('--multi-select-menu-max-height', maxHeightStyle);
    this.addStyle('max-height', 'unset');
  } else if (maxHeightStyle !== 'none') {
    console.warn('Can not adapt max-height:', maxHeightStyle);
  }
};

MultiSelectMenu.eventHandler.click = function (event) {
  if ((event.target === this || event.target === this.$itemCtn) && !this.disableClickToFocus) {
    this.isFocus = !this.isFocus;
  }
};

MultiSelectMenu.eventHandler.bodyClick = function (event) {
  if (!_EventEmitter.default.hitElement(this.$selectlistBox, event) && event.target !== this && event.target !== this.$itemCtn) {
    this.isFocus = false;
  }
};

MultiSelectMenu.eventHandler.selectListBoxPressItem = function (event) {
  var data = event.data;
  var currentValues = this.$selectlistBox.values;
  currentValues.push(data.value);
  this.$selectlistBox.values = currentValues;
  this.$selectlistBox.updatePosition();
  this._activeValue = data.value;

  this._updateItems();

  this.isFocus = false;
  this.emit('add', Object.assign({}, event, {
    type: 'add',
    target: this,
    value: data.value,
    data: data,
    itemData: data
  }), this);
  this.emit('change', Object.assign({}, event, {
    type: 'change',
    action: 'add',
    target: this,
    value: data.value,
    data: data,
    values: this.values
  }), this);
};

_ACore.default.install(MultiSelectMenu);

var _default = MultiSelectMenu;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/NumberInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/NumberInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/numberinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _Text = require("absol/src/HTML5/Text");

var _int = require("absol/src/Math/int");


var _ = _ACore.default._;
var $ = _ACore.default.$;

function NumberInput() {
  this.eventHandler = _OOP.default.bindFunctions(this, NumberInput.eventHandler);
  this.$input = $('input', this).on('keydown', this.eventHandler.keydown).on('keyup', this.eventHandler.keyup).on('paste', this.eventHandler.paste).on('change', this.eventHandler.change);
  this.$input.value = 0;
  this._previusValue = 0; //to kwnow whenever the value changed

  this._value = 0;
  this._max = Infinity;
  this._min = -Infinity;
  this.$upBtn = $('.absol-number-input-button-up-container button', this).on('mousedown', this.eventHandler.mouseDownUpBtn);
  this.$downBtn = $('.absol-number-input-button-down-container button', this).on('mousedown', this.eventHandler.mouseDownDownBtn);
  this._decimalSeparator = '.';
  this._thousandsSeparator = '';
  this._floatFixed = -1; // unset

  this._decimalPadding = -1; //unset
}

NumberInput.tag = 'NumberInput'.toLowerCase();

NumberInput.render = function () {
  return _({
    class: 'absol-number-input',
    extendEvent: ['change'],
    child: [{
      class: 'absol-number-input-text-container',
      child: 'input[type="text"]'
    }, {
      class: 'absol-number-input-button-up-container',
      child: {
        tag: 'button',
        child: 'span.mdi.mdi-menu-up'
      }
    }, {
      class: 'absol-number-input-button-down-container',
      child: {
        tag: 'button',
        child: 'span.mdi.mdi-menu-down'
      }
    }]
  });
};

NumberInput.eventHandler = {};

NumberInput.eventHandler.mouseDownUpBtn = function (event) {
  if (_EventEmitter.default.isMouseRight(event)) return;
  var self = this;
  var body = $(document.body);
  var pressing = true;
  var timeout = -1;
  var i = 0;

  function tick() {
    if (pressing) {
      if (i == 0 || i >= 4) {
        self.value = Math.round(self.value * Math.pow(10, Math.max(self._floatFixed, 0)) + 1) / Math.pow(10, Math.max(self._floatFixed, 0));
        self.notifyChanged({
          by: 'long_press_button'
        });
      }

      ++i;
      self.__pressingUpTimeout__ = setTimeout(tick, 100);
    }
  }

  function finish(event) {
    pressing = false;

    if (timeout >= 0) {
      clearTimeout(timeout);
      timeout = -1;
    }

    body.off('mouseup', finish);
    body.off('mouseleave', finish);

    if (event.type == 'mouseup') {
      self.$input.focus();
    }

    self.notifyChanged({
      originEvent: event,
      by: 'press_button'
    });
  }

  body.on('mouseup', finish);
  body.on('mouseleave', finish);
  tick();
};

NumberInput.eventHandler.mouseDownDownBtn = function (event) {
  if (_EventEmitter.default.isMouseRight(event)) return;
  var self = this;
  var body = $(document.body);
  var pressing = true;
  var timeout = -1;
  var i = 0;

  function tick() {
    if (pressing) {
      if (i == 0 || i >= 4) {
        self.value = Math.round(self.value * Math.pow(10, Math.max(self._floatFixed, 0)) - 1) / Math.pow(10, Math.max(self._floatFixed, 0));
        self.notifyChanged({
          by: 'long_press_button'
        });
      }

      ++i;
      self.__pressingUpTimeout__ = setTimeout(tick, 100);
    }
  }

  function finish(event) {
    pressing = false;

    if (timeout >= 0) {
      clearTimeout(timeout);
      timeout = -1;
    }

    body.off('mouseup', finish);
    body.off('mouseleave', finish);

    if (event.type == 'mouseup') {
      self.$input.focus();
    }

    self.notifyChanged({
      originEvent: event,
      by: 'press_button'
    });
  }

  body.on('mouseup', finish);
  body.on('mouseleave', finish);
  tick();
};

NumberInput.eventHandler.keyup = function (event) {
  var cValue = parseFloat(this.$input.value);

  if (!isNaN(cValue) && cValue <= this.max && this.min <= cValue) {
    this._value = cValue;
    this.notifyChanged({
      originEvent: event,
      by: 'keyup'
    });
  }
};

NumberInput.eventHandler.keydown = function () {
  var key = event.key;
  var text = this.$input.value;

  if (key && key.length == 1 && !event.ctrlKey) {
    if (key.match(/[0-9.\-\+]/)) {
      if (key == '.' && text.indexOf('.') >= 0) event.preventDefault();
      if ((key == '+' || key == '-') && (text.indexOf('+') >= 0 || text.indexOf('-') >= 0 || (0, _Text.getCaretPosition)(this.$input) > 0)) event.preventDefault();
    } else event.preventDefault();
  }
};

NumberInput.eventHandler.change = function (event) {
  this.value = parseFloat(this.$input.value);
  this.notifyChanged({
    originEvent: event,
    by: 'input_change'
  });
};

NumberInput.eventHandler.paste = function (e) {
  e.preventDefault();
  var text = "";

  if (e.clipboardData && e.clipboardData.getData) {
    text = e.clipboardData.getData("text/plain");
  } else if (window.clipboardData && window.clipboardData.getData) {
    text = window.clipboardData.getData("Text");
  }

  var oldText = this.$input.value;
  var caretPos = (0, _Text.getCaretPosition)(this.$input);
  var newText = oldText.substr(0, caretPos) + text + oldText.substr(caretPos);
  var matched = newText.match(/[+-]?([0-9]*[.])?[0-9]+/);

  if (matched) {
    this.value = parseFloat(matched[0]);
  }
};

NumberInput.prototype.notifyChanged = function (option) {
  option = option || {};

  if (this._previusValue != this.value || this._prevBy !== option.by) {
    this.emit('change', Object.assign({
      target: this,
      value: this.value
    }, option || {}), this);
    this._previusValue = this.value;
    this._prevBy = option.by;
  }
};

NumberInput.prototype.numberToString = function (number) {
  return (0, _int.numberToString)(this._value, this._floatFixed, this._decimalSeparator, this._thousandsSeparator, this._decimalPadding);
};

NumberInput.prototype.updateTextValue = function () {
  if (this._value == Infinity || this._value == -Infinity) this.$input.value = this._value + "";
  this.$input.value = this.numberToString(this._value);
};

NumberInput.prototype.stringToNumber = function (string) {
  var matchedInf = string.toLowerCase().match('/([+-])?infinity/');

  if (matchedInf) {
    if (matchedInf[1] == '-') return Infinity;
    return -Infinity;
  } else if (this._thousandsSeparator == '.') {
    string = string.replace(/\./g, '').replace(/\,/, '.');
  } else if (this._thousandsSeparator == ',') {
    string = string.replace(/\,/g, '');
  }

  return parseFloat(string);
};

NumberInput.property = {};
NumberInput.property.value = {
  set: function (value) {
    if (typeof value != 'number' || isNaN(value)) value = 0;
    this._value = Math.max(this._min, Math.min(this._max, value));
    this.updateTextValue();
  },
  get: function () {
    return this._value;
  }
};
NumberInput.property.max = {
  set: function (value) {
    if (!(typeof value == 'number') || isNaN(value)) {
      value = Infinity;
    }

    this._max = value;
    this._value = Math.min(value, this._value);
    this._min = Math.min(this._min, this._value);
    this.updateTextValue();
  },
  get: function () {
    return this._max;
  }
};
NumberInput.property.min = {
  set: function (value) {
    if (!(typeof value == 'number') || isNaN(value)) {
      value = -Infinity;
    }

    this._min = value;
    this._value = Math.max(value, this._value);
    this._max = Math.max(this._max, this._value);
    this.updateTextValue();
  },
  get: function () {
    return this._min;
  }
};
NumberInput.property.decimalSeparator = {
  set: function (value) {
    if (value == ',') {
      if (this._thousandsSeparator == ',') this._thousandsSeparator = '.';
    } else if (value == '.') {
      if (this._thousandsSeparator == '.') this._thousandsSeparator = ',';
    } else {
      value = '';
    }

    this._decimalSeparator = value;
    this.updateTextValue();
  },
  get: function () {
    return this._decimalSeparator;
  }
};
NumberInput.property.thousandsSeparator = {
  set: function (value) {
    if (value == ',') {
      if (this._decimalSeparator == ',') this._decimalSeparator = '.';
    } else if (value == '.') {
      if (this._decimalSeparator == '.') this._decimalSeparator = ',';
    } else {
      value = '';
    }

    this._thousandsSeparator = value;
    this.updateTextValue();
  },
  get: function () {
    return this._thousandsSeparator;
  }
};
NumberInput.property.floatFixed = {
  set: function (value) {
    if (typeof value == "number") {
      if (isNaN(value)) {
        value = -1;
      } else {
        value = Math.round(Math.max(-1, Math.min(100, value)));
      }
    } else {
      value = -1;
    }

    this._floatFixed = value;
    this.updateTextValue();
  },
  get: function () {
    return this._floatFixed;
  }
};
NumberInput.property.decimalPadding = {
  set: function (value) {
    if (typeof value == "number") {
      if (isNaN(value)) {
        value = 0;
      } else {
        value = Math.round(Math.max(-1, Math.min(100, value)));
      }
    } else {
      value = 0;
    }

    this._decimalPadding = value;
    this.updateTextValue();
  },
  get: function () {
    return this._decimalPadding;
  }
};
NumberInput.property.disabled = {
  set: function (value) {
    this.$input.disabled = !!value;
    this.$upBtn.disabled = !!value;
    this.$downBtn.disabled = !!value;
    if (value) this.addClass('absol-disabled');else this.removeClass('absol-disabled');
  },
  get: function () {
    return this.$input.disabled;
  }
};

_ACore.default.install('NumberInput'.toLowerCase(), NumberInput);

var _default = NumberInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/NumberSpanInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/NumberSpanInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends  AElement
 * @constructor
 */

function NumberSpanInput() {
  this.ev_keydown = this.ev_keydown.bind(this);
  this.on('keydown', this.ev_keydown, true);
  this.readOnly = false;
  this.value = 0;
  this.on('paste', function (event) {
    event.preventDefault();
  });
}

NumberSpanInput.tag = 'NumberSpanInput'.toLowerCase();

NumberSpanInput.render = function () {
  return _({
    tag: 'span',
    child: {
      text: ''
    }
  });
};

NumberSpanInput.prototype.selectAll = function () {
  var sel;

  if (window.getSelection) {
    sel = window.getSelection();
    sel.removeAllRanges();
    var range = document.createRange();
    range.selectNode(this.childNodes[this.childNodes.length - 1]);
    sel.addRange(range);
  } else {
    console.error("TimePicker: Not support!");
  }
};

NumberSpanInput.prototype.selectEnd = function () {
  var sel;

  if (window.getSelection) {
    sel = window.getSelection();
    sel.removeAllRanges();

    this._autoAddZero();

    var length = this.firstChild.data.length;
    var range = document.createRange();
    range.setStart(this.firstChild, length);
    range.setEnd(this.firstChild, length);
    sel.addRange(range);
  } else {
    console.error("TimePicker: Not support!");
  }
};

NumberSpanInput.prototype.selectNone = function () {
  var sel;

  if (document.activeElement === this) {
    sel = window.getSelection();
    sel.removeAllRanges();
  }
};

NumberSpanInput.prototype._autoAddZero = function () {
  if (!this.firstChild) {
    this.addChild(_({
      text: '0'
    }));
  }
};
/***
 *
 * @param {KeyboardEvent} event
 */


NumberSpanInput.prototype.ev_keydown = function (event) {
  if (event.key && event.key.length == 1 && !event.ctrlKey && !event.altKey) {
    if (event.key.match(/[0-9]/)) {} else {
      event.preventDefault();
    }
  } else if (event.key == 'Enter') {
    event.preventDefault();
  }
};

NumberSpanInput.property = {};
NumberSpanInput.property.readOnly = {
  set: function (value) {
    this.contentEditable = !value;
  },
  get: function () {
    return this.contentEditable === false || this.contentEditable === 'false';
  }
};
/***
 *
 * @type {NumberSpanInput}
 */

NumberSpanInput.property.value = {
  set: function (value) {
    this._autoAddZero();

    this.firstChild.data = value + '';
  },
  get: function () {
    return this.firstChild && this.firstChild.data || '';
  }
};

_ACore.default.install(NumberSpanInput);

var _default = NumberSpanInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/OnScreenWidget.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/OnScreenWidget.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/onscreenwidget.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Hanger = _interopRequireDefault(require("./Hanger"));

var _Dom = require("absol/src/HTML5/Dom");

var _Vec = _interopRequireDefault(require("absol/src/Math/Vec2"));

var _stringGenerate = require("absol/src/String/stringGenerate");


var _ = _ACore.default._;
var $ = _ACore.default.$;
var $$ = _ACore.default.$$;
/***
 * @extends Hanger
 * @constructor
 */

function OnScreenWidget() {
  this.id = 'unset-id-' + (0, _stringGenerate.randomIdent)();
  this.on({
    dragstart: this.eventHandler.widgetStartDrag,
    drag: this.eventHandler.widgetDrag,
    dragend: this.eventHandler.widgetDragEnd
  });
  this.addEventListener('click', function (event) {
    if (!this._preventClick) this.emit('click', event, this);
  });
  this.$attachhook = _('attachhook').addTo(this);
  this.$attachhook.on('attached', this.eventHandler.attached);
  this.config = null;
}

OnScreenWidget.tag = 'OnScreenWidget'.toLowerCase();

OnScreenWidget.render = function () {
  return _({
    tag: 'hanger',
    extendEvent: 'click',
    class: 'as-onscreen-widget',
    style: {
      visibility: 'hidden'
    }
  });
};

OnScreenWidget.prototype.configPrefix = 'on-screen-widget-';

OnScreenWidget.prototype._genConfig = function () {
  this._widgetBound = this.getBoundingClientRect();
  var screenSize = (0, _Dom.getScreenSize)();
  return {
    cx: (this._widgetBound.left + this._widgetBound.width / 2) * 100 / screenSize.width,
    cy: (this._widgetBound.top + this._widgetBound.height / 2) * 100 / screenSize.height
  };
};

OnScreenWidget.prototype._saveConfig = function () {
  var id = this.id || '';
  if (id.startsWith('unset-id-') || !this.config) return;
  localStorage.setItem(this.configPrefix + id, JSON.stringify(this.config));
};

OnScreenWidget.prototype._loadConfig = function () {
  var id = this.id || '';
  if (id.startsWith('unset-id-')) return;
  var config = null;

  try {
    config = JSON.parse(localStorage.getItem(this.configPrefix + id));

    if (typeof config !== "object" || typeof config.cx !== "number" || typeof config.cy !== 'number') {
      config = this.config || this._genConfig();
    }
  } catch (error) {
    config = this.config || this._genConfig();
  }

  var cx = config.cx || 0;
  var cy = config.cy || 0;
  this.addStyle({
    '--cx': cx / 100,
    '--cy': cy / 100
  });
  this.config = config;
};

OnScreenWidget.prototype._updateCSSSize = function () {
  var bound = this.getBoundingClientRect();
  this.addStyle({
    '--client-height': bound.height + 'px',
    '--client-width': bound.width + 'px'
  });
  this.removeStyle('visibility');
};
/***
 *
 * @type {OnScreenWidget|{}}
 */


OnScreenWidget.eventHandler = {};

OnScreenWidget.eventHandler.attached = function () {
  var images = $$('img', this);
  var syncs = images.map(function (img) {
    if (img.classList.contains('absol-attachhook')) return Promise.resolve();
    return (0, _Dom.waitImageLoaded)(img, 100);
  });
  var thisW = this;
  Promise.all(syncs).then(function () {
    thisW._updateCSSSize();

    thisW._loadConfig();
  });
};

OnScreenWidget.eventHandler.widgetStartDrag = function (event) {
  this._widgetBound = this.getBoundingClientRect();
  this._preventClick = true;
};

OnScreenWidget.eventHandler.widgetDrag = function (event) {
  event.preventDefault();
  var screenSize = (0, _Dom.getScreenSize)();
  var p0 = new _Vec.default(this._widgetBound.left, this._widgetBound.top);
  var dv = event.currentPoint.sub(event.startingPoint);
  var p1 = p0.add(dv);
  var cx = (p1.x - 2) * 100 / (screenSize.width - this._widgetBound.width - 4);
  var cy = (p1.y - 2) * 100 / (screenSize.height - this._widgetBound.height - 4);
  cx = Math.max(0, Math.min(100, cx));
  cy = Math.max(0, Math.min(100, cy));
  this.addStyle({
    '--cx': cx / 100,
    '--cy': cy / 100
  });

  if (this.config) {
    this.config.cx = cx;
    this.config.cy = cy;
  }
};

OnScreenWidget.eventHandler.widgetDragEnd = function () {
  var thisWG = this;
  setTimeout(function () {
    thisWG._preventClick = false;
  }, 100);

  this._saveConfig();
};

_ACore.default.install(OnScreenWidget);

var _default = OnScreenWidget;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Draggable.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Draggable.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));


function Draggable(element) {
  if (!element) element = _ACore.default._('div');else _ACore.default.$(element);
  element.defineEvent(['predrag', 'drag', 'begindrag', 'enddrag']);

  var body = _ACore.default.$('body');

  var isMoving = false;
  var firstMove = false;
  var offsetX;
  var offsetY;
  var fontSize;
  var left0em, top0em, left0, top0;

  var finishMoving = function (event) {
    if (isMoving) {
      isMoving = false;
      body.off('mousemove', mouseMoveEventHandler);
      event.moveDX = event.clientX - offsetX;
      event.moveDY = event.clientY - offsetY;
      event.moveDXem = event.moveDX / fontSize;
      event.moveDYem = event.moveDY / fontSize;
      event.moveToX = left0 + event.moveDX;
      event.moveToY = top0 + event.moveDY;
      element.emit('enddrag', event);
    }
  };

  var mouseUpEventHandler = function (event) {
    finishMoving(event);
  };

  var mouseMoveEventHandler = function (event) {
    event.preventDefault();
    event.moveDX = event.clientX - offsetX;
    event.moveDY = event.clientY - offsetY;
    event.moveDXem = event.moveDX / fontSize;
    event.moveDYem = event.moveDY / fontSize;
    event.moveToX = left0 + event.moveDX;
    event.moveToY = top0 + event.moveDY;
    event.moveToXem = left0em + event.moveDXem;
    event.moveToYem = top0em + event.moveDYem;

    if (firstMove) {
      firstMove = false;
      element.emit('begindrag', event);
    }

    element.emit('drag', event);
  };

  var mouseOutEventHandler = function (event) {
    finishMoving(event);
  };

  var mouseDownEventHandler = function (event) {
    isMoving = true;
    firstMove = true;
    body.on('mousemove', mouseMoveEventHandler);
    body.once('mouseleave', mouseOutEventHandler);
    body.once('mouseup', mouseUpEventHandler);
    fontSize = this.getFontSize();
    offsetX = event.clientX;
    offsetY = event.clientY;
    left0 = parseFloat(element.getComputedStyleValue('left').replace('px', ''));
    top0 = parseFloat(element.getComputedStyleValue('top').replace('px', ''));
    left0em = left0 / fontSize;
    top0em = top0 / fontSize;
    event.x0 = left0;
    event.y0 = top0;
    event.y0em = left0em;
    event.y0em = top0em;
    element.emit('predrag', event);
  };

  element.on('mousedown', mouseDownEventHandler);
  return element;
}

;
var _default = Draggable;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/OnsScreenWindow.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/OnsScreenWindow.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/onscreenwindow.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _Draggable = _interopRequireDefault(require("./Draggable"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function OnScreenWindow() {
  var res = this;
  this._lastSize = {
    width: 0,
    height: 0
  };
  res.$headerbar = $('.absol-onscreen-window-head-bar', res).on('dragstart', res.eventHandler.beginDragHeaderbar);
  res.$bottomResizer = $('.absol-onscreen-window-resizer.absol-onscreen-window-resize-bottom', res).on('dragstart', res.eventHandler.beginDragBottom);
  res.$rightResizer = $('.absol-onscreen-window-resizer.absol-onscreen-window-resize-right', res).on('dragstart', res.eventHandler.beginDragRight);
  res.$topResizer = $('.absol-onscreen-window-resizer.absol-onscreen-window-resize-top', res).on('dragstart', res.eventHandler.beginDragTop);
  res.$leftResizer = $('.absol-onscreen-window-resizer.absol-onscreen-window-resize-left', res).on('dragstart', res.eventHandler.beginDragLeft);
  res.$bottomRightResizer = $('.absol-onscreen-window-resizer.absol-onscreen-window-resize-bottom-right', res).on('dragstart', res.eventHandler.beginDragButtonRight);
  res.$bottomLeftResizer = $('.absol-onscreen-window-resizer.absol-onscreen-window-resize-bottom-left', res).on('dragstart', res.eventHandler.beginDragBottomLeft);
  res.$topLeftResizer = $('.absol-onscreen-window-resizer.absol-onscreen-window-resize-top-left', res).on('dragstart', res.eventHandler.beginDragTopLeft);
  res.$topRightResizer = $('.absol-onscreen-window-resizer.absol-onscreen-window-resize-top-right', res).on('dragstart', res.eventHandler.beginDragTopRight);
  res.$headerButtonCtn = $('.absol-onscreen-window-head-bar-buttons', res.$headerbar);
  res.$windowIcon = $('span.absol-onscreen-window-head-bar-icon.mdi.mdi-settings', res);
  res.$windowTitle = $('.absol-onscreen-window-head-bar-title', res);
  res._windowIcon = 'span.absol-onscreen-window-head-bar-icon.mdi.mdi-settings';
  res._windowTitle = '';
  res.$bodyContainer = $('.absol-onscreen-window-body-container', res);
  res.$attachhook = _('attachhook').addTo(res).on('error', function () {
    this.updateSize = this.updateSize || res.relocation.bind(res);

    _Dom.default.addToResizeSystem(this);
  });
  res.$minimizeBtn = $('button.absol-onscreen-window-head-bar-button-minimize', res);
  res.$closeBtn = $('button.absol-onscreen-window-head-bar-button-close', res);
  res.$dockBtn = $('button.absol-onscreen-window-head-bar-button-dock', res);
}

OnScreenWindow.tag = 'OnScreenWindow'.toLowerCase();

OnScreenWindow.render = function () {
  return _({
    extendEvent: ['sizechange', 'drag', 'relocation'],
    class: 'absol-onscreen-window',
    child: {
      class: 'absol-onscreen-window-content',
      child: [{
        tag: 'hanger',
        class: 'absol-onscreen-window-head-bar',
        child: ['span.absol-onscreen-window-head-bar-icon.mdi.mdi-settings', {
          tag: 'span',
          class: 'absol-onscreen-window-head-bar-title',
          child: {
            text: ''
          }
        }, {
          class: "absol-onscreen-window-head-bar-buttons",
          child: [{
            tag: 'button',
            class: 'absol-onscreen-window-head-bar-button-minimize',
            child: 'span.mdi.mdi-window-minimize'
          }, {
            tag: 'button',
            class: 'absol-onscreen-window-head-bar-button-dock',
            child: 'span.mdi.mdi-dock-window'
          }, {
            tag: 'button',
            class: 'absol-onscreen-window-head-bar-button-close',
            child: 'span.mdi.mdi-close'
          }]
        }]
      }, {
        class: 'absol-onscreen-window-body-container'
      }, 'hanger.absol-onscreen-window-resizer.absol-onscreen-window-resize-bottom', 'hanger.absol-onscreen-window-resizer.absol-onscreen-window-resize-top', 'hanger.absol-onscreen-window-resizer.absol-onscreen-window-resize-left', 'hanger.absol-onscreen-window-resizer.absol-onscreen-window-resize-right', 'hanger.absol-onscreen-window-resizer.absol-onscreen-window-resize-bottom-right', 'hanger.absol-onscreen-window-resizer.absol-onscreen-window-resize-bottom-left', 'hanger.absol-onscreen-window-resizer.absol-onscreen-window-resize-top-left', 'hanger.absol-onscreen-window-resizer.absol-onscreen-window-resize-top-right']
    }
  });
};

OnScreenWindow.prototype.maybeSizeChange = function () {
  var bound = this.getBoundingClientRect();

  if (this._lastSize.width !== bound.width || this._lastSize.height !== bound.height) {
    this._lastSize = bound;
    window.dispatchEvent(new Event('resize'));
    this.emit('sizechange', {
      size: bound,
      target: this,
      type: 'sizechange'
    }, this);
  }
};

OnScreenWindow.eventHandler = {};

OnScreenWindow.eventHandler.beginDragHeaderbar = function (event) {
  if (!_EventEmitter.default.hitElement(this.$headerButtonCtn, event)) {
    this.$headerbar.on('drag', this.eventHandler.dragHeaderbar);
    this.$headerbar.on('dragend', this.eventHandler.endDragHeaderbar);

    var screenSize = _Dom.default.getScreenSize();

    var bound = this.getBoundingClientRect();
    this.__moveData__ = {
      bound: bound,
      modal: _('.absol-onscreen-window-moving-modal').addTo(document.body),
      maxLeft: screenSize.width - bound.width - 1,
      maxY: screenSize.height - bound.height - 1
    };
  }
};

OnScreenWindow.eventHandler.dragHeaderbar = function (event) {
  var d = event.currentPoint.sub(event.startingPoint);
  var dx = d.x;
  var dy = d.y;
  var newX = Math.max(0, Math.min(this.__moveData__.maxLeft, this.__moveData__.bound.left + dx));
  var newY = Math.max(0, Math.min(this.__moveData__.maxY, this.__moveData__.bound.top + dy));
  this.addStyle({
    top: newY + 'px',
    left: newX + 'px'
  });
  this.emit('drag', event, this);
};

OnScreenWindow.eventHandler.endDragHeaderbar = function (event) {
  this.$headerbar.off('drag', this.eventHandler.dragHeaderbar);
  this.$headerbar.off('dragend', this.eventHandler.endDragHeaderbar);

  this.__moveData__.modal.remove();

  this.__moveData__ = undefined;
  this.emit('relocation', {
    type: 'relocation',
    target: this
  }, this);
};

OnScreenWindow.eventHandler.beginDragBottom = function (event) {
  if (event.target != this.$bottomResizer) return;
  this.$bottomResizer.on('drag', this.eventHandler.dragBottom);
  this.$bottomResizer.on('dragend', this.eventHandler.endDragBottom);

  var screenSize = _Dom.default.getScreenSize();

  var bound = this.getBoundingClientRect();
  this.__moveData__ = {
    bound: bound,
    minHeight: this.getFontSize() * 1.4,
    maxHeight: screenSize.height - bound.top,
    modal: _('.absol-onscreen-window-moving-modal.absol-onscreen-window-resize-bottom').addTo(document.body)
  };
};

OnScreenWindow.eventHandler.dragBottom = function (event) {
  var d = event.currentPoint.sub(event.startingPoint);
  var dy = d.y;
  var newHeight = Math.max(this.__moveData__.minHeight, Math.min(this.__moveData__.maxHeight, this.__moveData__.bound.height + dy));
  this.addStyle('height', newHeight + 'px');
  this.maybeSizeChange();
};

OnScreenWindow.eventHandler.endDragBottom = function (event) {
  this.$bottomResizer.off('drag', this.eventHandler.dragBottom);
  this.$bottomResizer.off('dragend', this.eventHandler.endDragBottom);

  this.__moveData__.modal.remove();

  this.__moveData__ = undefined;
};

OnScreenWindow.eventHandler.beginDragRight = function (event) {
  if (event.target != this.$rightResizer) return;
  this.$rightResizer.on('drag', this.eventHandler.dragRight);
  this.$rightResizer.on('dragend', this.eventHandler.endDragRight);

  var screenSize = _Dom.default.getScreenSize();

  var bound = this.getBoundingClientRect();
  var minWidth = this.$windowTitle.getBoundingClientRect().right - bound.left + this.$headerButtonCtn.getBoundingClientRect().width;
  this.__moveData__ = {
    minWidth: minWidth,
    bound: bound,
    maxWidth: screenSize.width - bound.left,
    modal: _('.absol-onscreen-window-moving-modal.absol-onscreen-window-resize-right').addTo(document.body)
  };
};

OnScreenWindow.eventHandler.dragRight = function (event) {
  var d = event.currentPoint.sub(event.startingPoint);
  var dx = d.x;
  var newWidth = Math.max(this.__moveData__.minWidth, Math.min(this.__moveData__.maxWidth, this.__moveData__.bound.width + dx));
  this.addStyle('width', newWidth + 'px');
  this.maybeSizeChange();
};

OnScreenWindow.eventHandler.endDragRight = function (event) {
  this.$rightResizer.off('drag', this.eventHandler.dragRight);
  this.$rightResizer.off('dragend', this.eventHandler.endDragRight);

  this.__moveData__.modal.remove();

  this.__moveData__ = undefined;
};

OnScreenWindow.eventHandler.beginDragTop = function (event) {
  if (event.target != this.$topResizer) return;
  this.$topResizer.on('drag', this.eventHandler.dragTop);
  this.$topResizer.on('dragend', this.eventHandler.endDragTop); // var screenSize = Dom.getScreenSize();

  var bound = this.getBoundingClientRect();
  var fontSize = this.getFontSize();
  this.__moveData__ = {
    fontSize: fontSize,
    bound: bound,
    maxTop: bound.bottom - 1.4 * fontSize,
    modal: _('.absol-onscreen-window-moving-modal.absol-onscreen-window-resize-top').addTo(document.body)
  };
};

OnScreenWindow.eventHandler.dragTop = function (event) {
  var d = event.currentPoint.sub(event.startingPoint);
  var dy = d.y;
  var newTop = Math.max(0, Math.min(this.__moveData__.maxTop, this.__moveData__.bound.top + dy));
  var newHeight = this.__moveData__.bound.bottom - newTop;
  this.addStyle({
    'top': newTop + 'px',
    'height': newHeight + 'px'
  });
  this.emit('relocation', {
    type: 'relocation',
    target: this
  }, this);
  this.maybeSizeChange();
};

OnScreenWindow.eventHandler.endDragTop = function (event) {
  this.$topResizer.off('drag', this.eventHandler.dragTop);
  this.$topResizer.off('dragend', this.eventHandler.endDragTop);

  this.__moveData__.modal.remove();

  this.__moveData__ = undefined;
};

OnScreenWindow.eventHandler.beginDragLeft = function (event) {
  if (event.target != this.$leftResizer) return;
  this.$leftResizer.on('drag', this.eventHandler.dragLeft);
  this.$leftResizer.on('dragend', this.eventHandler.endDragLeft);
  var bound = this.getBoundingClientRect();
  var minWidth = this.$windowTitle.getBoundingClientRect().right - bound.left + this.$headerButtonCtn.getBoundingClientRect().width;
  this.__moveData__ = {
    maxLeft: bound.right - minWidth,
    bound: bound,
    modal: _('.absol-onscreen-window-moving-modal.absol-onscreen-window-resize-left').addTo(document.body)
  };
};

OnScreenWindow.eventHandler.dragLeft = function (event) {
  var d = event.currentPoint.sub(event.startingPoint);
  var dx = d.x;
  var newLeft = Math.max(0, Math.min(this.__moveData__.maxLeft, this.__moveData__.bound.left + dx));
  var newWidth = this.__moveData__.bound.right - newLeft;
  this.addStyle({
    width: newWidth + 'px',
    left: newLeft + 'px'
  });
  this.emit('relocation', {
    type: 'relocation',
    target: this
  }, this);
  this.maybeSizeChange();
};

OnScreenWindow.eventHandler.endDragLeft = function (event) {
  this.$leftResizer.off('drag', this.eventHandler.dragLeft);
  this.$leftResizer.off('dragend', this.eventHandler.endDragLeft);

  this.__moveData__.modal.remove();

  this.__moveData__ = undefined;
}; //todo


OnScreenWindow.eventHandler.beginDragButtonRight = function (event) {
  if (event.target != this.$bottomRightResizer) return;
  this.$bottomRightResizer.on('drag', this.eventHandler.dragButtonRight);
  this.$bottomRightResizer.on('dragend', this.eventHandler.endDragButtonRight);

  var screenSize = _Dom.default.getScreenSize();

  var bound = this.getBoundingClientRect();
  var minWidth = this.$windowTitle.getBoundingClientRect().right - bound.left + this.$headerButtonCtn.getBoundingClientRect().width;
  this.__moveData__ = {
    minHeight: this.getFontSize() * 1.4,
    minWidth: minWidth,
    bound: bound,
    maxWidth: screenSize.width - bound.left,
    maxHeight: screenSize.height - bound.top,
    modal: _('.absol-onscreen-window-moving-modal.absol-onscreen-window-resize-bottom-right').addTo(document.body)
  };
};

OnScreenWindow.eventHandler.dragButtonRight = function (event) {
  var d = event.currentPoint.sub(event.startingPoint);
  var dx = d.x;
  var dy = d.y;
  var newWidth = Math.max(this.__moveData__.minWidth, Math.min(this.__moveData__.maxWidth, this.__moveData__.bound.width + dx));
  var newHeight = Math.max(this.__moveData__.minHeight, Math.min(this.__moveData__.maxHeight, this.__moveData__.bound.height + dy));
  this.addStyle('width', newWidth + 'px');
  this.addStyle('height', newHeight + 'px');
  this.maybeSizeChange();
};

OnScreenWindow.eventHandler.endDragButtonRight = function (event) {
  this.$bottomRightResizer.off('drag', this.eventHandler.dragButtonRight);
  this.$bottomRightResizer.off('dragend', this.eventHandler.endDragButtonRight);

  this.__moveData__.modal.remove();

  this.__moveData__ = undefined;
};

OnScreenWindow.eventHandler.beginDragBottomLeft = function (event) {
  if (event.target != this.$bottomLeftResizer) return;
  this.$bottomLeftResizer.on('drag', this.eventHandler.dragBottomLeft);
  this.$bottomLeftResizer.on('dragend', this.eventHandler.endDragBottomLeft);
  var bound = this.getBoundingClientRect();
  var minWidth = this.$windowTitle.getBoundingClientRect().right - bound.left + this.$headerButtonCtn.getBoundingClientRect().width;

  var screenSize = _Dom.default.getScreenSize();

  this.__moveData__ = {
    maxLeft: bound.right - minWidth,
    bound: bound,
    minHeight: this.getFontSize() * 1.4,
    maxHeight: screenSize.height - bound.top,
    modal: _('.absol-onscreen-window-moving-modal.absol-onscreen-window-resize-bottom-left').addTo(document.body)
  };
};

OnScreenWindow.eventHandler.dragBottomLeft = function (event) {
  var d = event.currentPoint.sub(event.startingPoint);
  var dx = d.x;
  var dy = d.y;
  var newLeft = Math.max(0, Math.min(this.__moveData__.maxLeft, this.__moveData__.bound.left + dx));
  var newWidth = this.__moveData__.bound.right - newLeft;
  var newHeight = Math.max(this.__moveData__.minHeight, Math.min(this.__moveData__.maxHeight, this.__moveData__.bound.height + dy));
  this.addStyle('height', newHeight + 'px');
  this.addStyle({
    width: newWidth + 'px',
    left: newLeft + 'px'
  });
  this.emit('relocation', {
    type: 'relocation',
    target: this
  }, this);
};

OnScreenWindow.eventHandler.endDragBottomLeft = function (event) {
  this.$bottomLeftResizer.off('drag', this.eventHandler.dragLeft);
  this.$bottomLeftResizer.off('dragend', this.eventHandler.endDragLeft);

  this.__moveData__.modal.remove();

  this.__moveData__ = undefined;
};

OnScreenWindow.eventHandler.beginDragTopLeft = function (event) {
  if (event.target != this.$topLeftResizer) return;
  this.$topLeftResizer.on('drag', this.eventHandler.dragTopLeft);
  this.$topLeftResizer.on('dragend', this.eventHandler.endDragTopLeft);
  var bound = this.getBoundingClientRect();
  var fontSize = this.getFontSize();
  var minWidth = this.$windowTitle.getBoundingClientRect().right - bound.left + this.$headerButtonCtn.getBoundingClientRect().width;
  this.__moveData__ = {
    maxLeft: bound.right - minWidth,
    fontSize: fontSize,
    bound: bound,
    maxTop: bound.bottom - 1.4 * fontSize,
    modal: _('.absol-onscreen-window-moving-modal.absol-onscreen-window-resize-top-left').addTo(document.body)
  };
};

OnScreenWindow.eventHandler.dragTopLeft = function (event) {
  var d = event.currentPoint.sub(event.startingPoint);
  var dx = d.x;
  var dy = d.y;
  var newTop = Math.max(0, Math.min(this.__moveData__.maxTop, this.__moveData__.bound.top + dy));
  var newHeight = this.__moveData__.bound.bottom - newTop;
  var newLeft = Math.max(0, Math.min(this.__moveData__.maxLeft, this.__moveData__.bound.left + dx));
  var newWidth = this.__moveData__.bound.right - newLeft;
  this.addStyle({
    top: newTop + 'px',
    height: newHeight + 'px',
    width: newWidth + 'px',
    left: newLeft + 'px'
  });
  this.emit('relocation', {
    type: 'relocation',
    target: this
  }, this);
  this.maybeSizeChange();
};

OnScreenWindow.eventHandler.endDragTopLeft = function (event) {
  this.$topLeftResizer.off('drag', this.eventHandler.dragTopLeft);
  this.$topLeftResizer.off('dragend', this.eventHandler.endDragTopLeft);

  this.__moveData__.modal.remove();

  this.__moveData__ = undefined;
};

OnScreenWindow.eventHandler.beginDragTopRight = function (event) {
  if (event.target != this.$topRightResizer) return;
  this.$topRightResizer.on('drag', this.eventHandler.dragTopRight);
  this.$topRightResizer.on('dragend', this.eventHandler.endDragTopRight);

  var screenSize = _Dom.default.getScreenSize();

  var bound = this.getBoundingClientRect();
  var fontSize = this.getFontSize();
  var minWidth = this.$windowTitle.getBoundingClientRect().right - bound.left + this.$headerButtonCtn.getBoundingClientRect().width;
  this.__moveData__ = {
    minWidth: minWidth,
    fontSize: fontSize,
    bound: bound,
    maxWidth: screenSize.width - bound.left,
    maxTop: bound.bottom - 1.4 * fontSize,
    modal: _('.absol-onscreen-window-moving-modal.absol-onscreen-window-resize-top-right').addTo(document.body)
  };
};

OnScreenWindow.eventHandler.dragTopRight = function (event) {
  var d = event.currentPoint.sub(event.startingPoint);
  var dx = d.x;
  var dy = d.y;
  var newWidth = Math.max(this.__moveData__.minWidth, Math.min(this.__moveData__.maxWidth, this.__moveData__.bound.width + dx));
  var newTop = Math.max(0, Math.min(this.__moveData__.maxTop, this.__moveData__.bound.top + dy));
  var newHeight = this.__moveData__.bound.bottom - newTop;
  this.addStyle({
    'top': newTop + 'px',
    'height': newHeight + 'px',
    width: newWidth + 'px'
  });
  this.emit('relocation', {
    type: 'relocation',
    target: this
  }, this);
  this.maybeSizeChange();
};

OnScreenWindow.eventHandler.endDragTopRight = function (event) {
  this.$topRightResizer.off('drag', this.eventHandler.dragTopRight);
  this.$topRightResizer.off('dragend', this.eventHandler.endDragTopRight);

  this.__moveData__.modal.remove();

  this.__moveData__ = undefined;
};

['addChild', 'addChildBefore', 'addChildAfter', 'clearChild', 'findChildBefore', 'findChildAfter'].forEach(function (key) {
  OnScreenWindow.prototype[key] = function () {
    return this.$bodyContainer[key].apply(this.$bodyContainer, arguments);
  };
});
OnScreenWindow.property = {};
OnScreenWindow.property.windowIcon = {
  set: function (value) {
    this._windowIcon = value;

    if (this.$windowIcon) {
      this.$windowIcon.remove();
      this.$windowIcon = undefined;
    }

    if (value) {
      this.$windowIcon = _(value).addClass('absol-onscreen-window-head-bar-icon');
      this.$headerbar.addChildBefore(this.$windowIcon, this.$headerbar.childNodes[0]);
    }
  },
  get: function () {
    return this._windowIcon;
  }
};
OnScreenWindow.property.windowTitle = {
  set: function (value) {
    this._windowTitle = value;
    this.$windowTitle.clearChild().addChild(_({
      text: '' + value
    }));
  },
  get: function () {
    return this._windowTitle;
  }
};

OnScreenWindow.prototype.relocation = function () {
  var bound = this.getBoundingClientRect();

  var screenSize = _Dom.default.getScreenSize();

  var isRelocated = false;

  if (bound.bottom >= screenSize.height) {
    this.addStyle('top', Math.max(0, screenSize.height - bound.height) + 'px');
    isRelocated = true;
  }

  if (bound.right >= screenSize.width) {
    this.addStyle('left', Math.max(0, screenSize.width - bound.width) + 'px');
    isRelocated = true;
  }

  if (isRelocated) {
    this.emit('relocation', {
      type: 'relocation',
      target: this
    }, this);
  }
};

_ACore.default.install(OnScreenWindow);

var _default = OnScreenWindow;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/PageSelector.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/PageSelector.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/pageselector.css");

var _ACore = _interopRequireDefault(require("../ACore"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function PageSelector() {
  this.$pageInput = $('.absol-page-number-input input', this);
  this.$pageInput.on('keyup', this.eventHandler.pressEnterKey);
  this.$prevBtn = $('li.page-previous', this);
  this.$nextBtn = $('li.page-next', this);
  this.$firstBtn = $('li.page-first', this);
  this.$lastBtn = $('li.page-last', this);
  this.$nextBtn.on('click', this.eventHandler.clickNext);
  this.$prevBtn.on('click', this.eventHandler.clickPrev);
  this.$firstBtn.on('click', this.eventHandler.clickFirst);
  this.$lastBtn.on('click', this.eventHandler.clickLast);
  this.$buttonContainer = $('.absol-page-number-buttons', this);
  this._buttons = [];
  this._pageOffset = 1;
  this._selectedIndex = 1;
  this._pageCount = 1;
  this._pageRange = 1;
  this.$pageInput.value = this._selectedIndex;
}

PageSelector.tag = 'PageSelector'.toLowerCase();

PageSelector.render = function () {
  return _({
    class: ['absol-page-selector'],
    extendEvent: ['change'],
    child: [{
      class: 'absol-page-number-input',
      child: [{
        tag: 'label',
        child: {
          text: "Page"
        }
      }, {
        tag: 'input',
        attr: {
          type: 'text'
        }
      }]
    }, {
      tag: 'ul',
      class: 'absol-page-number-buttons',
      child: [' <li class="page-first">\
                        <a aria-controls="dtBasicExample" data-dt-idx="0" tabindex="0" class="absol-page-link">First</a>\
                    </li>', ' <li class="page-previous">\
                        <a aria-controls="dtBasicExample" data-dt-idx="0" tabindex="0" class="absol-page-link">Previous</a>\
                    </li>', '<li class="page-next" >\
                        <a aria-controls="dtBasicExample" data-dt-idx="7" tabindex="0" class="absol-page-link">Next</a>\
                    </li>', ' <li class="page-last">\
                        <a aria-controls="dtBasicExample" data-dt-idx="0" tabindex="0" class="absol-page-link">Last</a>\
                    </li>']
    }]
  });
};

PageSelector.eventHandler = {};

PageSelector.eventHandler.pressEnterKey = function (event) {
  if (event.keyCode != 13) return;
  var index = parseInt(this.$pageInput.value.trim(), 10);

  if (index < 1 || index > this._pageCount) {
    this.$pageInput.value = this._selectedIndex;
    return;
  }

  this.selectPage(index, true);
};

PageSelector.eventHandler.clickLast = function (event) {
  this.selectPage(this._pageCount, true);
};

PageSelector.eventHandler.clickFirst = function (event) {
  this.selectPage(1, true);
};

PageSelector.eventHandler.clickNext = function (event) {
  if (this._selectedIndex == this._pageCount) return;
  this.selectPage(this._selectedIndex + 1, true);
};

PageSelector.eventHandler.clickPrev = function (event) {
  if (this._selectedIndex == 1) return;
  this.selectPage(this._selectedIndex - 1, true);
};

PageSelector.eventHandler.clickIndex = function (index, event) {
  this.selectPage(index + this._pageOffset, true);
};

PageSelector.prototype._createButton = function (index) {
  var button = _({
    tag: 'li',
    class: 'absol-page-number',
    child: {
      tag: 'a',
      attr: {
        'data-index': index
      },
      child: {
        text: '' + index
      }
    },
    on: {
      click: PageSelector.eventHandler.clickIndex.bind(this, index)
    }
  });

  this.$buttonContainer.addChildBefore(button, this.$nextBtn);
  return button;
};

PageSelector.prototype.setPageRange = function (pageCount) {
  this._pageRange = pageCount;
  if (this._buttons.length > 0) throw new Error("Not implement change pageCount");

  while (this._buttons.length < pageCount) {
    this._buttons.push(this._createButton(this._buttons.length));
  }
};

PageSelector.prototype.setStartPage = function (index) {
  this._buttons.forEach(function (e, i) {
    e.childNodes[0].innerHTML = i + index + '';
  });

  this._pageOffset = index;
};

PageSelector.prototype.selectPage = function (index, userActive) {
  if (index == this._selectedIndex) this.setStartPage(index - parseInt(this._pageRange / 2));

  if (index > this._selectedIndex) {
    if (index == this._pageOffset + this._pageRange - 1) this.setStartPage(index - parseInt(this._pageRange / 2));
  }

  if (index < this._selectedIndex) {
    if (index == this._pageOffset) this.setStartPage(index - parseInt(this._pageRange / 2));
  }

  if (index > this._pageCount - parseInt(this._pageRange / 2)) this.setStartPage(this._pageCount - this._pageRange + 1);
  if (index <= parseInt(this._pageRange / 2)) this.setStartPage(1);
  var pageOffset = this._pageOffset;

  this._buttons.forEach(function (e, i) {
    if (i + pageOffset == index) {
      e.addClass('active');
    } else {
      e.removeClass('active');
    }
  });

  if (this._selectedIndex != index) {
    this._selectedIndex = index;
    this.$pageInput.value = index;
    this.emit('change', {
      target: this,
      selectedIndex: index,
      userActive: !!userActive
    }, this);
  }
};

PageSelector.prototype.getSelectedPage = function () {
  return this._selectedIndex;
};

PageSelector.prototype.setPageCount = function (count) {
  this._pageCount = count;
};

PageSelector.property = {};

PageSelector.prototype.init = function (props) {
  props = props || {};
  props.pageOffset = props.pageOffset || 1;
  props.pageRange = props.pageRange || 5;
  props.pageCount = props.pageCount || 15;
  props.selectedIndex = typeof props.selectedIndex == "number" ? props.selectedIndex : props.pageOffset;
  if (props.pageCount < props.pageRange) props.pageRange = props.pageCount;
  this.setPageCount(props.pageCount);
  this.setPageRange(props.pageRange);
  this.setStartPage(props.pageOffset);
  this.selectPage(props.selectedIndex);
};

_ACore.default.install(PageSelector);

var _default = PageSelector;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/PreInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/PreInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/preinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _file = require("absol/src/Converter/file");

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _BrowserDetector = _interopRequireDefault(require("absol/src/Detector/BrowserDetector"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
var textDelay = _BrowserDetector.default.isSafari ? 100 : 1;
/***
 * @extends AElement
 * @constructor
 */

function PreInput() {
  this.defineEvent(['pasteimg', 'pastetext', 'change']);
  this.on('paste', this.eventHandler.paste);
  this.on('keydown', this.eventHandler.keydown);
  this.history = [];
  this.historyIndex = -1;
  this.commitChange('', 0);
}

PreInput.tag = 'preinput';

PreInput.render = function () {
  return _({
    tag: 'pre',
    class: 'as-preinput',
    attr: {
      contenteditable: 'true'
    },
    child: 'br'
  });
};

PreInput.prototype.applyData = function (text, offset) {
  var textNode = _({
    text: text
  });

  this.clearChild().addChild(textNode).addChild(_('br'));

  if (document.activeElement == this && this.isDescendantOf(document.body)) {
    if (document.getSelection) {
      var sel = document.getSelection();
      sel.removeAllRanges();
      var range = document.createRange();

      if (typeof offset == 'number') {
        range.setStart(textNode, Math.min(text.length, offset));
      } else {
        range.setStart(textNode, Math.min(text.length, offset.start));
        range.setEnd(textNode, Math.min(text.length, offset.end));
      }

      sel.addRange(range);
      this.scrollIntoRange(range);
    } else {
      console.error("PreInput: Not support!");
    }
  }
};

PreInput.prototype.scrollIntoRange = function (range) {
  var elementBound = range.getBoundingClientRect();
  var viewportBound = this.getBoundingClientRect();
  var dBottom = 0;
  if (range.startContainer && range.startContainer.data && range.startContainer.data.charAt(range.startContainer.data.length - 1) == '\n') dBottom += this.getFontSize() * 1.5;
  var currentScrollTop = this.scrollTop;
  var newScrollTop = currentScrollTop;

  if (elementBound.bottom + dBottom > viewportBound.bottom) {
    newScrollTop = currentScrollTop + (elementBound.bottom + dBottom - viewportBound.bottom);
  }

  if (elementBound.top < viewportBound.top) {
    newScrollTop = currentScrollTop - (viewportBound.top - elementBound.top);
  }

  if (newScrollTop != currentScrollTop) {
    this.scrollTop = newScrollTop;
  }

  var currentScrollLeft = this.scrollLeft;
  var newScrollLeft = currentScrollLeft;

  if (elementBound.right > viewportBound.right) {
    newScrollLeft = currentScrollLeft + (elementBound.right - viewportBound.right);
  }

  if (elementBound.left < viewportBound.left) {
    newScrollLeft = currentScrollLeft - (viewportBound.left - elementBound.left);
  }

  if (newScrollLeft != currentScrollLeft) {
    this.scrollLeft = newScrollLeft;
  }
};

PreInput.prototype.undo = function () {
  if (this.historyIndex <= 0) return;
  this.historyIndex--;
  var record = this.history[this.historyIndex];
  this.applyData(record.text, record.offset);
  this.emit('change', {
    target: this,
    value: record.text,
    action: 'undo',
    record: record,
    type: 'change'
  }, this);
};

PreInput.prototype.redo = function () {
  if (this.historyIndex + 1 >= this.history.length) return;
  this.historyIndex++;
  var record = this.history[this.historyIndex];
  this.applyData(record.text, record.offset);
  this.emit('change', {
    target: this,
    value: record.text,
    action: 'redo',
    record: record,
    type: 'change'
  }, this);
};

PreInput.prototype.commitChange = function (text, offset) {
  while (this.historyIndex < this.history.length - 1) {
    this.history.pop();
  }

  var lastText = this.history.length > 0 ? this.history[this.history.length - 1].text : null;

  if (text === lastText) {
    if (this.history[this.history.length - 1].offset != offset) this.history[this.history.length - 1].offset = offset;
  } else {
    this.historyIndex = this.history.length;
    var record = {
      text: text,
      offset: offset
    };
    this.history.push(record);
    this.emit('change', {
      target: this,
      value: record.text,
      action: 'commit',
      record: record,
      type: 'change'
    }, this);
  }
};

PreInput.prototype.waitToCommit = function (text, offset) {
  var thisInput = this;
  if (this._commitTimeout > 0) clearTimeout(this._commitTimeout);
  this._commitTimeout = setTimeout(function () {
    thisInput.commitChange(text, offset);
  }, textDelay);
};

PreInput.prototype.getPosition = function (node, offset) {
  if (!node) return NaN;
  if (node == this) return offset;
  var parent = node.parentElement;
  if (!parent) return NaN;
  var text = '';
  var child;
  var lastBr = false;

  for (var i = 0; i < parent.childNodes.length; ++i) {
    child = parent.childNodes[i];
    if (child == node) break;
    text += this.stringOf(child);
  }

  return this.getPosition(parent, text.length + offset);
};

PreInput.prototype.getSelectPosition = function () {
  if (window.getSelection) {
    var sel = window.getSelection();

    if (sel.getRangeAt && sel.rangeCount) {
      var range = sel.getRangeAt(0);
      var direction = 'forward';
      var cmpPosition = sel.anchorNode.compareDocumentPosition(sel.focusNode);

      if (cmpPosition === 4) {
        direction = 'forward';
      } else if (cmpPosition === 2) {
        direction = 'backward';
      } else if (!cmpPosition && sel.anchorOffset > sel.focusOffset || cmpPosition === Node.DOCUMENT_POSITION_PRECEDING) {
        direction = 'backward';
      }

      var startOffset = this.getPosition(range.startContainer, range.startOffset);
      var endOffset = this.getPosition(range.endContainer, range.endOffset);
      if (isNaN(startOffset)) return null;
      return {
        start: startOffset,
        end: endOffset,
        direction: direction
      };
    }
  } else if (document.selection) {
    console.error('May not support!');
  }
};

PreInput.prototype.stringOf = function (node) {
  if (!node) return '';

  if (node.nodeType == 3) {
    return node.data;
  }

  if (node.tagName == 'BR' || node.tagName == 'br') {
    return '\n';
  }

  var thisInput = this;
  return Array.prototype.map.call(node.childNodes, function (cNode, index, arr) {
    if ((cNode.tagName == 'BR' || cNode.tagName == 'br') && index + 1 >= arr.length) return '';
    return thisInput.stringOf(cNode);
  }).join('');
};

PreInput.prototype._pasteText = function (text) {
  var sel = window.getSelection();
  var range;

  if (window.getSelection) {
    sel = window.getSelection();

    if (sel.getRangeAt && sel.rangeCount) {
      try {
        range = sel.getRangeAt(0);
        range.deleteContents();

        var textNode = _({
          text: text
        });

        range.insertNode(textNode);

        if (sel.removeRange) {
          sel.removeRange(range);
        } else {
          sel.removeAllRanges();
        }

        range = document.createRange();
        range.setStart(textNode, text.length);
        sel.addRange(range);
        this.scrollIntoRange(range);
        this.commitChange(this.stringOf(this), this.getPosition(textNode, text.length));
      } catch (error) {
        alert(error.message);
      }
    }
  } else if (document.selection && document.selection.createRange) {
    document.selection.createRange().text = text;
    this.commitChange(this.stringOf(this), this.getPosition(textNode, text.length));
    console.error('May not support!');
  }
};
/**
 * @type {PreInput}
 */


PreInput.eventHandler = {};

PreInput.eventHandler.paste = function (event) {
  var thisIp = this;
  var clipboardData = event.clipboardData || window.clipboardData;
  /**Safari bug */

  if (clipboardData) {
    if (clipboardData.items) {
      var items = Array.prototype.slice.call(clipboardData.items);
      var imgItems = items.filter(function (item) {
        return item.type.indexOf('image') >= 0;
      });
      var plainTextItems = items.filter(function (item) {
        return item.type.indexOf('text/plain') >= 0;
      });

      if (imgItems.length > 0) {
        var imgFiles = imgItems.map(function (it) {
          return it.getAsFile();
        });
        this.emit('pasteimg', {
          target: this,
          imageFile: imgFiles[0],
          imageFiles: imgFiles,
          orginEvent: event
        }, this);
      } else if (plainTextItems.length > 0) {
        var plainTextItem = plainTextItems[0]; //only one item

        plainTextItem.getAsString(function (text) {
          thisIp._pasteText(text);
        });
      } else {
        window.ABSOL_DEBUG && console.error("Can not handle clipboard data");
      }

      event.preventDefault();
    } else {
      var text = event.clipboardData.getData('text/plain');

      if (text) {
        event.preventDefault();

        this._pasteText(text);
      } else {
        var currentText = this.stringOf(this);
        var currentSelection = this.getSelectPosition();
        setTimeout(function () {
          var images = [];
          $('img', thisIp, function (elt) {
            images.push(elt);
          });
          Promise.all(images.map(function (img) {
            return _Dom.default.imageToCanvas(img).then(function (canvas) {
              var dataURI = canvas.toDataURL();
              var blob = (0, _file.dataURItoBlob)(dataURI);
              var file = (0, _file.blobToFile)(blob);
              return {
                file: file,
                blob: blob,
                url: dataURI
              };
            }, function (error) {
              console.error(error);
            }).catch(function (error) {
              console.error(error);
            });
          })).then(function (results) {
            results = results.filter(function (it) {
              return !!it;
            });

            if (results.length > 0) {
              var imgFiles = results.map(function (it) {
                return it.file;
              });
              var urls = results.map(function (it) {
                return it.url;
              });
              thisIp.emit('pasteimg', {
                target: this,
                imageFile: imgFiles[0],
                imageFiles: imgFiles,
                urls: urls,
                url: urls[0],
                orginEvent: event
              }, thisIp);
            }
          });
          thisIp.applyData(currentText, currentSelection);
        }, textDelay);
      }
    }
  } else {
    setTimeout(function () {
      if (window.getSelection) {
        var sel = window.getSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          var range = sel.getRangeAt(0);
          var text = this.stringOf(this);
          var offset = this.getPosition(range.startContainer, range.startOffset);
          this.waitToCommit(text, offset);
        }
      } else if (document.selection) {
        console.error('May not support!');
      }
    }.bind(this), textDelay);
  }
};

PreInput.eventHandler.keydown = function (event) {
  if (event.ctrlKey) {
    switch (event.key) {
      case 'z':
        this.undo();
        event.preventDefault();
        break;

      case 'y':
        this.redo();
        event.preventDefault();
        break;

      default:
        break;
    }
  }

  if (!event.ctrlKey && !event.altKey) {
    setTimeout(function () {
      if (window.getSelection) {
        var sel = window.getSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          var range = sel.getRangeAt(0);
          var text = this.stringOf(this);
          var offset = this.getPosition(range.startContainer, range.startOffset);
          this.waitToCommit(text, offset);
        }
      } else if (document.selection) {
        console.error('May not support!');
      }
    }.bind(this), textDelay);
  }
};

PreInput.property = {};
PreInput.property.value = {
  set: function (value) {
    value = value || '';
    this.applyData(value, value.length);
    this.commitChange(value, value.length);
  },
  get: function () {
    return this.stringOf(this);
  }
};
PreInput.property.disabled = {
  set: function (value) {
    value = !!value;
    if (value === this.containsClass('as-disabled')) return;

    if (value) {
      this.addClass('as-disabled');
      this.attr({
        contenteditable: undefined,
        oncut: 'return false',
        onpaste: 'return false',
        onkeydown: 'if(event.metaKey) return true; return false;'
      });
    } else {
      this.removeClass('as-disabled');
      this.attr({
        contenteditable: true,
        oncut: undefined,
        onpaste: undefined,
        onkeydown: undefined
      });
    }
  },
  get: function () {
    return this.containsClass('as-disabled');
  }
};

_ACore.default.install(PreInput);

var _default = PreInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/ProgressBar.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/ProgressBar.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/progressbar.css");

var _ACore = _interopRequireDefault(require("../ACore"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function ProgressBar() {
  this._value = 0;
  this._variant = null;
  this.$value = $('.as-progress-bar-value', this);
  this._striped = false;
  this._animated = false;
}

ProgressBar.tag = 'ProgressBar'.toLowerCase();

ProgressBar.render = function () {
  return _({
    class: 'as-progress-bar',
    child: {
      class: 'as-progress-bar-value'
    }
  });
};

ProgressBar.property = {};
/**
 * @type {ProgressBar}
 */

ProgressBar.property.variant = {
  set: function (value) {
    if (this._variant) {
      this.removeClass('as-variant-' + this._variant);
    }

    if (value) {
      this.addClass('as-variant-' + value);
    } else {
      value = null;
    }

    this._variant = value;
  },
  get: function () {
    return this._variant;
  }
};
/**
 * @type {ProgressBar}
 */

ProgressBar.property.value = {
  set: function (value) {
    value = Math.max(0, Math.min(1, value || 0));
    this._value = value;
    this.$value.addStyle('width', value * 100 + '%');
  },
  get: function () {
    return this._value;
  }
};
ProgressBar.property.animated = {
  set: function (value) {
    value = !!value;
    this._striped = value;

    if (value) {
      this.addClass('as-animated');
    } else {
      this.removeClass('as-animated');
    }
  },
  get: function () {
    return this._animated;
  }
};
ProgressBar.property.striped = {
  set: function (value) {
    value = !!value;
    this._striped = value;

    if (value) {
      this.addClass('as-striped');
    } else {
      this.removeClass('as-striped');
    }
  },
  get: function () {
    return this._striped;
  }
};

_ACore.default.install(ProgressBar);

var _default = ProgressBar;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/QuickListButton.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/QuickListButton.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/quicklistbutton.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _FollowerToggler = _interopRequireDefault(require("./FollowerToggler"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/****
 * @extends FollowerToggler
 * @constructor
 */

function QuickListButton() {
  this.$shareFollower = QuickListButton.getFollower();

  _({
    tag: 'followertoggler',
    elt: this,
    on: {
      preopen: this.eventHandler.preopen,
      close: this.eventHandler.closeFollower
    }
  });

  this.bindFollower(this.$shareFollower);
  this.$iconCtn.remove();
  this.$content.addChild(this.$iconCtn);
  this._items = this._items;
  this._anchor = [];
  this.$list = null;
  this._listUpdated = true;
  this._opened = false;
  this.anchor = [12, 13, 15, 14]; //todo: add property
}

QuickListButton.$follower = _('follower.as-quick-list-button-follower');

QuickListButton.getFollower = function () {
  if (!QuickListButton.$follower) QuickListButton.$follower = _('follower.as-quick-list-button-follower');
  return QuickListButton.$follower;
};

QuickListButton.tag = 'QuickListButton'.toLowerCase();

QuickListButton.render = function () {
  return _({
    tag: 'flexiconbutton',
    class: 'as-quick-list-button',
    extendEvent: 'select',
    props: {
      text: "+ Thêm",
      icon: 'span.mdi.mdi-menu-down'
    }
  });
};

QuickListButton.property = {};
QuickListButton.property.items = {
  set: function (value) {
    value = value || [];
    this._items = value;
    this._listUpdated = false;
  },
  get: function () {
    return this._items;
  }
};
/**
 * @type {QuickListButton}
 */

QuickListButton.eventHandler = {};

QuickListButton.eventHandler.preopen = function () {
  this.$shareFollower.addTo(document.body);
  this.$shareFollower.anchor = this.anchor;

  if (this.$list == null) {
    this.$list = _('selectlist.absol-bscroller').on('pressitem', this.eventHandler.pressitem);
  }

  if (!this._listUpdated) {
    this._listUpdated = true;
    this.$list.items = this._items;
  }

  this.$shareFollower.addChild(this.$list);
  this.$shareFollower.on({
    preupdateposition: this.eventHandler.preUpdatePosition
  });
};

QuickListButton.eventHandler.preUpdatePosition = function () {
  var bound = this.getBoundingClientRect();

  var screenSize = _Dom.default.getScreenSize();

  var maxHeight = Math.max(screenSize.height - bound.bottom, bound.top) - 10;
  this.$list.addStyle('max-height', maxHeight + 'px');
};

QuickListButton.eventHandler.closeFollower = function () {
  this.$shareFollower.off({
    preupdateposition: this.eventHandler.preUpdatePosition
  });
};

QuickListButton.eventHandler.pressitem = function (event) {
  this.close();
  this.emit('select', Object.assign({}, event, {
    type: 'select',
    target: this
  }));
};

_ACore.default.install(QuickListButton);

var _default = QuickListButton;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/QuickMenu.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/QuickMenu.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireWildcard(require("absol/src/HTML5/Dom"));

var _Rectangle = _interopRequireDefault(require("absol/src/Math/Rectangle"));

var _BrowserDetector = _interopRequireDefault(require("absol/src/Detector/BrowserDetector"));

require("./Menu");

var _utils = require("./utils");




var isMobile = _BrowserDetector.default.isMobile;
var _ = _ACore.default._;
var $ = _ACore.default.$;

function QuickMenu() {
  //like context menu without right-click
  this._contextMenuSync = Promise.resolve();
}

QuickMenu.tag = 'QuickMenu'.toLowerCase();

QuickMenu.render = function () {
  return _({
    tag: 'vmenu',
    extendEvent: 'requestcontextmenu',
    class: ['as-quick-menu', 'as-bscroller'],
    style: {
      'overflow-y': 'auto',
      'box-sizing': 'border-box'
    }
  });
};

_ACore.default.install(QuickMenu);

QuickMenu.PRIORITY_ANCHORS = [0, 3, 7, 4, 1, 2, 6, 5];
QuickMenu.DEFAULT_ANCHOR = 0;
QuickMenu.$elt = _('quickmenu');
QuickMenu.$element = undefined;
QuickMenu.$anchor = _('.absol-context-menu-anchor.as-context-menu-ctn');
QuickMenu.$anchor.addChild(QuickMenu.$elt);
QuickMenu._acceptAnchors = 0;
QuickMenu._previewAnchor = QuickMenu.DEFAULT_ANCHOR;
QuickMenu._session = Math.random() * 10000000000 >> 0;
QuickMenu._menuListener = undefined;
QuickMenu._scrollOutListener = undefined;
QuickMenu.$elt.on('press', function (event) {
  if (QuickMenu._menuListener) QuickMenu._menuListener((0, _utils.cleanMenuItemProperty)(event.menuItem));
});

QuickMenu.updatePosition = function () {
  if (!QuickMenu.$element) return;
  var menu = QuickMenu.$elt;
  var anchor = QuickMenu.$anchor;
  var eBound = QuickMenu.$element.getBoundingClientRect();
  var outBound = (0, _Dom.traceOutBoundingClientRect)(QuickMenu.$element);

  if (eBound.bottom < outBound.top || eBound.left > outBound.right || eBound.top > outBound.bottom || eBound.right < outBound.left) {
    QuickMenu._scrollOutListener && QuickMenu._scrollOutListener();
  }

  var qBound = menu.getBoundingClientRect();
  outBound = (0, _Dom.getScreenSize)();
  outBound.left = 0;
  outBound.right = outBound.width;
  outBound.top = 0;
  outBound.bottom = outBound.height; //padding

  outBound.left += 2;
  outBound.top += 2;
  outBound.bottom -= 2;
  outBound.right -= 2;
  outBound.height -= 4;
  outBound.width -= 4;

  var getPos = function (anchor) {
    anchor = anchor % 8;
    var x = 0;
    var y = 0;

    if (anchor == 0 || anchor == 3) {
      y = eBound.top;
    }

    if (anchor == 0 || anchor == 7) {
      x = eBound.right;
    }

    if (anchor == 1 || anchor == 6) {
      x = eBound.left;
    }

    if (anchor == 1 || anchor == 2) {
      y = eBound.bottom;
    }

    if (anchor == 2 || anchor == 5) {
      x = eBound.right - qBound.width;
    }

    if (anchor == 3 || anchor == 4) {
      x = eBound.left - qBound.width;
    }

    if (anchor == 4 || anchor == 7) {
      y = eBound.bottom - qBound.height;
    }

    if (anchor == 5 || anchor == 6) {
      y = eBound.top - qBound.height;
    }

    return {
      x: x,
      y: y
    };
  };

  var pos;
  var bestSquare = -1;
  var bestRect;
  var priority = (typeof QuickMenu._previewAnchor === 'number' ? [QuickMenu._previewAnchor] : []).concat(QuickMenu._acceptAnchors);

  if (priority.length) {
    var cAnchor;
    var outRect = new _Rectangle.default(outBound.left, outBound.top, outBound.width, outBound.height);
    var menuRect;
    var viewSquare;
    var cPos;

    for (var i = 0; i < priority.length; ++i) {
      cAnchor = priority[i];
      cPos = getPos(cAnchor);
      menuRect = new _Rectangle.default(cPos.x, cPos.y, qBound.width, qBound.height);
      viewSquare = outRect.collapsedSquare(menuRect);

      if (viewSquare - 0.01 > bestSquare) {
        bestSquare = viewSquare;
        pos = cPos;
        QuickMenu._previewAnchor = cAnchor;
        bestRect = outRect.collapsedRect(menuRect);
      }
    }

    anchor.addStyle({
      left: pos.x + 'px',
      top: pos.y + 'px'
    });
  } else {
    anchor.removeStyle({
      left: null,
      top: null
    });
  }
};

QuickMenu._scrollEventHandler = QuickMenu.updatePosition.bind(QuickMenu);
QuickMenu.$scrollTrackElements = [];

QuickMenu.show = function (element, menuProps, anchor, menuListener, darkTheme) {
  var menuElt = QuickMenu.$elt;
  var anchorElt = QuickMenu.$anchor; //untrack all element

  QuickMenu.$scrollTrackElements.forEach(function (e) {
    if (e.removeEventListener) e.removeEventListener('scroll', QuickMenu._scrollEventHandler, false);else e.dettachEvent('onscroll', QuickMenu._scrollEventHandler, false);
  });
  QuickMenu.$scrollTrackElements = [];

  if (typeof anchor == 'number') {
    QuickMenu._acceptAnchors = [anchor];
  } else if (anchor instanceof Array) {
    QuickMenu._acceptAnchors = anchor;
  } else if (anchor === 'modal') {
    QuickMenu._acceptAnchors = [];
  } else {
    QuickMenu._acceptAnchors = QuickMenu.PRIORITY_ANCHORS;
  }

  if (anchor === 'modal') {
    QuickMenu.$anchor.addClass('as-anchor-modal');
  } else {
    QuickMenu.$anchor.removeClass('as-anchor-modal');
  }

  QuickMenu._previewAnchor = QuickMenu._acceptAnchors[0];
  QuickMenu._session = Math.random() * 10000000000 >> 0;
  QuickMenu.$anchor.addTo(document.body);

  _Dom.default.addToResizeSystem(QuickMenu.$elt);

  QuickMenu.$elt.updateSize = QuickMenu.updatePosition.bind(QuickMenu);
  QuickMenu.$element = element;
  QuickMenu.$element.classList.add('as-quick-menu-attached');
  QuickMenu._menuListener = menuListener;
  Object.assign(menuElt, menuProps);
  if (darkTheme) anchorElt.addClass('dark');else anchorElt.removeClass('dark');
  menuElt.addStyle('visibility', 'hidden'); //for prevent size change blink

  QuickMenu.$anchor.addClass('absol-active');
  QuickMenu.updatePosition();
  setTimeout(function () {
    menuElt.addStyle('visibility', 'visible');
  }, isMobile ? 33 : 2); //track element

  var trackElt = element.parentElement;

  while (trackElt) {
    // trackElt.addEventListener('scroll', QuickMenu._scrollEventHandler, false);
    if (trackElt.addEventListener) trackElt.addEventListener('scroll', QuickMenu._scrollEventHandler, false);else trackElt.attachEvent('onscroll', QuickMenu._scrollEventHandler, false);
    QuickMenu.$scrollTrackElements.push(trackElt);
    trackElt = trackElt.parentElement;
  }

  if (document.addEventListener) {
    document.addEventListener('scroll', QuickMenu._scrollEventHandler, false);
  } else {
    document.attachEvent('onscroll', QuickMenu._scrollEventHandler, false);
  }

  QuickMenu.$scrollTrackElements.push(document);
  return QuickMenu._session;
};

QuickMenu.close = function (session) {
  if (session !== true && session !== QuickMenu._session) return;
  QuickMenu._session = Math.random() * 10000000000 >> 0;
  if (QuickMenu.$element) QuickMenu.$element.classList.remove('as-quick-menu-attached');
  QuickMenu.$element = undefined;
  QuickMenu._menuListener = undefined;
  QuickMenu._previewAnchor = QuickMenu.DEFAULT_ANCHOR; //untrack all element

  QuickMenu.$scrollTrackElements.forEach(function (e) {
    e.removeEventListener('scroll', QuickMenu._scrollEventHandler, false);
  });
  QuickMenu.$scrollTrackElements = [];
  var menuElt = QuickMenu.$elt;
  menuElt.removeStyle('visibility'); //for prevent size change blink

  menuElt.removeStyle({
    left: true,
    top: true
  });
  QuickMenu.$anchor.removeClass('absol-active');
  QuickMenu.$anchor.remove();
};

QuickMenu.showWhenClick = function (element, menuProps, anchor, menuListener, darkTheme) {
  var res = {
    menuProps: menuProps,
    anchor: anchor,
    currentSession: undefined,
    element: element,
    menuListener: menuListener,
    darkTheme: darkTheme
  };

  var clickHandler = function () {
    if (QuickMenu._session === res.currentSession) return;
    res.currentSession = QuickMenu.show(res.element, res.menuProps, res.anchor, res.menuListener, res.darkTheme);

    var finish = function () {
      document.body.removeEventListener('click', finish, false);
      QuickMenu.close(res.currentSession);
      res.currentSession = undefined;
      if (QuickMenu._scrollOutListener === finish) QuickMenu._scrollOutListener = undefined;
    };

    QuickMenu._scrollOutListener = finish;
    setTimeout(function () {
      document.body.addEventListener('click', finish, false);
    }, 10);
  };

  res.remove = function () {
    element.removeEventListener('click', clickHandler, false);
    element.classList.remove('as-quick-menu-trigger');
  };

  element.addEventListener('click', clickHandler, false);
  element.classList.add('as-quick-menu-trigger');
  return res;
};
/**
 * @typedef {Object} QuickMenuAdaptor
 * @property {Function} getFlowedElement default is trigger
 * @property {Function} getMenuProps define menuProps if un-change
 * @property {Function} getAnchor default is 'auto', define anchor if un-change
 * @property {Function} onClose callback
 * @property {Function} onOpen callback
 * @property {Function} onSelect calback
 * @property {Function} isDarkTheme default is false, define darkThem if un-change
 *
 *
 * @typedef {Object} QuickMenuDataHolder
 * @property {Function} remove
 *
 * @param {Element} trigger
 * @param {QuickMenuAdaptor} adaptor
 * @returns {QuickMenuDataHolder}
 */


QuickMenu.toggleWhenClick = function (trigger, adaptor) {
  var res = {
    trigger: trigger,
    adaptor: adaptor,
    currentSession: undefined
  };

  var clickHandler = function () {
    if (QuickMenu._session === res.currentSession) return;
    res.currentSession = QuickMenu.show(res.adaptor.getFlowedElement ? res.adaptor.getFlowedElement() : trigger, res.adaptor.getMenuProps ? res.adaptor.getMenuProps() : adaptor.menuProps || [], res.adaptor.getAnchor ? res.adaptor.getAnchor() : adaptor.anchor || 'auto', res.adaptor.onSelect, res.adaptor.isDarkTheme ? res.adaptor.isDarkTheme() : !!res.adaptor.darkTheme);
    if (res.adaptor.onOpen) res.adaptor.onOpen();

    var finish = function () {
      document.body.removeEventListener('click', finish, false);
      QuickMenu.close(res.currentSession);
      if (adaptor.onClose) adaptor.onClose();
      res.currentSession = undefined;
      if (QuickMenu._scrollOutListener === finish) QuickMenu._scrollOutListener = undefined;
    };

    QuickMenu._scrollOutListener = finish;
    setTimeout(function () {
      document.body.addEventListener('click', finish, false);
    }, 10);
  };

  res.remove = function () {
    trigger.removeEventListener('click', clickHandler, false);
    trigger.classList.remove('as-quick-menu-trigger');
  };

  trigger.addEventListener('click', clickHandler, false);
  trigger.classList.add('as-quick-menu-trigger');
  return res;
};

var _default = QuickMenu;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/QuickPath.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/QuickPath.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/quickpath.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _QuickMenu = _interopRequireDefault(require("./QuickMenu"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function QuickPath() {
  this._holders = [];
}
/**
 * @type {QuickPath}
 */


QuickPath.eventHandler = {};

QuickPath.eventHandler.click = function (event) {
  var button = this._fileButton(event.target);

  if (button) this.pressButton(button);
};

QuickPath.tag = 'QuickPath'.toLowerCase();
/**
 * @returns {QuickPath}
 */

QuickPath.render = function () {
  return _({
    class: 'absol-quick-path',
    extendEvent: ['change', 'press']
  });
};

QuickPath.prototype.updatePath = function () {
  this.clearChild();
  var self = this;
  this._holders = this._path.map(function (data, index) {
    var holder = self._createButton(data, index);

    holder.buttom.addTo(self);
    return holder;
  });
};

QuickPath.prototype._createButton = function (pathItem, index) {
  var buttom = _({
    tag: 'expnode',
    class: 'absol-quick-path-btn',
    attr: {
      'data-index': '' + index
    }
  });

  buttom.status = 'close';
  buttom.name = pathItem.name;

  if (pathItem.icon) {
    buttom.icon = pathItem.icon;
  }

  if (pathItem.iconSrc) {
    buttom.icon = {
      tag: 'img',
      props: {
        src: pathItem.iconSrc
      }
    };
  }

  var thisQuickpath = this;

  if (pathItem.items) {
    _QuickMenu.default.toggleWhenClick(buttom, {
      getAnchor: function () {
        return [1, 2, 6, 5];
      },
      getMenuProps: function () {
        return {
          extendStyle: {
            fontSize: buttom.getComputedStyleValue('font-size')
          },
          items: pathItem.items.map(function (it, menuIndex) {
            var res = {
              text: it.name,
              menuIndex: menuIndex,
              icon: it.iconSrc ? {
                tag: 'img',
                props: {
                  src: it.iconSrc
                }
              } : it.icon || undefined,
              extendStyle: it.extendStyle || {},
              extendClass: it.extendClass || []
            };
            return res;
          })
        };
      },
      onOpen: function () {
        buttom.status = 'open';
        thisQuickpath.emit('press', {
          target: thisQuickpath,
          pathItem: pathItem,
          index: index
        }, thisQuickpath);
      },
      onClose: function () {
        buttom.status = 'close';
      },
      onSelect: function (item) {
        var dataItem = pathItem.items[item.menuIndex];
        thisQuickpath.emit('change', {
          target: thisQuickpath,
          pathItem: pathItem,
          item: dataItem,
          index: index
        }, thisQuickpath);
        thisQuickpath.status = 'close';
      }
    });
  } else {
    buttom.on('click', function () {
      this.emit('press', {
        target: thisQuickpath,
        pathItem: pathItem,
        index: index
      }, thisQuickpath);
    });
  }

  return {
    buttom: buttom
  };
};

QuickPath.prototype.push = function (item) {
  this.path.push(item);

  var holder = this._createButton(item, this.path.length - 1);

  this.addChild(holder, buttom);

  this._holders.push(holder);
};

QuickPath.prototype.clear = function () {
  this.path = [];
  this._holders = [];
};

QuickPath.prototype.pop = function () {
  //todo
  var res = this.path.pop();
  var button = $('button[data-index="' + this.path.length + '"]');
  if (button) button.remove();
  return res;
};

QuickPath.property = {};
/**
 * @typedef PathElement
 * @property {String} name
 * @property {String} icon
 * @property {Array<String>} items
 *
 */

QuickPath.property.path = {
  /**
   * @param {Array<PathElement>} value
   */
  set: function (value) {
    this._path = value || [];
    this.updatePath();
  },
  get: function () {
    return this._path || [];
  }
};
QuickPath.property.textPath = {
  get: function () {
    return this.path.join('/');
  }
};

_ACore.default.install('quickpath', QuickPath);

var _default = QuickPath;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/RadioButton.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/RadioButton.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/radiobutton.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function RadioButton() {
  var thisRB = this;
  this.defineEvent('change');
  this.$input = $('input', this).on('change', this.notifyChange.bind(this));

  _OOP.default.drillProperty(this, this.$input, ['value', 'checked']);
}

RadioButton.tag = 'radiobutton';
RadioButton.radioProto = _('<svg class="absol-radio-icon" width="20" height="20" version="1.1" viewBox="0 0 5.2917 5.2917"' + '   xmlns="http://www.w3.org/2000/svg">' + '    <g transform="translate(0 -291.71)">' + '        <circle class="bound" cx="2.6458" cy="294.35" r="2.4626" style="stroke-opacity:.99497;stroke-width:.26458;" />' + '        <circle class="dot" cx="2.6458" cy="294.35"  r= "0.92604" style="fill-rule:evenodd;" />' + '    </g>' + '</svg>');

RadioButton.render = function () {
  return _({
    tag: 'label',
    class: 'absol-radio-button',
    child: [{
      tag: 'input',
      attr: {
        type: 'radio'
      }
    }, RadioButton.radioProto.cloneNode(true)]
  });
};

RadioButton.prototype.notifyChange = function () {
  this.emit('change', {
    type: 'change',
    checked: this.checked,
    target: this
  }, this);
};

RadioButton.prototype.getAllFriend = function () {
  return Radio.getAllByName(this.name);
};

RadioButton.attribute = {
  checked: {
    set: function (value) {
      if (value == 'false' || value == null) {
        this.checked = false;
      } else {
        this.checked = true;
      }
    },
    get: function () {
      return this.checked ? 'true' : 'false';
    },
    remove: function () {
      this.checked = false;
    }
  },
  disabled: {
    set: function (value) {
      if (value == 'false' || value == null) {
        this.disabled = false;
      } else {
        this.disabled = true;
      }
    },
    get: function () {
      return this.disabled ? 'true' : 'false';
    },
    remove: function () {
      this.disabled = false;
    }
  },
  name: {
    set: function (value) {
      this.name = value;
    },
    get: function () {
      return this.name;
    },
    remove: function () {
      this.name = null;
    }
  }
};
RadioButton.property = {
  name: {
    set: function (name) {
      if (name == null) this.$input.removeAttribute('name');else this.$input.setAttribute('name', name);
    },
    get: function () {
      return this.$input.getAttribute('name');
    }
  },
  disabled: {
    set: function (value) {
      this.$input.disabled = !!value;

      if (value) {
        this.addClass('disabled');
      } else {
        this.removeClass('disabled');
      }
    },
    get: function () {
      return this.$input.disabled;
    }
  }
};

RadioButton.getAllByName = function (name) {
  return (document.getElementsByTagName('input') || []).filter(function (elt) {
    return elt.getAttribute('type') == 'radio' && elt.getAttribute('name') == name;
  });
};

RadioButton.getValueByName = function (name) {
  var inputs = RadioButton.getAllByName(name);
  var res = null;
  var input;

  for (var i = 0; i < inputs.length; ++i) {
    input = inputs[i];

    if (input.checked) {
      res = input.value;
    }
  }

  return res;
};

RadioButton.autoReplace = function () {
  var placeHolders = Array.prototype.slice.call(document.getElementsByTagName(this.tag));
  var ph;
  var attOfPH;
  var attrs;
  var style;
  var classList;
  var attNode;
  var attrName, attrValue;
  var props;

  for (var i = 0; i < placeHolders.length; ++i) {
    ph = placeHolders[i];
    attOfPH = ph.attributes;
    classList = [];
    style = {};
    attrs = {};
    props = {};

    for (var j = 0; j < attOfPH.length; ++j) {
      attNode = attOfPH[j];
      attrName = attNode.nodeName;
      attrValue = attNode.nodeValue;

      if (attrName == 'style') {
        attrValue.trim().split(';').reduce(function (style, prop) {
          var p = prop.split(':');

          if (p.length == 2) {
            style[p[0].trim()] = p[1].trim();
          }

          return style;
        }, style);
      } else if (attrName == 'class') {
        classList = attrValue.trim().split(/\s+/);
      } else if (attrName == 'onchange') {
        props.onchange = new Function('event', 'sender', attrValue);
      } else {
        attrs[attrName] = attrValue;
      }
    }

    var newElt = _({
      tag: this.tag,
      attr: attrs,
      class: classList,
      style: style,
      props: props
    });

    $(ph).selfReplace(newElt);
  }
};

RadioButton.initAfterLoad = function () {
  _Dom.default.documentReady.then(function () {
    RadioButton.autoReplace();
  });
};

_ACore.default.install('RadioButton'.toLowerCase(), RadioButton);

var _default = RadioButton;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Radio.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Radio.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/radio.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _RadioButton = _interopRequireDefault(require("./RadioButton"));

var _Svg = _interopRequireDefault(require("absol/src/HTML5/Svg"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
var $$ = _ACore.default.$$;
var _svg = _Svg.default.ShareInstance._;
/***
 * @extends AElement
 * @constructor
 */

function Radio() {
  var thisR = this;
  this.defineEvent('change');
  this.$input = $('input', this).on('change', this.notifyChange.bind(this));
  this.$labels = $$('span', this);

  _OOP.default.drillProperty(this, this.$input, ['value', 'checked']);
}

Radio.tag = 'radio';
Radio.radioProto = _('<svg class="absol-radio-icon" width="20" height="20" version="1.1" viewBox="0 0 5.2917 5.2917"' + '   xmlns="http://www.w3.org/2000/svg">' + '    <g transform="translate(0 -291.71)">' + '        <circle class="bound" cx="2.6458" cy="294.35" r="2.4626" style="stroke-opacity:.99497;stroke-width:.26458;" />' + '        <circle class="dot" cx="2.6458" cy="294.35"  r= "0.92604" style="fill-rule:evenodd;" />' + '    </g>' + '</svg>');

Radio.render = function () {
  return _({
    tag: 'label',
    class: 'absol-radio',
    child: [{
      tag: 'input',
      attr: {
        type: 'radio'
      }
    }, {
      tag: 'span',
      class: 'absol-radio-left-label'
    }, Radio.radioProto.cloneNode(true), {
      tag: 'span',
      class: 'absol-radio-right-label'
    }]
  });
};

Radio.prototype.notifyChange = function () {
  this.emit('change', {
    type: 'change',
    checked: this.checked,
    target: this
  }, this);
};

Radio.prototype.getAllFriend = function () {
  return Radio.getAllByName(this.name);
};

Radio.attribute = _RadioButton.default.attribute;
Radio.property = {
  name: {
    set: function (name) {
      this.$input.setAttribute('name', name);
    },
    get: function () {
      return this.$input.getAttribute('name');
    }
  },
  text: {
    set: function (value) {
      value = (value || '').trim();
      this.$labels[0].clearChild();
      this.$labels[1].clearChild();

      if (value) {
        this.$labels[0].addChild(_({
          text: value
        }));
        this.$labels[1].addChild(_({
          text: value
        }));
      }
    },
    get: function () {
      return this.$labels[0].firstChild.data;
    }
  },
  disabled: {
    set: function (value) {
      this.$input.disabled = !!value;

      if (value) {
        this.addClass('disabled');
      } else {
        this.removeClass('disabled');
      }
    },
    get: function () {
      return this.$input.disabled;
    }
  }
};

Radio.getAllByName = function (name) {
  return (Array.apply(null, document.getElementsByTagName('input')) || []).filter(function (elt) {
    return elt.getAttribute('type') == 'radio' && elt.getAttribute('name') == name;
  });
};

Radio.getValueByName = function (name) {
  var inputs = Radio.getAllByName(name);
  var res = null;
  var input;

  for (var i = 0; i < inputs.length; ++i) {
    input = inputs[i];

    if (input.checked) {
      res = input.value;
    }
  }

  return res;
};

_ACore.default.install(Radio);

var _default = Radio;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/RadioInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/RadioInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/radioinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));


//new tech, not working version
var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends Element
 * @constructor
 */

function RadioInput() {
  this.$input = $('input', this).on('change', this.notifyChange.bind(this));
  this.checked = false;
  this.disabled = false;
  this.on('click', this.eventHandler.click);
  this.onchange = null;
}

RadioInput.tag = "RadioInput".toLowerCase();

RadioInput.render = function (data) {
  return _({
    tag: 'label',
    extendEvent: 'change',
    class: 'as-radio-input',
    child: [{
      elt: data && data.$input,
      tag: 'input',
      class: 'as-radio-input-value',
      attr: {
        type: 'radio'
      }
    }, {
      class: ['as-radio-input-check-mark']
    }]
  });
};
/***
 * as normal, change event will be fired when radio change by system
 */


RadioInput.prototype.notifyChange = function () {
  var event = {
    checked: this.checked
  };
  this.emit('change', event, this);
};

RadioInput.prototype._updateCheckedClass = function () {
  if (this.checked) {
    this.addClass('as-checked');
  } else {
    this.removeClass('as-checked');
  }
};

RadioInput.property = {};
RadioInput.property.disabled = {
  set: function (value) {
    if (value) {
      this.addClass('as-disabled');
    } else {
      this.removeClass('as-disabled');
    }

    this.$input.disabled = !!value;
  },
  get: function () {
    this.$input.disabled;
  }
};
/***
 *
 * @type {RadioInput}
 */

RadioInput.property.checked = {
  set: function (value) {
    this.$input.checked = !!value;

    this._updateCheckedClass();
  },
  get: function () {
    return this.$input.checked;
  }
};
RadioInput.attribute = {
  checked: {
    set: function (value) {
      if (value === 'false' || value === null) {
        this.checked = false;
      } else {
        this.checked = true;
      }
    },
    get: function () {
      return this.checked ? 'true' : 'false';
    },
    remove: function () {
      this.checked = false;
    }
  },
  disabled: {
    set: function (value) {
      if (value === 'false' || value === null) {
        this.disabled = false;
      } else {
        this.disabled = true;
      }
    },
    get: function () {
      return this.disabled ? 'true' : 'false';
    },
    remove: function () {
      this.disabled = false;
    }
  }
};
/***
 *
 * @type {RadioInput}
 */

RadioInput.eventHandler = {};

RadioInput.eventHandler.click = function () {
  this._updateCheckedClass();
};

_ACore.default.install(RadioInput);

RadioInput.autoReplace = function () {
  var placeHolders = Array.prototype.slice.call(document.getElementsByTagName(this.tag));
  var ph;
  var attOfPH;
  var attrs;
  var style;
  var classList;
  var attNode;
  var attrName, attrValue;
  var props;

  for (var i = 0; i < placeHolders.length; ++i) {
    ph = placeHolders[i];
    attOfPH = ph.attributes;
    classList = [];
    style = {};
    attrs = {};
    props = {};

    for (var j = 0; j < attOfPH.length; ++j) {
      attNode = attOfPH[j];
      attrName = attNode.nodeName;
      attrValue = attNode.nodeValue;

      if (attrName == 'style') {
        attrValue.trim().split(';').reduce(function (style, prop) {
          var p = prop.split(':');

          if (p.length == 2) {
            style[p[0].trim()] = p[1].trim();
          }

          return style;
        }, style);
      } else if (attrName == 'class') {
        classList = attrValue.trim().split(/\s+/);
      } else if (attrName == 'onchange') {
        props.onchange = new Function('event', 'sender', attrValue);
      } else {
        attrs[attrName] = attrValue;
      }
    }

    var newElt = _({
      tag: this.tag,
      attr: attrs,
      class: classList,
      style: style,
      props: props
    });

    $(ph).selfReplace(newElt);
  }
};

RadioInput.initAfterLoad = function () {
  _Dom.default.documentReady.then(function () {
    RadioInput.autoReplace();
  });
};

var _default = RadioInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/RemoteSvg.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/RemoteSvg.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));

var _XHR = _interopRequireDefault(require("absol/src/Network/XHR"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function RemoteSvg() {}

RemoteSvg.tag = 'RemoteSvg'.toLowerCase();

RemoteSvg.render = function () {
  return _('svg').defineEvent('load');
};

RemoteSvg.property = {
  src: {
    set: function (value) {
      this._src = value;
      var self = this;
      RemoteSvg.loadIcon(value).then(function (data) {
        self.emit('load', {
          target: self,
          src: value,
          data: data
        }, self);
        self.attr(data.attr);
        self.init(data.props);
      });
    },
    get: function () {
      return this._name;
    }
  }
};
RemoteSvg.attribute = {
  src: {
    set: function (value) {},
    get: function () {},
    remove: function () {}
  }
};
RemoteSvg.__cache__ = {};
RemoteSvg.__div_parser__ = document.createElement('div');

RemoteSvg.loadIcon = function (path) {
  if (RemoteSvg.__cache__[path]) {
    return RemoteSvg.__cache__[path];
  } else {
    RemoteSvg.__cache__[path] = _XHR.default.getRequest(path, 'text').then(function (result) {
      RemoteSvg.__div_parser__.innerHTML = result;
      var svgElt = $('svg', RemoteSvg.__div_parser__);
      var res = {
        attr: {},
        props: {}
      };

      if (svgElt) {
        Array.prototype.forEach.call(svgElt.attributes, function (attribute) {
          res.attr[attribute.name] = attribute.value;
        });
        res.props.innerHTML = svgElt.innerHTML;
      }

      return res;
    }, function () {
      return {};
    });
    return RemoteSvg.__cache__[path];
  }
};

_ACore.default.install(RemoteSvg);

var _default = RemoteSvg;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/ResizeBox.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/ResizeBox.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/resizebox.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function ResizeBox() {
  this.on('mousedown', this.eventHandler.mouseDownBody);
  this._mousedownEventData = undefined;
  this._mousemoveEventData = undefined;
  this._lastClickTime = 0;
}

ResizeBox.tag = 'ResizeBox'.toLowerCase();

ResizeBox.render = function () {
  return _({
    class: 'as-resize-box',
    extendEvent: ['beginmove', 'endmove', 'moving', 'click', 'dblclick'],
    //override click event
    child: {
      class: 'as-resize-box-body',
      child: ['.as-resize-box-dot.left-top', '.as-resize-box-dot.top', '.as-resize-box-dot.right-top', '.as-resize-box-dot.right', '.as-resize-box-dot.right-bottom', '.as-resize-box-dot.bottom', '.as-resize-box-dot.left-bottom', '.as-resize-box-dot.left']
    }
  });
};

ResizeBox.eventHandler = {};

ResizeBox.eventHandler.mouseDownBody = function (event) {
  if (_EventEmitter.default.isMouseRight(event)) return;
  event.preventDefault();
  this._optionNames = event.target.attr('class').match(/body|left|top|right|bottom/g);

  var option = this._optionNames.reduce(function (ac, key) {
    ac[key] = true;
    return ac;
  }, {});

  this._mousedownEventData = {
    clientX: event.clientX,
    clientY: event.clientY,
    target: this,
    originEvent: event,
    prevented: false,
    preventDefault: function () {
      this.prevented = true;
    },
    option: option,
    begin: false,
    type: 'beginmove'
  };
  $(document.body).on('mousemove', this.eventHandler.mouseMoveBody);
  $(document.body).on('mouseup', this.eventHandler.mouseFinishBody).on('mouseleave', this.eventHandler.mouseFinishBody);
};

ResizeBox.eventHandler.mouseMoveBody = function (event) {
  if (this._mousedownEventData.option.body && !this.canMove) return;

  if (this._mousedownEventData && !this._mousedownEventData.begin && !this._mousedownEventData.prevented) {
    this.emit('beginmove', this._mousedownEventData, this);

    if (this._mousedownEventData.prevented) {
      $(document.body).off('mousemove', this.eventHandler.mouseMoveBody);
    } else {
      this._mousedownEventData.begin = true;
      $(document.body).addClass('as-resize-box-overiding').addClass(this._optionNames.join('-'));
    }
  }

  if (this._mousedownEventData.begin) {
    event.preventDefault();
    this._mousemoveEventData = {
      clientX: event.clientX,
      clientY: event.clientY,
      clientX0: this._mousedownEventData.clientX,
      clientY0: this._mousedownEventData.clientY,
      clientDX: event.clientX - this._mousedownEventData.clientX,
      clientDY: event.clientY - this._mousedownEventData.clientY,
      target: this,
      originEvent: event,
      option: this._mousedownEventData.option,
      type: 'moving'
    };
    this.emit('moving', this._mousemoveEventData, this);
  }
};

ResizeBox.eventHandler.mouseFinishBody = function (event) {
  $(document.body).off('mousemove', this.eventHandler.mouseMoveBody).off('mouseup', this.eventHandler.mouseFinishBody).off('mouseleave', this.eventHandler.mouseFinishBody).removeClass('as-resize-box-overiding').removeClass(this._optionNames.join('-'));
  this._optionNames = undefined;

  if (this._mousedownEventData.begin) {
    this._mousefinishEventData = {
      clientX: event.clientX,
      clientY: event.clientY,
      clientX0: this._mousedownEventData.clientX,
      clientY0: this._mousedownEventData.clientY,
      clientDX: event.clientX - this._mousedownEventData.clientX,
      clientDY: event.clientY - this._mousedownEventData.clientY,
      target: this,
      originEvent: event,
      option: this._mousedownEventData.option,
      type: 'endmove'
    };
    this.emit('endmove', this._mousefinishEventData, this);
  } else {
    if (_EventEmitter.default.hitElement(this, event)) {
      this.emit('click', event, this);
      var now = new Date().getTime();

      if (now - this._lastClickTime < 500) {
        this.emit('dblclick', event, this);
        this._lastClickTime = 0;
      }

      this._lastClickTime = now;
    }
  }
};

ResizeBox.property = {};
ResizeBox.property.canMove = {
  set: function (value) {
    if (value) {
      this.addClass('as-can-move');
    } else {
      this.removeClass('as-can-move');
    }
  },
  get: function () {
    return this.containsClass('as-can-move');
  }
};
ResizeBox.property.canResize = {
  set: function (value) {
    if (value) {
      this.addClass('as-can-resize');
    } else {
      this.removeClass('as-can-resize');
    }
  },
  get: function () {
    return this.containsClass('as-can-resize');
  }
};
ResizeBox.property.canClick = {
  set: function (value) {
    if (value) {
      this.addClass('as-can-click');
    } else {
      this.removeClass('as-can-click');
    }
  },
  get: function () {
    return this.containsClass('as-can-click');
  }
};

_ACore.default.install(ResizeBox);

var _default = ResizeBox;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/RibbonSplitButton.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/RibbonSplitButton.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/ribbonsplitbutton.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _QuickMenu = _interopRequireDefault(require("./QuickMenu"));

var _utils = require("./utils");

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function RibbonSplitButton() {
  this.$icon = null;
  this._icon = null;
  this.$text = $('.as-ribbon-split-button-text', this);
  this.$textNode = this.$text.firstChild;
  this.$primaryBtn = $('.as-ribbon-split-button-primary', this).on('click', this.eventHandler.clickPrimaryBtn);
  this.$extendBtn = $('.as-ribbon-split-button-extend', this);
  this._menuHolder = null;
}

RibbonSplitButton.tag = 'RibbonSplitButton'.toLowerCase();

RibbonSplitButton.render = function () {
  return _({
    extendEvent: ['press', 'select'],
    attr: {
      'tabindex': '0'
    },
    class: ['as-ribbon-split-button', 'as-no-dropdown'],
    child: {
      class: 'as-ribbon-split-button-content',
      child: [{
        tag: 'button',
        attr: {
          'tabindex': '-1'
        },
        class: 'as-ribbon-split-button-primary',
        child: {
          tag: 'span',
          class: 'as-ribbon-split-button-text',
          child: {
            text: ''
          }
        }
      }, {
        tag: 'button',
        attr: {
          'tabindex': '-1'
        },
        class: 'as-ribbon-split-button-extend',
        child: 'span.mdi.mdi-chevron-down'
      }]
    }
  });
};

RibbonSplitButton.property = {};
RibbonSplitButton.property.items = {
  set: function (items) {
    var thisB = this;
    this._items = items || [];

    if (this._items && this._items.length > 0) {
      if (!this._menuHolder) {
        this.removeClass('as-no-dropdown');
        this._menuHolder = _QuickMenu.default.toggleWhenClick(this.$extendBtn || this, {
          getMenuProps: function () {
            return {
              items: thisB._items
            };
          },
          getFlowedElement: function () {
            return thisB;
          },
          anchor: [1, 2, 6, 5],
          onSelect: function (item) {
            thisB.emit('select', {
              item: (0, _utils.cleanMenuItemProperty)(item),
              type: 'select',
              target: thisB
            });
          }
        });
      }
    } else {
      if (this._menuHolder) {
        this.addClass('as-no-dropdown');

        this._menuHolder.remove();

        this._menuHolder = null;
      }
    }
  },
  get: function () {
    return this._items;
  }
};
RibbonSplitButton.property.text = {
  set: function (value) {
    value = value || '';
    this.$textNode.data = value;
  },
  get: function () {
    return this.$textNode.data;
  }
};
RibbonSplitButton.property.icon = {
  set: function (icon) {
    icon = icon || null;
    this._icon = icon;
    if (this.$icon) this.$primaryBtn.removeChild(this.$icon);

    if (icon) {
      this.$icon = _(icon);
      this.$primaryBtn.addChildBefore(this.$icon, this.$text);
      if (this.$icon.addClass) this.$icon.addClass('as-ribbon-split-button-icon');
    } else {
      this.$icon = null;
    }
  },
  get: function () {
    return this._icon;
  }
};
RibbonSplitButton.eventHandler = {};

RibbonSplitButton.eventHandler.clickPrimaryBtn = function () {
  this.emit('press', {
    type: 'press',
    target: this,
    item: (0, _utils.cleanMenuItemProperty)(this)
  });
};

_ACore.default.install(RibbonSplitButton);

var _default = RibbonSplitButton;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/RibbonButton.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/RibbonButton.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/ribbonbutton.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _RibbonSplitButton = _interopRequireDefault(require("./RibbonSplitButton"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function RibbonButton() {
  this.$icon = null;
  this._icon = null;
  this.$text = $('.as-ribbon-button-text', this);
  this.$textNode = this.$text.firstChild;
  this._menuHolder = null;
}

RibbonButton.tag = 'RibbonButton'.toLowerCase();

RibbonButton.render = function () {
  return _({
    tag: 'button',
    extendEvent: ['select'],
    attr: {
      'tabindex': '0'
    },
    class: ['as-ribbon-button', 'as-no-dropdown'],
    child: [{
      tag: 'span',
      class: 'as-ribbon-button-text',
      child: {
        text: ''
      }
    }, 'span.mdi.mdi-chevron-down']
  });
};

RibbonButton.property = Object.assign({}, _RibbonSplitButton.default.property);
RibbonButton.property.icon = {
  set: function (icon) {
    icon = icon || null;
    this._icon = icon;
    if (this.$icon) this.removeChild(this.$icon);

    if (icon) {
      this.$icon = _(icon);
      this.addChildBefore(this.$icon, this.$text);
      if (this.$icon.addClass) this.$icon.addClass('as-ribbon-button-icon');
    } else {
      this.$icon = null;
    }
  },
  get: function () {
    return this._icon;
  }
};
RibbonButton.eventHandler = {};

_ACore.default.install(RibbonButton);

var _default = RibbonButton;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/RotatedText.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/RotatedText.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireWildcard(require("../ACore"));

require("../css/rotatedtext.css");

var _ResizeSystem = _interopRequireDefault(require("absol/src/HTML5/ResizeSystem"));




/***
 * @extends AElement
 * @constructor
 */
function RotatedText() {
  this.$attachHook = (0, _ACore.$)('attachhook', this);
  this.$attachHook.requestUpdateSize = this.eventHandler.positionChange;
  this.$attachHook.on('attached', this.eventHandler.attached);
  this.$anchor = (0, _ACore.$)('.as-rotated-text-anchor', this);
  this.$content = (0, _ACore.$)('.as-rotated-text-content', this);
  this.$contentText = this.$content.firstChild;
  this.$trackElts = [];
  this._angle = 0;
  this.angle = 0;
  this.text = '';
  this._trackInterval = -1;
}

RotatedText.tag = 'RotatedText';

RotatedText.render = function () {
  return (0, _ACore._)({
    tag: 'span',
    class: 'as-rotated-text',
    child: ['attachhook', {
      class: 'as-rotated-text-anchor',
      child: {
        tag: 'span',
        class: 'as-rotated-text-content',
        child: {
          text: ''
        }
      }
    }]
  });
};

RotatedText.prototype._trackPosition = function () {
  this._cancelTrackPosition();

  var parent = this.parentElement;

  while (parent) {
    parent.addEventListener('scroll', this.eventHandler.positionChange);
    this.$trackElts.push(parent);
    parent = parent.parentElement;
  }

  document.addEventListener('scroll', this.eventHandler.positionChange);
  this.$trackElts.push(document);
  this._trackInterval = setInterval(this.eventHandler.intervalCheck, 3000);
};

RotatedText.prototype._cancelTrackPosition = function () {
  if (this._trackInterval >= 0) {
    clearInterval(this._trackInterval);
    this._trackInterval = -1;
  }

  while (this.$trackElts.length > 0) {
    this.$trackElts.pop().removeEventListener('scroll', this.eventHandler.positionChange);
  }
};

RotatedText.property = {};
RotatedText.property.text = {
  get: function () {
    return this.$contentText.data;
  },
  set: function (value) {
    value = value || '';
    value = value + '';
    this.$contentText.data = value;
  }
};
RotatedText.property.angle = {
  set: function (value) {
    value = value || 0;
    var matched;

    if (typeof value === 'number') {
      this._angle = value;
      this.$content.addStyle('transform', 'rotate(' + value + 'deg)');
    } else if (value.match) {
      matched = value.match(/([0-9.+\-e]+)deg/);

      if (matched) {
        value = parseFloat(matched[1]);

        if (isFinite(value)) {
          this._angle = value;
          this.$content.addStyle('transform', 'rotate(' + this._angle + 'deg)');
        }

        return;
      }

      matched = value.match(/([0-9.+\-e]+)rad/);

      if (matched) {
        value = parseFloat(matched[1]);

        if (isFinite(value)) {
          this._angle = value * 180 / Math.PI;
          this.$content.addStyle('transform', 'rotate(' + this._angle + 'deg)');
        }
      }
    }
  },
  get: function () {
    return this._angle;
  }
};
RotatedText.eventHandler = {};

RotatedText.eventHandler.attached = function () {
  _ResizeSystem.default.add(this);

  this.eventHandler.positionChange();
  this.$content.addStyle('transform-origin', Math.round(0.3 * this.$content.getFontSize()) + 'px 50%');

  this._trackPosition();
};

RotatedText.eventHandler.detached = function () {
  this._cancelTrackPosition();
};

RotatedText.eventHandler.intervalCheck = function () {
  if (!this.isDescendantOf(document.body)) {
    this.eventHandler.detached();
  }
};

RotatedText.eventHandler.positionChange = function () {
  var bound = this.getBoundingClientRect();
  this.$anchor.addStyle({
    top: Math.round(bound.top) + 'px',
    left: Math.round(bound.left) + 'px'
  });
};

_ACore.default.install(RotatedText);

var _default = RotatedText;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Searcher.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Searcher.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/searcher.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

_ACore.default.creator['find-ico'] = function () {
  var res = _('<svg class="find" width="100mm" height="100mm" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">' + ' <g transform="matrix(-1 0 0 1 99.478 -193.73)">' + '  <path d="m62.128 199.18c-18.859 0-34.148 15.289-34.148 34.148 0 5.4138 1.26 10.533 3.5026 15.081 0.6886 1.3965 1.4698 2.7392 2.3357 4.02-1.9962 2.1685-31.467 31.596-31.404 33.295 0.21757 5.8346 4.9404 8.7289 9.464 7.855 1.3264-0.25627 30.938-30.639 31.774-31.529 1.3906 0.89633 2.8508 1.6948 4.3702 2.3848 4.2995 1.9526 9.0756 3.04 14.105 3.04 18.859 0 34.147-15.288 34.147-34.147 3e-6 -18.859-15.288-34.148-34.147-34.148zm0.49444 8.2454a26.067 26.067 0 0 1 26.068 26.067 26.067 26.067 0 0 1-26.068 26.068 26.067 26.067 0 0 1-26.067-26.068 26.067 26.067 0 0 1 26.067-26.067z"/>' + ' </g>' + '</svg>');

  return res;
};

_ACore.default.creator['times-circle-ico'] = function () {
  var res = _('<svg class="times" width="100mm" height="100mm" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">\
            <g transform="translate(0,-197)">\
                <path d="m49.979 236.2-14.231-14.231-10.696 10.696 14.257 14.257-14.351 14.351 10.737 10.737 14.292-14.292 14.292 14.292 10.761-10.761-14.257-14.257 14.316-14.316-10.725-10.725zm50.021 10.804a50 50 0 0 1-50 50 50 50 0 0 1-50-50 50 50 0 0 1 50-50 50 50 0 0 1 50 50z" />\
            </g>\
        </svg>');

  return res;
};
/**
 * @extends {AElement}
 * @constructor
 */


function SearchTextInput() {
  var thisSTI = this;
  this.defineEvent(['change', 'modify', 'stoptyping']);
  this.eventHandler = _OOP.default.bindFunctions(this, SearchTextInput.eventHandler);
  this.$button = $('button', this);
  this.$input = $('input', this);
  ['keyup', 'keydown', 'focus', 'blur'].forEach(function (evName) {
    thisSTI.defineEvent(evName);
    thisSTI.$input.on(evName, function (event) {
      thisSTI.emit(evName, event, thisSTI);
    });
  });
  this.$input.on('change', this.eventHandler.inputChange);
  this.$input.on('keyup', this.eventHandler.inputKeyUp);
  this.$button.on('click', function (event) {
    thisSTI.$input.value = '';
    thisSTI.eventHandler.inputKeyUp(event);
    setTimeout(function () {
      thisSTI.focus();
    }, 50);
  });
}

SearchTextInput.tag = 'SearchTextInput'.toLowerCase();

SearchTextInput.render = function () {
  return _({
    class: 'absol-search-text-input',
    child: [{
      class: 'absol-search-text-input-container',
      child: {
        tag: 'input',
        attr: {
          type: 'search',
          placeholder: 'search...'
        }
      }
    }, {
      class: 'absol-search-text-button-container',
      child: {
        tag: 'button',
        child: ['find-ico', 'times-circle-ico']
      }
    }]
  });
};

SearchTextInput.property = {
  value: {
    set: function (value) {
      value = value || '';
      this.$input.value = value;
      this._lastTextModified = value;

      if (this.value.length > 0) {
        this.addClass('searching');
      } else {
        this.removeClass('searching');
      }
    },
    get: function () {
      return this.$input.value;
    }
  },
  placeholder: {
    set: function (value) {
      this.$input.attr('placeholder', value);
    },
    get: function () {
      return this.$placeholder.getAttribute('placeholder');
    }
  }
};

SearchTextInput.prototype.focus = function () {
  this.$input.focus();
};

SearchTextInput.prototype.blur = function () {
  this.$input.blur();
};

SearchTextInput.eventHandler = {};

SearchTextInput.eventHandler.inputChange = function (event) {
  event.value = this.value;

  if (typeof this.onchange == 'function') {
    this.onchange(event, this);
  }

  this.emit('change', event);
};

SearchTextInput.eventHandler.inputKeyUp = function (event) {
  if (this._lastTextModified != this.value) {
    if (this.value.length > 0) {
      this.addClass('searching');
    } else {
      this.removeClass('searching');
    }

    event.value = this.value;

    if (typeof this.onchange == 'function') {
      this.onchange(event, this);
    }

    this.emit('modify', event);

    if (this._updateTimeOut !== undefined) {
      clearTimeout(this._updateTimeOut);
      this._updateTimeOut = undefined;
    }

    this._updateTimeOut = setTimeout(function () {
      this.emit('stoptyping', event);
    }.bind(this), 500);
    this._lastTextModified = this.value;
  }
};

_ACore.default.creator.searchcrosstextinput = function () {
  var res = _('searchtextinput', true);

  return res;
};

_ACore.default.creator.searchtextinput = SearchTextInput;
var _default = SearchTextInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SelectTable.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SelectTable.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/selecttable.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _stringMatching = require("absol/src/String/stringMatching");

var _stringFormat = require("absol/src/String/stringFormat");

var _Svg = _interopRequireDefault(require("absol/src/HTML5/Svg"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

require("./BScroller");

var _Searcher = _interopRequireDefault(require("./Searcher"));


var privateDom = new _Dom.default().install(_ACore.default);
var $ = privateDom.$;
var _ = privateDom._;

function SelectTable() {
  var thisST = this;
  this.$attachhook = _('attachhook').addTo(this);
  this.sync = new Promise(function (rs) {
    thisST.$attachhook.on('error', rs);
  });
  this.$buttonsContainer = $('.absol-select-table-buttons-container', this);
  this.$searchContainer = $('.absol-select-table-searchtextinput-container', this);
  this.$nonselectedItemsContainer = $('.absol-select-table-nonselected-items-container', this);
  this.$selectedItemsContainer = $('.absol-select-table-selected-items-container', this);
  this.$nonselectedSearchItemsContainer = $('.absol-select-table-nonselected-search-items-container', this);
  this.$selectedSearchItemsContainer = $('.absol-select-table-selected-search-items-container', this);
  this.$removeAllBtn = $('button.remove-all', this).on('click', this.eventHandler.removeAllBtnClick);
  this.$addAllBtn = $('button.add-all', this).on('click', this.eventHandler.addAllBtnClick);
  this.$vscrollerSelected = $('bscroller#selected', this);
  this.$vscrollerNonselected = $('bscroller#nonselected', this);
  this.$body = $('.absol-select-table-body', this);
  this.$header = $('.absol-select-table-header', this);
  /***
   *
   * @type {SearchTextInput}
   */

  this.$searchTextInput = $('searchtextinput', this).on('stoptyping', this.eventHandler.searchTextInputModify);

  this.$addAllBtn.updateSize = function () {
    thisST.updateScroller && thisST.updateScroller();
  };

  _Dom.default.addToResizeSystem(this.$addAllBtn);

  return this;
}

SelectTable.tag = 'SelectTable'.toLowerCase();

SelectTable.render = function () {
  return _({
    class: 'absol-select-table',
    extendEvent: ['change', 'addall', 'removeall', 'add', 'remove'],
    child: [{
      class: 'absol-select-table-header',
      child: [{
        class: 'absol-select-table-searchtextinput-container',
        child: 'searchtextinput'
      }, {
        class: 'absol-select-table-buttons-container',
        child: [{
          tag: 'button',
          class: 'add-all',
          props: {
            innerHTML: 'Add All'
          }
        }, {
          tag: 'button',
          class: 'remove-all',
          props: {
            innerHTML: 'Remove All'
          }
        }]
      }]
    }, {
      class: 'absol-select-table-body',
      child: [{
        tag: 'bscroller',
        attr: {
          id: 'nonselected'
        },
        class: ['absol-select-table-items-scroller'],
        child: {
          child: ['.absol-select-table-nonselected-items-container', '.absol-select-table-nonselected-search-items-container']
        }
      }, {
        tag: 'bscroller',
        attr: {
          id: 'selected'
        },
        class: ['absol-select-table-items-scroller'],
        child: {
          child: ['.absol-select-table-selected-items-container', '.absol-select-table-selected-search-items-container']
        }
      }]
    }]
  });
};

SelectTable.prototype.updateButtonsContainerSize = function () {
  var rootBound = this.$buttonsContainer.getBoundingClientRect();
  var containBound = this.$buttonsContainer.getBoundingRecursiveRect();
  var fontSize = this.getFontSize();
  this.$buttonsContainer.addStyle('width', (containBound.width + 1) / fontSize + 'em');
  this.$searchContainer.addStyle('right', (containBound.width + 5) / fontSize + 'em');
};

SelectTable.prototype.addAll = function () {
  Array.apply(null, this.$nonselectedItemsContainer.childNodes).forEach(function (e) {
    e.addTo(this.$selectedItemsContainer);
  }.bind(this));
  this.requestSort();
};

SelectTable.prototype.removeAll = function () {
  Array.apply(null, this.$selectedItemsContainer.childNodes).forEach(function (e) {
    e.addTo(this.$nonselectedItemsContainer);
  }.bind(this));
  this.requestSort();
};

SelectTable.prototype.updateScroller = function () {
  var update = function () {
    if (this.style.height) {
      var height = parseFloat(this.getComputedStyleValue('height').replace('px', ''));
      var headerHeight = parseFloat(this.$header.getComputedStyleValue('height').replace('px', ''));
      var bodyMargin = parseFloat(this.$body.getComputedStyleValue('margin-top').replace('px', ''));
      var borderWidth = 1;
      var availableHeight = height - headerHeight - bodyMargin * 2 - borderWidth * 2;
      this.$vscrollerNonselected.addStyle('max-height', availableHeight + 'px');
      this.$vscrollerSelected.addStyle('max-height', availableHeight + 'px');
    }
  }.bind(this);

  setTimeout(update, 1);
};

SelectTable.prototype.getAllItemElement = function () {
  var selectedItemElements = Array.apply(null, this.$selectedItemsContainer.childNodes);
  var nonselectedItemElements = Array.apply(null, this.$nonselectedItemsContainer.childNodes);
  return selectedItemElements.concat(nonselectedItemElements);
};

SelectTable.prototype.init = function (props) {
  this.super(props);
  this.sync = this.sync.then(this.updateButtonsContainerSize.bind(this));
};

SelectTable.eventHandler = {};

SelectTable.eventHandler.addAllBtnClick = function (event) {
  this.addAll();

  if (this.searching) {
    this.eventHandler.searchTextInputModify(event);
  }

  this.emit('addall', _EventEmitter.default.copyEvent(event, {}), this);
  this.updateScroller();
};

SelectTable.eventHandler.removeAllBtnClick = function (event) {
  this.removeAll();

  if (this.searching) {
    this.eventHandler.searchTextInputModify(event);
  }

  this.emit('removeall', _EventEmitter.default.copyEvent(event, {}), this);
  this.updateScroller();
};

SelectTable.prototype._filter = function (items, filterText) {
  var result = [];

  if (filterText.length == 1) {
    result = items.map(function (item) {
      var res = {
        item: item,
        text: typeof item === 'string' ? item : item.text
      };
      return res;
    }).map(function (it) {
      it.score = 0;
      var text = it.text.replace(/((\&nbsp)|(\s))+/g, ' ').trim();
      it.score += text.toLowerCase().indexOf(filterText.toLowerCase()) >= 0 ? 100 : 0;
      text = (0, _stringFormat.nonAccentVietnamese)(text);
      it.score += text.toLowerCase().indexOf(filterText.toLowerCase()) >= 0 ? 100 : 0;
      return it;
    });
    result.sort(function (a, b) {
      if (b.score - a.score == 0) {
        if ((0, _stringFormat.nonAccentVietnamese)(b.text) > (0, _stringFormat.nonAccentVietnamese)(a.text)) return -1;
        return 1;
      }

      return b.score - a.score;
    });
    result = result.filter(function (x) {
      return x.score > 0;
    });
  } else {
    var its = items.map(function (item) {
      var res = {
        item: item,
        text: typeof item === 'string' ? item : item.text
      };
      var text = res.text.replace(/((\&nbsp)|(\s))+/g, ' ').trim();
      res.score = ((0, _stringMatching.phraseMatch)(text, filterText) + (0, _stringMatching.phraseMatch)((0, _stringFormat.nonAccentVietnamese)(text), (0, _stringFormat.nonAccentVietnamese)(filterText))) / 2;
      if ((0, _stringFormat.nonAccentVietnamese)(text).replace(/s/g, '').toLowerCase().indexOf((0, _stringFormat.nonAccentVietnamese)(filterText).toLowerCase().replace(/s/g, '')) > -1) res.score = 100;
      return res;
    });
    if (its.length == 0) return;
    its.sort(function (a, b) {
      if (b.score - a.score == 0) {
        if ((0, _stringFormat.nonAccentVietnamese)(b.text) > (0, _stringFormat.nonAccentVietnamese)(a.text)) return -1;
        return 1;
      }

      return b.score - a.score;
    });
    var result = its.filter(function (x) {
      return x.score > 0.5;
    });

    if (result.length == 0) {
      var bestScore = its[0].score;
      result = its.filter(function (it) {
        return it.score + 0.001 >= bestScore;
      });
    }

    if (result[0].score == 0) result = [];
  }

  result = result.map(function (e) {
    return e.item;
  });
  return result;
};

SelectTable.prototype._stringcmp = function (s0, s1) {
  if (s0 == s1) return 0;
  if (s0 > s1) return 1;
  return -1;
};

SelectTable.prototype._getString = function (item) {
  if (typeof item == "string") return item;
  return item.text;
};

SelectTable.prototype._equalArr = function (a, b) {
  if (a.length != b.length) return false;

  for (var i = 0; i < a.length; ++i) {
    if (a[i] != b[i] && a[i].text != b[i].text && a[i].value != b[i].value) return false;
  }

  return true;
};

SelectTable.prototype._applySort = function (items, sortFlag) {
  var res = items.slice();

  if (sortFlag == 1 || sortFlag === true) {
    res.sort(function (a, b) {
      return this._stringcmp(this._getString(a), this._getString(b));
    }.bind(this));
  } else if (sortFlag == -1) {
    res.sort(function (a, b) {
      return -this._stringcmp(this._getString(a), this._getString(b));
    }.bind(this));
  } else if (typeof sortFlag == 'function') {
    res.sort(function (a, b) {
      return sortFlag(a, b);
    }.bind(this));
  }

  return res;
};

SelectTable.prototype.requestSort = function () {
  if (!this.sorted || this.sorted == 0) return;
  var selectedItems = this.selectedItems;

  var selectedItemsNew = this._applySort(selectedItems, this.sorted);

  if (!this._equalArr(selectedItems, selectedItemsNew)) {
    this.selectedItems = selectedItemsNew;
  }

  var nonselectedItems = this.nonselectedItems;

  var nonselectedItemsNew = this._applySort(nonselectedItems, this.sorted);

  if (!this._equalArr(nonselectedItems, nonselectedItemsNew)) {
    this.nonselectedItems = nonselectedItemsNew;
  }
};

SelectTable.eventHandler.searchTextInputModify = function (event) {
  var filterText = this.$searchTextInput.value.trim();

  if (filterText.length > 0) {
    var selectedItems = this.selectedItems;
    var nonselectedItems = this.nonselectedItems;
    this.selectedSearchItems = selectedItems;
    this.nonselectedSearchItems = this._filter(nonselectedItems, filterText);
    this.selectedSearchItems = this._filter(selectedItems, filterText);
  } else {}

  this.searching = filterText.length > 0;
};

SelectTable.property = {};
SelectTable.property.disableMoveAll = {
  set: function (value) {
    if (value) this.addClass('disable-move-all');else this.removeClass('disable-move-all');
  },
  get: function () {
    return this.containsClass('disable-move-all');
  }
};
SelectTable.property.removeAllText = {
  set: function (text) {
    this._removeAllText = text; //todo: update remove all text

    if (!text) this.$removeAllBtn.addStyle('display', 'none');else {
      this.$removeAllBtn.removeStyle('display');
      this.$removeAllBtn.innerHTML = this.removeAllText;
      this.updateButtonsContainerSize();
    }
  },
  get: function () {
    return this._removeAllText || 'Remove All';
  }
};
SelectTable.property.addAllText = {
  set: function (text) {
    this._addAllText = text;
    if (!text) this.$addAllBtn.addStyle('display', 'none');else {
      this.$addAllBtn.removeStyle('display');
      this.$addAllBtn.innerHTML = this.removeAllText;
      this.updateButtonsContainerSize();
    }
  },
  get: function () {
    return this._addAllText || 'Add All';
  }
};
SelectTable.property.searching = {
  set: function (value) {
    if (value) {
      this.addClass('searching');
    } else {
      this.removeClass('searching');
    }

    this.updateScroller();
  },
  get: function () {
    return this.containsClass('searching');
  }
};
SelectTable.property.sorted = {
  set: function (value) {
    this._sort = value;
    this.requestSort();
  },
  get: function () {
    return this._sort;
  }
};
SelectTable.property.selectedItems = {
  set: function (items) {
    this.$selectedItemsContainer.clearChild();
    var $nonselectedItemsContainer = this.$nonselectedItemsContainer;
    var $selectedItemsContainer = this.$selectedItemsContainer;
    var self = this;

    if (items instanceof Array) {
      items.map(function (item) {
        return _({
          tag: 'item',
          props: {
            data: item
          },
          on: {
            requestmove: function (event) {
              if (this.parentElement == $selectedItemsContainer) {
                this.addTo($nonselectedItemsContainer);
                self.emit('remove', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), self);
              } else {
                this.addTo($selectedItemsContainer);
                self.emit('add', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), self);
              }

              self.updateScroller();
              self.requestSort();
            }
          }
        }).addTo(this.$selectedItemsContainer);
      }.bind(this));
    } else {// error
    }

    this.updateScroller();
    this.requestSort();
  },
  get: function () {
    return Array.prototype.map.call(this.$selectedItemsContainer.childNodes, function (e) {
      return e.data;
    });
  }
};
SelectTable.property.nonselectedItems = {
  set: function (items) {
    this.$nonselectedItemsContainer.clearChild();
    var $nonselectedItemsContainer = this.$nonselectedItemsContainer;
    var $selectedItemsContainer = this.$selectedItemsContainer;
    var self = this;

    if (items instanceof Array) {
      items.map(function (item) {
        return _({
          tag: 'item',
          props: {
            data: item
          },
          on: {
            requestmove: function (event) {
              if (this.parentElement == $selectedItemsContainer) {
                this.addTo($nonselectedItemsContainer);
                self.emit('remove', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), self);
              } else {
                this.addTo($selectedItemsContainer);
                self.emit('add', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), self);
              }

              self.updateScroller();
              self.requestSort();
            }
          }
        }).addTo(this.$nonselectedItemsContainer);
      }.bind(this));
    } else {// error
    }

    this.updateScroller();
    this.requestSort();
  },
  get: function () {
    return Array.prototype.map.call(this.$nonselectedItemsContainer.childNodes, function (e) {
      return e.data;
    });
  }
};
SelectTable.property.selectedSearchItems = {
  set: function (items) {
    this.$selectedSearchItemsContainer.clearChild();
    var $nonselectedSearchItemsContainer = this.$nonselectedSearchItemsContainer;
    var $selectedSearchItemsContainer = this.$selectedSearchItemsContainer;
    var table = this;

    if (items instanceof Array) {
      items.map(function (item) {
        return _({
          tag: 'item',
          props: {
            data: item
          },
          on: {
            requestmove: function (event) {
              if (this.parentElement == $selectedSearchItemsContainer) {
                this.addTo($nonselectedSearchItemsContainer);
                table.getAllItemElement().filter(function (itemElement) {
                  if (itemElement.data == this.data) {
                    itemElement.addTo(table.$nonselectedItemsContainer);
                    return true;
                  }

                  return false;
                }.bind(this));
                table.emit('remove', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), table);
              } else {
                this.addTo($selectedSearchItemsContainer);
                table.getAllItemElement().filter(function (itemElement) {
                  if (itemElement.data == this.data) {
                    itemElement.addTo(table.$selectedItemsContainer);
                    return true;
                  }

                  return false;
                }.bind(this));
                table.emit('add', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), table);
              }

              table.updateScroller();
              table.requestSort();
            }
          }
        }).addTo(this.$selectedSearchItemsContainer);
      }.bind(this));
    } else {// error
    }

    this.updateScroller();
  },
  get: function () {
    return Array.prototype.map.call(this.$selectedSearchItemsContainer.childNodes, function (e) {
      return e.data;
    });
  }
};
SelectTable.property.nonselectedSearchItems = {
  set: function (items) {
    this.$nonselectedSearchItemsContainer.clearChild();
    var $nonselectedSearchItemsContainer = this.$nonselectedSearchItemsContainer;
    var $selectedSearchItemsContainer = this.$selectedSearchItemsContainer;
    var table = this;

    if (items instanceof Array) {
      items.map(function (item) {
        return _({
          tag: 'item',
          props: {
            data: item
          },
          on: {
            requestmove: function (event) {
              if (this.parentElement == $selectedSearchItemsContainer) {
                this.addTo($nonselectedSearchItemsContainer);
                table.getAllItemElement().filter(function (itemElement) {
                  if (itemElement.data == this.data) {
                    itemElement.addTo(table.$nonselectedItemsContainer);
                    return true;
                  }

                  return false;
                }.bind(this));
                table.emit('remove', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), table);
              } else {
                this.addTo($selectedSearchItemsContainer);
                table.getAllItemElement().filter(function (itemElement) {
                  if (itemElement.data == this.data) {
                    itemElement.addTo(table.$selectedItemsContainer);
                    return true;
                  }

                  return false;
                }.bind(this));
                table.emit('add', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), table);
              }

              table.updateScroller();
              table.requestSort();
            }
          }
        }).addTo(this.$nonselectedSearchItemsContainer);
      }.bind(this));
    } else {// error
    }

    this.updateScroller();
  },
  get: function () {
    return Array.prototype.map.call(this.$nonselectedSearchItemsContainer.childNodes, function (e) {
      return e.data;
    });
  }
};
/*
namespace of selecttable
*/

function Item() {
  var res = _({
    extendEvent: ['requestmove'],
    class: 'absol-select-table-item',
    child: ['span.absol-select-table-item-text', {
      class: 'absol-select-table-item-right-container',
      child: {
        class: 'absol-select-table-item-right-container-table',
        child: {
          class: 'absol-select-table-item-right-container-cell',
          child: ['addicon', 'subicon']
        }
      }
    }]
  });

  res.$text = $('span', res);
  res.eventHandler = _OOP.default.bindFunctions(res, Item.eventHandler);
  res.$rightBtn = $('.absol-select-table-item-right-container', res);
  res.on('dblclick', res.eventHandler.dblclick);
  res.$rightBtn.on('click', res.eventHandler.rightBtClick);
  return res;
}

;
Item.eventHandler = {};

Item.eventHandler.dblclick = function (event) {
  event.preventDefault();
  if (!_EventEmitter.default.hitElement(this.$rightBtn, event)) this.emit('requestmove', event, this);
};

Item.eventHandler.rightBtClick = function (event) {
  this.emit('requestmove', event, this);
};

Item.property = {};
Item.property.data = {
  set: function (value) {
    this._data = value;

    if (value) {
      var text;

      if (typeof value == "string") {
        text = value;
      } else {
        text = value.text;
      }

      this.$text.innerHTML = text;
    }
  },
  get: function () {
    return this._data;
  }
};
Item.property.text = {
  get: function () {
    return this._data ? typeof this._data == 'string' ? this._data : this._data.text : '';
  }
};
/**
 *
 * <svg width="100mm" height="100mm" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
 <g transform="translate(0,-197)">
 <path d="m39.873 198.21v38.668h-38.668v20.252h38.668v38.668h20.253v-38.668h38.668v-20.252h-38.668v-38.668z" style="fill-rule:evenodd;fill:#5fbbc2;stroke-linejoin:round;stroke-width:2.4109;stroke:#002eea"/>
 </g>
 </svg>
 */

function AddIcon() {
  return _Svg.default.ShareInstance.buildSvg('<svg class="add-icon" width="100mm" height="100mm" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">' + '<g transform="translate(0,-197)">' + '<path d="m39.873 198.21v38.668h-38.668v20.252h38.668v38.668h20.253v-38.668h38.668v-20.252h-38.668v-38.668z" style="fill-rule:evenodd;stroke-linejoin:round;stroke-width:2.4109;" />' + '</g>' + '</svg>');
}

;

function SubIcon() {
  return _Svg.default.ShareInstance.buildSvg('<svg class="sub-icon" width="100mm" height="100mm" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">' + ' <g transform="translate(0,-197)">' + '  <path d="m98.795 236.87v20.253h-97.589v-20.253z" style="fill-rule:evenodd;stroke-linejoin:round;stroke-width:2.411;"/>' + ' </g>' + '</svg>');
}

;
privateDom.install({
  subicon: SubIcon,
  addicon: AddIcon,
  item: Item
});
SelectTable.privateDom = privateDom;

_ACore.default.install(SelectTable);

var _default = SelectTable;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SelectTable2.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SelectTable2.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/selecttable.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _stringMatching = require("absol/src/String/stringMatching");

var _stringFormat = require("absol/src/String/stringFormat");

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _SelectTable = _interopRequireDefault(require("./SelectTable"));


var privateDom = new _Dom.default().install(_ACore.default).install(_SelectTable.default.privateDom);
var $ = privateDom.$;
var _ = privateDom._;

function SelectTable2() {
  var thisST = this;
  this.$attachhook = _('attachhook').addTo(this);
  this.sync = new Promise(function (rs) {
    thisST.$attachhook.on('error', rs);
  });
  this.$buttonsContainer = $('.absol-select-table-buttons-container', this);
  this.$searchContainer = $('.absol-select-table-searchtextinput-container', this);
  this.$nonselectedItemsContainer = $('.absol-select-table-nonselected-items-container', this);
  this.$selectedItemsContainer = $('.absol-select-table-selected-items-container', this);
  this.$nonselectedSearchItemsContainer = $('.absol-select-table-nonselected-search-items-container', this);
  this.$selectedSearchItemsContainer = $('.absol-select-table-selected-search-items-container', this);
  this.$removeAllBtn = $('button.remove-all', this).on('click', this.eventHandler.removeAllBtnClick);
  this.$addAllBtn = $('button.add-all', this).on('click', this.eventHandler.addAllBtnClick);
  this.$vscrollerSelected = $('vscroller#selected', this);
  this.$vscrollerNonselected = $('vscroller#nonselected', this);
  this.$body = $('.absol-select-table-body', this);
  this.$searchTextInput = $('searchtextinput', this).on('stoptyping', this.eventHandler.searchTextInputModify);
}

;
SelectTable2.tag = 'SelectTable2'.toLowerCase();

SelectTable2.render = function () {
  return _({
    class: ['absol-select-table', 'exclude'],
    extendEvent: ['change', 'addall', 'removeall', 'add', 'remove'],
    child: [{
      class: 'absol-select-table-header',
      child: [{
        class: 'absol-select-table-searchtextinput-container',
        child: 'searchtextinput'
      }, {
        class: 'absol-select-table-buttons-container',
        child: [{
          tag: 'button',
          class: 'add-all',
          props: {
            innerHTML: 'Add All'
          }
        }, {
          tag: 'button',
          class: 'remove-all',
          props: {
            innerHTML: 'Remove All'
          }
        }]
      }]
    }, {
      class: 'absol-select-table-body',
      child: [{
        tag: 'vscroller',
        attr: {
          id: 'nonselected'
        },
        class: 'absol-select-table-items-scroller',
        child: {
          child: ['.absol-select-table-nonselected-items-container', '.absol-select-table-nonselected-search-items-container']
        }
      }, {
        tag: 'vscroller',
        attr: {
          id: 'selected'
        },
        class: 'absol-select-table-items-scroller',
        child: {
          child: ['.absol-select-table-selected-items-container', '.absol-select-table-selected-search-items-container']
        }
      }]
    }]
  });
};

SelectTable2.prototype.updateButtonsContainerSize = function () {
  var rootBound = this.$buttonsContainer.getBoundingClientRect();
  var containBound = this.$buttonsContainer.getBoundingRecursiveRect();
  var fontSize = this.getFontSize();
  this.$buttonsContainer.addStyle('width', (containBound.width + 1) / fontSize + 'em');
  this.$searchContainer.addStyle('right', (containBound.width + 5) / fontSize + 'em');
};

SelectTable2.prototype.addAll = function () {
  Array.apply(null, this.$nonselectedItemsContainer.childNodes).forEach(function (e) {
    e.addTo(this.$selectedItemsContainer);
  }.bind(this));
  this.requestSort();
};

SelectTable2.prototype.removeAll = function () {
  Array.apply(null, this.$selectedItemsContainer.childNodes).forEach(function (e) {
    e.addTo(this.$nonselectedItemsContainer);
  }.bind(this));
  this.requestSort();
};

SelectTable2.prototype.updateScroller = function () {
  var update = function () {
    if (this.style.height) {
      var bodyMargin = parseFloat(this.$body.getComputedStyleValue('margin-top').replace('px', '') || 0.14285714285 * 14 + '');
      var bound = this.getBoundingClientRect();
      var bodyBound = this.$body.getBoundingClientRect();
      var bodyRBound = this.$body.getBoundingRecursiveRect();
      var availableHeight = bound.bottom - bodyMargin - bodyBound.top;
      var isOverflowHeight = availableHeight < bodyRBound.height;

      if (isOverflowHeight) {
        this.$vscrollerNonselected.addStyle('max-height', availableHeight + 'px');
        this.$vscrollerSelected.addStyle('max-height', availableHeight + 'px');
        this.$vscrollerSelected.addClass('limited-height');
        this.$vscrollerNonselected.addClass('limited-height');
      } else {
        this.$vscrollerNonselected.removeStyle('max-height');
        this.$vscrollerSelected.removeStyle('max-height');
        this.$vscrollerSelected.removeClass('limited-height');
        this.$vscrollerSelected.removeClass('limited-height');
        this.$vscrollerNonselected.removeClass('limited-height');
      }
    }

    requestAnimationFrame(this.$vscrollerNonselected.requestUpdateSize.bind(this.$vscrollerNonselected));
    requestAnimationFrame(this.$vscrollerSelected.requestUpdateSize.bind(this.$vscrollerSelected));
  }.bind(this);

  setTimeout(update, 1);
};

SelectTable2.prototype.getAllItemElement = function () {
  var selectedItemElements = Array.apply(null, this.$selectedItemsContainer.childNodes);
  var nonselectedItemElements = Array.apply(null, this.$nonselectedItemsContainer.childNodes);
  return selectedItemElements.concat(nonselectedItemElements);
};

SelectTable2.prototype.init = function (props) {
  this.super(props);
  this.sync = this.sync.then(this.updateButtonsContainerSize.bind(this));
};

SelectTable2.eventHandler = {};

SelectTable2.eventHandler.addAllBtnClick = function (event) {
  this.addAll();

  if (this.searching) {
    this.eventHandler.searchTextInputModify(event);
  }

  this.emit('addall', _EventEmitter.default.copyEvent(event, {}), this);
  this.updateScroller();
};

SelectTable2.eventHandler.removeAllBtnClick = function (event) {
  this.removeAll();

  if (this.searching) {
    this.eventHandler.searchTextInputModify(event);
  }

  this.emit('removeall', _EventEmitter.default.copyEvent(event, {}), this);
  this.updateScroller();
};

SelectTable2.prototype._filter = function (items, filterText) {
  var result = [];

  if (filterText.length == 1) {
    result = items.map(function (item) {
      var res = {
        item: item,
        text: typeof item === 'string' ? item : item.text
      };
      return res;
    }).map(function (it) {
      it.score = 0;
      var text = it.text.replace(/((\&nbsp)|(\s))+/g, ' ').trim();
      it.score += text.toLowerCase().indexOf(filterText.toLowerCase()) >= 0 ? 100 : 0;
      text = (0, _stringFormat.nonAccentVietnamese)(text);
      it.score += text.toLowerCase().indexOf(filterText.toLowerCase()) >= 0 ? 100 : 0;
      return it;
    });
    result.sort(function (a, b) {
      if (b.score - a.score == 0) {
        if ((0, _stringFormat.nonAccentVietnamese)(b.text) > (0, _stringFormat.nonAccentVietnamese)(a.text)) return -1;
        return 1;
      }

      return b.score - a.score;
    });
    result = result.filter(function (x) {
      return x.score > 0;
    });
  } else {
    var its = items.map(function (item) {
      var res = {
        item: item,
        text: typeof item === 'string' ? item : item.text
      };
      var text = res.text.replace(/((\&nbsp)|(\s))+/g, ' ').trim();
      res.score = ((0, _stringMatching.phraseMatch)(text, filterText) + (0, _stringMatching.phraseMatch)((0, _stringFormat.nonAccentVietnamese)(text), (0, _stringFormat.nonAccentVietnamese)(filterText))) / 2;
      if ((0, _stringFormat.nonAccentVietnamese)(text).replace(/s/g, '').toLowerCase().indexOf((0, _stringFormat.nonAccentVietnamese)(filterText).toLowerCase().replace(/s/g, '')) > -1) res.score = 100;
      return res;
    });
    if (its.length == 0) return;
    its.sort(function (a, b) {
      if (b.score - a.score == 0) {
        if ((0, _stringFormat.nonAccentVietnamese)(b.text) > (0, _stringFormat.nonAccentVietnamese)(a.text)) return -1;
        return 1;
      }

      return b.score - a.score;
    });
    var result = its.filter(function (x) {
      return x.score > 0.5;
    });

    if (result.length == 0) {
      var bestScore = its[0].score;
      result = its.filter(function (it) {
        return it.score + 0.001 >= bestScore;
      });
    }

    if (result[0].score == 0) result = [];
  }

  result = result.map(function (e) {
    return e.item;
  });
  return result;
};

SelectTable2.prototype._stringcmp = function (s0, s1) {
  if (s0 == s1) return 0;
  if (s0 > s1) return 1;
  return -1;
};

SelectTable2.prototype._getString = function (item) {
  if (typeof item == "string") return item;
  return item.text;
};

SelectTable2.prototype._equalArr = function (a, b) {
  if (a.length != b.length) return false;

  for (var i = 0; i < a.length; ++i) {
    if (a[i] != b[i]) return false;
  }

  return true;
};

SelectTable2.prototype._applySort = function (items, sortFlag) {
  var res = items.slice();

  if (sortFlag == 1 || sortFlag === true) {
    res.sort(function (a, b) {
      return this._stringcmp(this._getString(a), this._getString(b));
    }.bind(this));
  } else if (sortFlag == -1) {
    res.sort(function (a, b) {
      return -this._stringcmp(this._getString(a), this._getString(b));
    }.bind(this));
  } else if (typeof sortFlag == 'function') {
    res.sort(function (a, b) {
      return sortFlag(a, b);
    }.bind(this));
  }

  return res;
};

SelectTable2.prototype.requestSort = function () {
  if (!this.sorted || this.sorted == 0) return;
  var selectedItems = this.selectedItems;

  var selectedItemsNew = this._applySort(selectedItems, this.sorted);

  if (!this._equalArr(selectedItems, selectedItemsNew)) {
    this.selectedItems = selectedItemsNew;
  }

  var nonselectedItems = this.nonselectedItems;

  var nonselectedItemsNew = this._applySort(nonselectedItems, this.sorted);

  if (!this._equalArr(nonselectedItems, nonselectedItemsNew)) {
    this.nonselectedItems = nonselectedItemsNew;
  }
};

SelectTable2.eventHandler.searchTextInputModify = function (event) {
  var filterText = this.$searchTextInput.value.trim();

  if (filterText.length > 0) {
    var selectedItems = this.selectedItems;
    var nonselectedItems = this.nonselectedItems;
    this.selectedSearchItems = selectedItems;
    this.nonselectedSearchItems = this._filter(nonselectedItems, filterText);
    this.selectedSearchItems = this._filter(selectedItems, filterText);
  } else {}

  this.searching = filterText.length > 0;
};

SelectTable2.property = {};
SelectTable2.property.disableMoveAll = {
  set: function (value) {
    if (value) this.addClass('disable-move-all');else this.removeClass('disable-move-all');
  },
  get: function () {
    return this.containsClass('disable-move-all');
  }
};
SelectTable2.property.removeAllText = {
  set: function (text) {
    this._removeAllText = text; //todo: update remove all text

    if (!text) this.$removeAllBtn.addStyle('display', 'none');else {
      this.$removeAllBtn.removeStyle('display');
      this.$removeAllBtn.innerHTML = this.removeAllText;
      this.updateButtonsContainerSize();
    }
  },
  get: function () {
    return this._removeAllText || 'Remove All';
  }
};
SelectTable2.property.addAllText = {
  set: function (text) {
    this._addAllText = text;
    if (!text) this.$addAllBtn.addStyle('display', 'none');else {
      this.$addAllBtn.removeStyle('display');
      this.$addAllBtn.innerHTML = this.removeAllText;
      this.updateButtonsContainerSize();
    }
  },
  get: function () {
    return this._addAllText || 'Add All';
  }
};
SelectTable2.property.searching = {
  set: function (value) {
    if (value) {
      this.addClass('searching');
    } else {
      this.removeClass('searching');
    }

    this.updateScroller();
  },
  get: function () {
    return this.containsClass('searching');
  }
};
SelectTable2.property.sorted = {
  set: function (value) {
    this._sort = value;
    this.requestSort();
  },
  get: function () {
    return this._sort;
  }
};
SelectTable2.property.selectedItems = {
  set: function (items) {
    this.$selectedItemsContainer.clearChild();
    var $nonselectedItemsContainer = this.$nonselectedItemsContainer;
    var $selectedItemsContainer = this.$selectedItemsContainer;
    var self = this;

    if (items instanceof Array) {
      items.map(function (item) {
        return _({
          tag: 'item',
          props: {
            data: item
          },
          on: {
            requestmove: function (event) {
              if (this.parentElement == $selectedItemsContainer) {
                this.addTo($nonselectedItemsContainer);
                self.emit('remove', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), self);
              } else {
                this.addTo($selectedItemsContainer);
                self.emit('add', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), self);
              }

              self.updateScroller();
              self.requestSort();
            }
          }
        }).addTo(this.$selectedItemsContainer);
      }.bind(this));
    } else {// error
    }

    this.updateScroller();
    this.requestSort();
  },
  get: function () {
    return Array.prototype.map.call(this.$selectedItemsContainer.childNodes, function (e) {
      return e.data;
    });
  }
};
SelectTable2.property.nonselectedItems = {
  set: function (items) {
    this.$nonselectedItemsContainer.clearChild();
    var $nonselectedItemsContainer = this.$nonselectedItemsContainer;
    var $selectedItemsContainer = this.$selectedItemsContainer;
    var self = this;

    if (items instanceof Array) {
      items.map(function (item) {
        return _({
          tag: 'item',
          props: {
            data: item
          },
          on: {
            requestmove: function (event) {
              if (this.parentElement == $selectedItemsContainer) {
                this.addTo($nonselectedItemsContainer);
                self.emit('remove', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), self);
              } else {
                this.addTo($selectedItemsContainer);
                self.emit('add', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), self);
              }

              self.updateScroller();
              self.requestSort();
            }
          }
        }).addTo(this.$nonselectedItemsContainer);
      }.bind(this));
    } else {// error
    }

    this.updateScroller();
    this.requestSort();
  },
  get: function () {
    return Array.prototype.map.call(this.$nonselectedItemsContainer.childNodes, function (e) {
      return e.data;
    });
  }
};
SelectTable2.property.selectedSearchItems = {
  set: function (items) {
    this.$selectedSearchItemsContainer.clearChild();
    var $nonselectedSearchItemsContainer = this.$nonselectedSearchItemsContainer;
    var $selectedSearchItemsContainer = this.$selectedSearchItemsContainer;
    var table = this;

    if (items instanceof Array) {
      items.map(function (item) {
        return _({
          tag: 'item',
          props: {
            data: item
          },
          on: {
            requestmove: function (event) {
              if (this.parentElement == $selectedSearchItemsContainer) {
                this.addTo($nonselectedSearchItemsContainer);
                table.getAllItemElement().filter(function (itemElement) {
                  if (itemElement.data == this.data) {
                    itemElement.addTo(table.$nonselectedItemsContainer);
                    return true;
                  }

                  return false;
                }.bind(this));
                table.emit('remove', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), table);
              } else {
                this.addTo($selectedSearchItemsContainer);
                table.getAllItemElement().filter(function (itemElement) {
                  if (itemElement.data == this.data) {
                    itemElement.addTo(table.$selectedItemsContainer);
                    return true;
                  }

                  return false;
                }.bind(this));
                table.emit('add', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), table);
              }

              table.updateScroller();
              table.requestSort();
            }
          }
        }).addTo(this.$selectedSearchItemsContainer);
      }.bind(this));
    } else {// error
    }

    this.updateScroller();
  },
  get: function () {
    return Array.prototype.map.call(this.$selectedSearchItemsContainer.childNodes, function (e) {
      return e.data;
    });
  }
};
SelectTable2.property.nonselectedSearchItems = {
  set: function (items) {
    this.$nonselectedSearchItemsContainer.clearChild();
    var $nonselectedSearchItemsContainer = this.$nonselectedSearchItemsContainer;
    var $selectedSearchItemsContainer = this.$selectedSearchItemsContainer;
    var table = this;

    if (items instanceof Array) {
      items.map(function (item) {
        return _({
          tag: 'item',
          props: {
            data: item
          },
          on: {
            requestmove: function (event) {
              if (this.parentElement == $selectedSearchItemsContainer) {
                this.addTo($nonselectedSearchItemsContainer);
                table.getAllItemElement().filter(function (itemElement) {
                  if (itemElement.data == this.data) {
                    itemElement.addTo(table.$nonselectedItemsContainer);
                    return true;
                  }

                  return false;
                }.bind(this));
                table.emit('remove', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), table);
              } else {
                this.addTo($selectedSearchItemsContainer);
                table.getAllItemElement().filter(function (itemElement) {
                  if (itemElement.data == this.data) {
                    itemElement.addTo(table.$selectedItemsContainer);
                    return true;
                  }

                  return false;
                }.bind(this));
                table.emit('add', _EventEmitter.default.copyEvent(event, {
                  item: item
                }), table);
              }

              table.updateScroller();
              table.requestSort();
            }
          }
        }).addTo(this.$nonselectedSearchItemsContainer);
      }.bind(this));
    } else {// error
    }

    this.updateScroller();
  },
  get: function () {
    return Array.prototype.map.call(this.$nonselectedSearchItemsContainer.childNodes, function (e) {
      return e.data;
    });
  }
};
/*
namespace of selecttable
*/

function Item() {
  var res = _({
    extendEvent: ['requestmove', 'clickadd', 'clickremove', 'clickexclude'],
    class: 'absol-select-table-item',
    child: ['span.absol-select-table-item-text', {
      class: 'absol-select-table-item-right-container',
      child: {
        class: 'absol-select-table-item-right-container-table',
        child: {
          class: 'absol-select-table-item-right-container-row',
          child: [{
            attr: {
              title: 'Add'
            },
            class: ['absol-select-table-item-right-container-cell', 'add'],
            child: 'addicon'
          }, {
            attr: {
              title: 'Remove'
            },
            class: ['absol-select-table-item-right-container-cell', 'remove'],
            child: 'subicon'
          }, {
            attr: {
              title: 'Exclude'
            },
            class: ['absol-select-table-item-right-container-cell', 'exclude'],
            child: 'excludeico'
          }]
        }
      }
    }]
  });

  res.$text = $('span', res);
  res.eventHandler = _OOP.default.bindFunctions(res, Item.eventHandler);
  res.$rightBtn = $('.absol-select-table-item-right-container', res);
  res.on('dblclick', res.eventHandler.dblclick);
  res.$addBtn = $('.absol-select-table-item-right-container-cell.add', res).on('click', res.eventHandler.addBtClick);
  res.$removeBtn = $('.absol-select-table-item-right-container-cell.remove', res).on('click', res.eventHandler.removeBtClick);
  res.$excludeBtn = $('.absol-select-table-item-right-container-cell.exclude', res).on('click', res.eventHandler.excludeBtClick);
  return res;
}

;
Item.eventHandler = {};

Item.eventHandler.dblclick = function (event) {
  event.preventDefault();
  if (!_EventEmitter.default.hitElement(this.$rightBtn, event)) this.emit('requestmove', event, this);
};

Item.eventHandler.rightBtClick = function (event) {
  this.emit('requestmove', event, this);
};

Item.eventHandler.removeBtClick = function (event) {
  this.emit('clickremove', event, this);
};

Item.eventHandler.addBtClick = function (event) {
  this.emit('clickadd', event, this);
};

Item.eventHandler.excludeBtClick = function (event) {
  this.emit('clickexclude', event, this);
};

Item.property = {};
Item.property.data = {
  set: function (value) {
    this._data = value;

    if (value) {
      var text;

      if (typeof value == "string") {
        text = value;
      } else {
        text = value.text;
      }

      this.$text.innerHTML = text;
    }
  },
  get: function () {
    return this._data;
  }
};
Item.property.text = {
  get: function () {
    return this._data ? typeof this._data == 'string' ? this._data : this._data.text : '';
  }
};

function ExcludeIco() {
  return _('<svg class="exclude-icon" width="24" height="24" viewBox="0 0 24 24">\
            <path  d="M8.27,3L3,8.27V15.73L8.27,21H15.73C17.5,19.24 21,15.73 21,15.73V8.27L15.73,3M9.1,5H14.9L19,9.1V14.9L14.9,19H9.1L5,14.9V9.1M11,15H13V17H11V15M11,7H13V13H11V7" />\
        </svg>');
}

privateDom.install({
  item: Item,
  excludeico: ExcludeIco
}); // not completed yet

_ACore.default.install('selecttable2', SelectTable2);

var _default = SelectTable2;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/list/treeListToList.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/list/treeListToList.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = treeListToList;

/***
 *
 * @param {Array<SelectionItem>} items
 * @returns {Array<SelectionItem>}
 */
function treeListToList(items) {
  var arr = [];

  function visit(level, node) {
    Object.defineProperty(node, 'level', {
      configurable: true,
      writable: true,
      value: level
    });
    arr.push(node);
    if (node.items && node.items.length > 0) node.items.forEach(visit.bind(null, level + 1));
  }

  items.forEach(visit.bind(null, 0));
  return arr;
}
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SelectTreeBox.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SelectTreeBox.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _SelectListBox = _interopRequireDefault(require("./SelectListBox"));

var _treeListToList = _interopRequireDefault(require("./list/treeListToList"));

var _ACore = _interopRequireDefault(require("../ACore"));

var _search = require("./list/search");


var _ = _ACore.default._;
var $ = _ACore.default.$;
var $$ = _ACore.default.$$;
/***
 * @extends SelectListBox
 * @constructor
 */

function SelectTreeBox() {
  _SelectListBox.default.call(this);
}

SelectTreeBox.tag = 'SelectTreeBox'.toLowerCase();

SelectTreeBox.render = function () {
  return _SelectListBox.default.render().addClass('as-select-tree-box');
};

Object.assign(SelectTreeBox.prototype, _SelectListBox.default.prototype);
SelectTreeBox.property = Object.assign({}, _SelectListBox.default.property);
SelectTreeBox.eventHandler = Object.assign({}, _SelectListBox.default.eventHandler);

SelectTreeBox.prototype._itemsToNodeList = function (items) {
  return (0, _treeListToList.default)(items);
}; //todo


SelectTreeBox.prototype.searchItemByText = function (text) {
  text = text.trim();
  if (text.length == 0) return this._items;
  if (this._searchCache[text]) return this._searchCache[text];
  this._searchCache[text] = (0, _search.searchTreeListByText)(text, this._items);
  return this._searchCache[text];
};

_ACore.default.install(SelectTreeBox);

var _default = SelectTreeBox;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SelectTreeMenu.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SelectTreeMenu.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/selecttreemenu.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _SelectMenu = _interopRequireDefault(require("./SelectMenu2"));

var _SelectTreeBox = _interopRequireDefault(require("./SelectTreeBox"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends SelectMenu
 * @constructor
 */

function SelectTreeMenu() {
  var thisSM = this;
  this._items = [];
  this._value = null;
  this._lastValue = null;
  this.$holderItem = $('.absol-selectmenu-holder-item', this);
  this.$viewItem = $('.absol-selectmenu-holder-item selectlistitem', this);
  /***
   *
   * @type {SelectTreeBox}
   */

  this.$selectlistBox = _({
    tag: 'selecttreebox',
    props: {
      anchor: [1, 6, 2, 5]
    },
    on: {
      preupdateposition: this.eventHandler.preUpdateListPosition
    }
  });
  this.$selectlistBox.on('pressitem', this.eventHandler.selectListBoxPressItem);
  this.$selectlistBox.followTarget = this;

  _OOP.default.drillProperty(this, this.$selectlistBox, 'enableSearch');

  this._lastValue = "NOTHING_VALUE";
  this._isFocus = false;
  this.isFocus = false;
  this.on('mousedown', this.eventHandler.click, true);
}

SelectTreeMenu.tag = 'SelectTreeMenu'.toLowerCase();

SelectTreeMenu.render = function () {
  return _SelectMenu.default.render().addClass('as-select-tree-menu');
};

SelectTreeMenu.eventHandler = Object.assign({}, _SelectMenu.default.eventHandler);
SelectTreeMenu.property = Object.assign({}, _SelectMenu.default.property);
Object.assign(SelectTreeMenu.prototype, _SelectMenu.default.prototype);

_ACore.default.install(SelectTreeMenu);

var _default = SelectTreeMenu;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SinglePage.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SinglePage.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/singlepage.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _ResizeSystem = _interopRequireDefault(require("absol/src/HTML5/ResizeSystem"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
var warned = false;
/***
 * @extends AElement
 * @constructor
 */

function SinglePage() {
  var thisSP = this;
  this._updateIntv = -1;

  this._tick = function () {
    if (this.isDescendantOf(document.body)) {
      if (this.$header) {
        var headerHeight = this.$header.getBoundingClientRect().height;

        if (this._prevHeaderHeight !== headerHeight) {
          _ResizeSystem.default.update();
        }
      }
    } else {
      clearInterval(this._updateIntv);
      this._updateIntv = -1;
    }
  }.bind(this);

  this.$attachhook = $('attachhook', this).on('attached', function () {
    this.updateSize();
    setTimeout(this.updateSize, 20);

    _Dom.default.addToResizeSystem(this);

    if (thisSP._updateIntv < 0) {
      thisSP._updateIntv = setInterval(thisSP._tick, 200);
    }
  });
  this.$attachhook.updateSize = this.updateSize.bind(this);
  this.$header = null;
  this.$footer = null;
  this.$viewport = $('.absol-single-page-scroller-viewport', this);
  this.$scroller = $('.absol-single-page-scroller', this);
}

SinglePage.tag = 'SinglePage'.toLowerCase();

SinglePage.render = function () {
  return _({
    tag: 'tabframe',
    extendEvent: ['sizechange'],
    class: 'absol-single-page',
    child: [{
      class: 'absol-single-page-scroller',
      child: {
        class: 'absol-single-page-scroller-viewport'
      }
    }, 'attachhook']
  });
};

SinglePage.prototype.updateSize = function () {
  if (!this.isDescendantOf(document.body)) return;
  var paddingTop = parseFloat(this.getComputedStyleValue('padding-top').replace('px', '')) || 0;

  if (this.$header) {
    var headerBound = this.$header.getBoundingClientRect();
    var headerMarginTop = parseFloat(this.$header.getComputedStyleValue('margin-top').replace('px', '')) || 0;
    var headerMarginBottom = parseFloat(this.$header.getComputedStyleValue('margin-bottom').replace('px', '')) || 0;
    this.$scroller.addStyle('top', headerBound.height + headerMarginTop + headerMarginBottom + paddingTop + 'px');
    this._prevHeaderHeight = headerBound.height;
  }

  if (this.$footer) {
    var footerBound = this.$footer.getBoundingClientRect();
    this.$viewport.addStyle('padding-bottom', footerBound.height + 'px');
  }

  if (this.isSupportedEvent('sizechange')) this.emit('sizechange', {
    type: 'sizechange',
    target: this
  }, this);
  this.addStyle('--single-page-scroller-height', this.$scroller.clientHeight + 'px');
};

SinglePage.prototype.addChild = function (elt) {
  if (elt.classList.contains('absol-single-page-header')) {
    if (this.firstChild) {
      this.addChildBefore(elt, this.firstChild);
    } else {
      this.appendChild(elt);
    }

    this.$header = $(elt);
    this.updateSize();
  } else if (elt.classList.contains('absol-single-page-footer')) {
    this.$viewport.addChild(elt);
    this.$footer = $(elt);
    this.updateSize();
  } else {
    this.$viewport.addChild(elt);
  }
};

SinglePage.prototype.removeChild = function (elt) {
  if (elt == this.$footer) {
    this.$viewport.removeChild(elt);
    this.$footer = undefined;
    this.updateSize();
  } else if (elt == this.$header) {
    this.super(elt);
    this.$header = undefined;
    this.updateSize();
  } else {
    this.$viewport.removeChild(elt);
  }
};

_ACore.default.install(SinglePage);

var _default = SinglePage;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Snackbar.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Snackbar.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/snackbar.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _Dom = require("absol/src/HTML5/Dom");


var _ = _ACore.default._;
var $ = _ACore.default.$;
var t = document.createElement;
/***
 * @extends AElement
 * @constructor
 */

function SnackBar() {
  // OOP.drillProperty(this, this.firstChild, 'message', 'data');

  /***
   *
   * @type {*}
   */
  this._message = null;
  this.message = null;
}

SnackBar.tag = 'SnackBar'.toLowerCase();

SnackBar.render = function () {
  return _({
    class: 'as-snackbar'
  });
};

SnackBar.property = {};
SnackBar.property.message = {
  set: function (value) {
    this._message = value;

    if (value instanceof Array) {
      this.clearChild();
      this.addChild(value.map(function (item) {
        return _(item);
      }));
    } else if (typeof value === 'string') {
      this.innerHTML = value;
    } else if ((0, _Dom.isDomNode)(value)) {
      this.clearChild().addChild(value);
    } else if (value && typeof value === 'object' && (value.text || value.props || value.tag || value.attr || value.style || value.child || value.child && value.child instanceof Array)) {
      this.clearChild().addChild(_(value));
    } else {
      this.clearChild();
      this._message = null;
    }
  },
  get: function () {
    return this._message;
  }
};

_ACore.default.install(SnackBar);

SnackBar.$instance = _('snackbar');
SnackBar._removeTimeout = -1;

SnackBar.show = function (message) {
  if (SnackBar._removeTimeout > 0) {
    clearTimeout(SnackBar._removeTimeout);
  }

  if (!SnackBar.$instance.parentElement) document.body.appendChild(SnackBar.$instance);
  SnackBar.$instance.removeClass('as-hiding');
  SnackBar._removeTimeout = setTimeout(function () {
    SnackBar.$instance.addClass('as-show');
    SnackBar.$instance.message = message;
    SnackBar._removeTimeout = setTimeout(function () {
      SnackBar.$instance.removeClass('as-show').addClass('as-hiding');
      SnackBar._removeTimeout = setTimeout(function () {
        SnackBar.$instance.remove();
        SnackBar._removeTimeout = -1;
        SnackBar.$instance.removeClass('as-hiding');
      }, 500);
    }, 3000);
  }, 1);
};

var _default = SnackBar;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SpanInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SpanInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/spaninput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _utils = require("./utils");

var _Text = require("absol/src/HTML5/Text");


var _ = _ACore.default._;
var $ = _ACore.default.$;

function SpanInput() {
  this.defineEvent(['change']);
  this._inputType = 0;
  this._lastValue = null;
  this.on('paste', this.eventHandler.paste).on('keyup', this.eventHandler.keyup).on('keydown', this.eventHandler.keydown).on('blur', this.eventHandler.blur);
}

SpanInput.prototype.notifyValueChange = function (event) {
  var cValue = this.value;

  if (this._lastValue != cValue && (this._inputType != 1 || !isNaN(this._lastValue) || !isNaN(cValue))) {
    this._lastValue = cValue;
    this.emit('change', {
      type: 'change',
      value: cValue,
      originEvent: event
    }, this);
  }
};

SpanInput.eventHandler = {};

SpanInput.eventHandler.keyup = function (event) {
  if (this._inputType == 0) {
    this.notifyValueChange(event);
  } else if (this._inputType == 1) {
    this.eventHandler.numberKeyup(event);
  }
};

SpanInput.eventHandler.keydown = function (event) {
  if (this._inputType == 0) {} else if (this._inputType == 1) {
    this.eventHandler.numberKeydown(event);
  }
};

SpanInput.eventHandler.numberBlur = function (value) {
  this.notifyValueChange(event);
};

SpanInput.eventHandler.textBlur = function (event) {
  this.notifyValueChange(event);
};

SpanInput.eventHandler.blur = function (event) {
  if (this._inputType == 0) {
    this.eventHandler.textBlur(event);
  } else if (this._inputType == 1) {
    this.eventHandler.numberKeydown(event);
  }
};

SpanInput.eventHandler.numberKeyup = function (event) {
  this.notifyValueChange();
};

SpanInput.eventHandler.numberKeydown = function (event) {
  var key = event.key;

  if (key == 'Enter') {
    event.preventDefault();
    this.blur();
    this.notifyValueChange();
    return;
  }

  if (key && key.length == 1 && !event.ctrlKey && !event.altKey) {
    if (key.match(/[0-9.\-\+]/)) {
      if (key == '.' && this.text.indexOf('.') >= 0) event.preventDefault();
      if ((key == '+' || key == '-') && (this.text.indexOf('+') >= 0 || this.text.indexOf('-') >= 0 || getCaretPosition(this) > 0)) event.preventDefault();
    } else event.preventDefault();
  }
};

SpanInput.eventHandler.paste = function (event) {
  event.preventDefault();

  if (event.clipboardData && event.clipboardData.getData) {
    var text = event.clipboardData.getData("text/plain");
    if (this._inputType == 1) text = text.replace(/[^0-9.\-+]/g, '');
    document.execCommand("insertHTML", false, text);

    if (this._inputType == 1) {
      if (isNaN(this.value)) {
        this.value = NaN;
      }
    }
  } else if (window.clipboardData && window.clipboardData.getData) {
    var text = window.clipboardData.getData("Text");
    if (this._inputType == 1) text = text.replace(/[^0-9.\-+]/g, '');
    (0, _utils.insertTextAtCursor)(text);

    if (this._inputType == 1) {
      if (isNaN(this.value)) {
        this.value = NaN;
      }
    }
  }
};

SpanInput.property = {};
SpanInput.property.value = {
  set: function (value) {
    if (this._inputType == 1 && isNaN(value)) value = null;
    this.clearChild();
    if (value !== null) this.addChild(_({
      text: value + ''
    }));
  },
  get: function () {
    if (this._inputType == 1) {
      return parseFloat(this.text);
    } else {
      return this.text;
    }
  }
};
SpanInput.property.type = {
  set: function (value) {
    var index = ['text', 'number'].indexOf(value);
    if (index < 0) index = 0;
    this._inputType = index;

    if (index == 1) {
      this.addClass('absol-span-input-empty-minus');
    } else {
      this.removeClass('absol-span-input-empty-minus');
    }
  },
  get: function () {
    return ['text', 'number'][this._inputType];
  }
};
SpanInput.property.text = {
  get: function () {
    return (0, _Text.getTextIn)(this);
  }
};
SpanInput.tag = 'spaninput';

SpanInput.render = function () {
  return _('span.absol-span-input[contenteditable="true"]');
};

_ACore.default.install(SpanInput);

var _default = SpanInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/StaticTabbar.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/StaticTabbar.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/statictabbar.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _stringGenerate = require("absol/src/String/stringGenerate");


var $ = _ACore.default.$;
var _ = _ACore.default._;

function StaticTabbar() {
  var thisST = this;
  this.$activeBox = $('.absol-static-tabbar-active-box', this);
  this.$hline = $('.absol-static-tabbar-hline', this);
  this.$buttons = [];
  this._btDict = {};
  this._activedButton = undefined;
  this.sync = new Promise(function (resolve) {
    _('attachhook').on('error', function () {
      this.remove();
      resolve();
    }).addTo(thisST);
  });
  return this;
}

StaticTabbar.tag = 'StaticTabbar'.toLowerCase();

StaticTabbar.render = function () {
  return _({
    class: 'absol-static-tabbar',
    extendEvent: 'change',
    child: [{
      class: 'absol-static-tabbar-active-box',
      child: '.absol-static-tabbar-hline'
    }]
  });
};

StaticTabbar.prototype.fireChange = function (data) {
  this.emit('change', {
    target: this,
    data,
    value: this.value
  }, self);
};

StaticTabbar.property = {};
StaticTabbar.property.items = {
  set: function (value) {
    this.$buttons.forEach(function (e) {
      e.remove();
    });
    this._items = value;
    var self = this;
    this.$buttons = this.items.map(function (tab) {
      var ident = tab.value || (0, _stringGenerate.randomIdent)();

      var button = _({
        tag: 'button',
        class: 'absol-static-tabbar-button',
        id: 'tab-' + ident,
        child: {
          tag: 'span',
          child: {
            text: tab.text
          }
        },
        on: {
          click: function (event) {
            if (self.value != tab.value) {
              self.value = ident;
              self.fireChange(tab);
            }
          }
        }
      }).addTo(self);

      self._btDict[ident] = button;
      return button;
    });

    if (this.value !== undefined) {
      this.sync.then(this.activeTab.bind(this, this.value));
    }
  },
  get: function () {
    return this._items || [];
  }
};
StaticTabbar.property.value = {
  set: function (value) {
    this._value = value;

    if (this.$buttons.length > 0) {
      this.sync.then(this.activeTab.bind(this, value));
    }
  },
  get: function () {
    return this._value;
  }
};

StaticTabbar.prototype.activeTab = function (ident) {
  if (this._activedButton) this._activedButton.removeClass('active');
  var button = this._btDict[ident];
  this._activedButton = button;

  if (button) {
    button.addClass('active');
    var bound = this.getBoundingClientRect();
    var buttonBound = button.getBoundingClientRect();
    var dx = buttonBound.left - bound.left;
    var fontSize = this.getFontSize();
    this.$activeBox.addStyle({
      left: dx / fontSize + 'em',
      width: buttonBound.width / fontSize + 'em'
    });
  } else {
    this.$activeBox.addStyle({
      left: '0',
      width: '0'
    });
  }
};

_ACore.default.install('statictabbar', StaticTabbar);

var _default = StaticTabbar;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Switch.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Switch.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/switch.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function Switch() {
  var thisS = this;
  this.$input = $('input', this);
  this.$input.on('click', function (event) {
    thisS.emit('change', event, thisS);
  });

  _OOP.default.drillProperty(this, this.$input, 'checked');

  _OOP.default.drillProperty(this, this.$input, 'isOn', 'checked');
}

Switch.tag = 'switch';

Switch.render = function () {
  return _({
    tag: 'label',
    class: 'absol-switch',
    extendEvent: 'change',
    child: ['input[type="checkbox"]', 'span.absol-switch-slider']
  });
};

Switch.attribute = {
  checked: {
    set: function (value) {
      if (value == 'false' || value == null) {
        this.checked = false;
      } else {
        this.checked = true;
      }
    },
    get: function () {
      return this.checked ? 'true' : 'false';
    },
    remove: function () {
      this.checked = false;
    }
  },
  disabled: {
    set: function (value) {
      if (value == 'false' || value == null) {
        this.disabled = false;
      } else {
        this.disabled = true;
      }
    },
    get: function () {
      return this.disabled ? 'true' : 'false';
    },
    remove: function () {
      this.disabled = false;
    }
  }
};
Switch.property = {
  disabled: {
    set: function (value) {
      this.$input.disabled = !!value;

      if (value) {
        this.addClass('disabled');
      } else {
        this.removeClass('disabled');
      }
    },
    get: function () {
      return this.$input.disabled;
    }
  }
};

_ACore.default.install('switch', Switch);

var _default = Switch;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TabFrame.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TabFrame.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireDefault(require("../ACore"));


var $ = _ACore.default.$;
var _ = _ACore.default._;

function TabFrame() {}

TabFrame.tag = 'tabframe';

TabFrame.render = function () {
  return _({
    tag: 'frame',
    class: 'absol-tab-frame',
    extendEvent: ['requestremove', 'remove']
  }, true);
};

TabFrame.property = {};
TabFrame.property.name = {
  set: function (value) {
    if (typeof name == "undefined") {
      this._name = undefined;
    } else {
      this._name = value + '';
    }

    if (this.$parent) {
      if (this.$parent.notifyUpdateName) this.$parent.notifyUpdateName(this);
    }
  },
  get: function () {
    return this._name;
  }
};
TabFrame.property.modified = {
  set: function (value) {
    this._modified = !!value;

    if (this.$parent) {
      if (this.$parent.notifyUpdateModified) this.$parent.notifyUpdateModified(this);
    }
  },
  get: function () {
    return !!this._modified;
  }
};
TabFrame.property.desc = {
  set: function (value) {
    if (typeof value == "undefined") {
      this._desc = undefined;
    } else {
      this._desc = value + '';
    }

    if (this.$parent) {
      if (this.$parent.notifyUpdateDesc) this.$parent.notifyUpdateDesc(this);
    }
  },
  get: function () {
    return this._desc;
  }
};
TabFrame.attribute = {};
TabFrame.attribute.name = {
  set: function (value) {
    this.name = value;
  },
  get: function () {
    return this.name;
  },
  remove: function () {
    this.name = undefined;
  }
};
TabFrame.attribute.desc = {
  set: function (value) {
    this.desc = value;
  },
  get: function () {
    return this.desc;
  },
  remove: function () {
    this.desc = undefined;
  }
};
TabFrame.attribute.modified = {
  set: function (value) {
    this.modified = value == 'true' || value == '1' || value === true;
  },
  get: function () {
    return this.modified ? 'true' : undefined;
  },
  remove: function () {
    this.desc = false;
  }
};

TabFrame.prototype.requestRemove = function () {
  if (this.$parent && this.$parent.removeTab) {
    this.$parent.removeTab(this.id, false);
  } else {
    this.selfRemove();
  }
};

_ACore.default.install(TabFrame);

var _default = TabFrame;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TabButton.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TabButton.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/tabview.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _stringGenerate = require("absol/src/String/stringGenerate");

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function TabButton() {
  var thisTB = this;
  this.$close = $('.absol-tabbar-button-close', this);
  this.$iconCtn = $('.absol-tabbar-button-icon-container', this).on('click', function (event) {
    event.tabButtonEventName = 'delete';
    thisTB.emit('close', event);
  });
  this.$modifiedFlag = $('.absol-tabbar-button-modified-flag', this).on('click', function (event) {
    event.tabButtonEventName = 'delete';
    thisTB.emit('close', event);
  });
  this.$textView = $('.absol-tabbar-button-text', this);
  this.on({
    click: function (event) {
      if (event.tabButtonEventName) return;
      event.tabButtonEventName = 'active';
      thisTB.emit('active', event);
    }
  });
}

TabButton.tag = 'TabButton';

TabButton.render = function () {
  return _({
    tag: 'button',
    class: 'absol-tabbar-button',
    extendEvent: ['close', 'active'],
    id: (0, _stringGenerate.randomIdent)(20),
    child: [{
      class: 'absol-tabbar-button-text'
    }, {
      class: 'absol-tabbar-button-icon-container',
      child: [{
        tag: 'span',
        class: ['absol-tabbar-button-close', 'mdi-close', 'mdi'],
        attr: {
          title: 'Close'
        }
      }, {
        tag: 'span',
        class: ['absol-tabbar-button-close-circle', 'mdi-close-circle', 'mdi'],
        attr: {
          title: 'Close'
        }
      }, {
        tag: 'span',
        class: ['absol-tabbar-button-modified-flag', 'mdi', 'mdi-checkbox-blank-circle']
      }]
    }]
  });
};

TabButton.property = {};
TabButton.property.active = {
  set: function (value) {
    this._active = value;
    if (value) this.addClass('absol-tabbar-button-active');else this.removeClass('absol-tabbar-button-active');
  },
  get: function () {
    return this._active;
  }
};
TabButton.property.name = {
  set: function (value) {
    this._name = value || '';
    this.$textView.innerHTML = this._name;
  },
  get: function () {
    return this._name;
  }
};
TabButton.property.desc = {
  set: function (value) {
    this.attr('title', value);
  },
  get: function () {
    return this.attr('title');
  }
};
TabButton.property.modified = {
  set: function (value) {
    if (value) {
      this.addClass('absol-tabbar-button-modified');
    } else {
      this.removeClass('absol-tabbar-button-modified');
    }
  },
  get: function () {
    return this.containsClass('absol-tabbar-button-modified');
  }
};

_ACore.default.install(TabButton);

var _default = TabButton;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TabBar.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TabBar.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/tabview.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _TabButton = _interopRequireDefault(require("./TabButton"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function TabBar() {
  this.defineEvent(['active', 'close']);
  this.on('wheel', function (event) {
    var lastLeft = this.$viewport.scrollLeft;

    if (event.deltaY > 1) {
      this.$viewport.scrollLeft += 50;
    } else if (event.deltaY < -1) {
      this.$viewport.scrollLeft -= 50;
    }

    if (lastLeft != this.$viewport.scrollLeft) event.preventDefault();
  });
  this._tabs = [];
}

TabBar.tag = 'tabbar';

TabBar.render = function () {
  return _('hscroller.absol-tabbar');
};

TabBar.prototype.getAllTabButtons = function () {
  var buttons = [];
  $('tabbutton', this, function (e) {
    buttons.push(e);
  });
  return buttons;
};
/***
 *
 * @param {string} ident
 * @return {TabButton}
 */


TabBar.prototype.getButtonByIdent = function (ident) {
  return $('tabbutton#tabbuton-' + ident, this);
};

TabBar.property = {};
TabBar.property.tabs = {
  set: function (value) {
    this.clearChild();
    this._tabs = [];
    (value || []).forEach(this.addTab.bind(this));
  },
  get: function () {
    //each hold item data
    return this._tabs || [];
  }
};
/***
 *
 * @param {{text}}
 * @return {tabbar}
 */

TabBar.prototype.addTab = function (value) {
  var self = this;
  var props = {};

  if (typeof value == "string") {
    props.name = value;
  } else {
    if (value.name) {
      props.name = value.name;
    } else {
      throw new Error('Tab must has name attribute');
    }

    if (value.desc) props.desc = value.desc;
  }

  var tabButton = _({
    tag: 'tabbutton',
    props: props,
    on: {
      active: function (event, sender) {
        var prevented = false;
        self.emit('active', {
          target: this,
          value: value,
          preventDefault: function () {
            prevented = true;
          }
        }, self);

        if (!prevented) {
          self.getAllTabButtons().forEach(function (e) {
            e.active = false;
          });
          this.active = true;
        }
      },
      close: function (event, sender) {
        var prevented = false;
        self.emit('close', {
          target: this,
          value: value,
          preventDefault: function () {
            prevented = true;
          }
        }, self);

        if (!prevented) {
          //todo:active other
          this.remove();
        }
      }
    }
  }).addTo(this);

  if (value.id) tabButton.attr('id', 'tabbuton-' + value.id);

  this._tabs.push(tabButton);

  this.requestUpdateSize();
  return tabButton;
};

TabBar.prototype.removeTab = function (id) {
  this._tabs = this._tabs.filter(function (value) {
    return value == id;
  });
  $('#tabbuton-' + id, this).remove();
  this.requestUpdateSize();
};

TabBar.prototype.activeTab = function (id) {
  var self = this;
  var activedbtn = $('.absol-tabbar-button-active', this);

  if (activedbtn && activedbtn.attr('id') != id) {
    activedbtn.active = false;
  }

  var mButton = $('#tabbuton-' + id, this);

  if (mButton) {
    mButton.active = true;
    setTimeout(function () {
      self.scrollInto(mButton);
    }, 30);
  }
};

TabBar.prototype.setModified = function (ident, flag) {
  var bt = this.getButtonByIdent(ident);

  if (bt) {
    bt.modified = flag;
  }
};

_ACore.default.install(TabBar);

var _default = TabBar;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TabView.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TabView.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/tabview.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _TabBar = _interopRequireDefault(require("./TabBar"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function TabView() {
  var thisTV = this;
  /***
   *
   * @type {TabBar}
   */

  this.$tabbar = $('tabbar', this);
  this.$tabbar.on({
    close: TabView.eventHandler.closeTab.bind(thisTV),
    active: TabView.eventHandler.activeTab.bind(thisTV)
  });
  this._frameHolders = [];
  this._history = [];
}

TabView.tag = 'TabView'.toLowerCase();

TabView.render = function () {
  return _({
    class: 'absol-tabview',
    extendEvent: ['activetab', 'deactivetab', 'removetab', 'requestremovetab'],
    child: ['tabbar']
  });
};

TabView.eventHandler = {};

TabView.eventHandler.closeTab = function (event) {
  event.preventDefault();
  var id = event.value.id;
  this.removeTab(id, true);
};

TabView.eventHandler.activeTab = function (event) {
  event.preventDefault();
  var id = event.value.id;
  this.activeTab(id, true);
};

TabView.prototype.activeTab = function (id, userActive) {
  var self = this;
  var resPromise = [];
  var needDeactiveHolder = [];
  var needActiveHolder = [];

  this._frameHolders.forEach(function (holder) {
    if (holder.containerElt.containsClass('absol-tabview-container-hidden')) {
      if (holder.id == id) {
        needActiveHolder.push(holder);
      }
    } else {
      if (holder.id != id) {
        needDeactiveHolder.push(holder);
      }
    }
  });

  needDeactiveHolder.forEach(function (holder) {
    holder.containerElt.addClass('absol-tabview-container-hidden');
    holder.tabFrame.emit('deactive', {
      type: 'deactive',
      target: holder.tabFrame,
      id: holder.id,
      userActive: !!userActive,
      tabButton: holder.tabButton,
      holder: holder
    }, holder.tabFrame);
  });
  needActiveHolder.forEach(function (holder) {
    self._history.push(holder.id);

    holder.containerElt.removeClass('absol-tabview-container-hidden');
    self.$tabbar.activeTab(holder.id);
    holder.tabFrame.emit('active', {
      type: 'active',
      target: holder.tabFrame,
      id: holder.id,
      userActive: !!userActive,
      tabButton: holder.tabButton,
      holder: holder
    }, holder.tabFrame);
    self.emit('activetab', {
      type: 'activetab',
      target: self,
      id: holder.id,
      userActive: !!userActive,
      tabButton: holder.tabButton,
      holder: holder
    }, self);
  });
};

TabView.prototype.removeTab = function (id, userActive) {
  var self = this;
  var resPromise = [];

  this._frameHolders.forEach(function (holder) {
    if (holder.id == id) {
      var eventData = {
        type: 'requestremove',
        id: id,
        userActive: !!userActive,
        target: holder.tabFrame,
        tabFrame: holder.tabFrame,
        tabButton: holder.tabButton,
        holder: holder,
        __promise__: Promise.resolve(),
        waitFor: function (promise) {
          this.__promise__ = promise;
        }
      };
      holder.tabFrame.emit('requestremove', eventData, holder.tabFrame);
      eventData.type = 'requestremovetab';
      eventData.target = self;
      self.emit('requestremovetab', eventData, self);
      resPromise.push(eventData.__promise__.then(function () {
        //if ok
        var eventData2 = {
          type: 'deactive',
          target: holder.tabFrame,
          id: holder.id,
          userActive: !!userActive,
          tabButton: holder.tabButton,
          holder: holder
        };
        if (!holder.containerElt.containsClass('absol-tabview-container-hidden')) holder.tabFrame.emit('deactive', eventData2, holder.tabFrame);
        eventData2.type = 'deactivetab';
        eventData2.target = self;
        if (!holder.containerElt.containsClass('absol-tabview-container-hidden')) self.emit('deactivetab', eventData2, self);
        self._frameHolders = self._frameHolders.filter(function (x) {
          return x.id != id;
        });
        holder.tabFrame.notifyDetached();
        self.$tabbar.removeTab(holder.id);
        holder.containerElt.remove();
        eventData2.type = 'remove';
        eventData2.target = holder.tabFrame;
        holder.tabFrame.emit('remove', eventData2, holder.tabFrame);
        eventData2.type = 'removetab';
        eventData2.target = self;
        self.emit('removetab', eventData2, self);
        self.activeLastTab();
      }, function () {//if reject
      }));
    }
  });

  return Promise.all(resPromise);
};

TabView.prototype.notifyUpdateDesc = function (elt) {
  var holder = this.findHolder(elt);

  if (holder) {
    holder.tabButton.desc = elt.desc;
  }
};

TabView.prototype.notifyUpdateName = function (elt) {
  var holder = this.findHolder(elt);

  if (holder) {
    holder.tabButton.name = elt.name;
  }
};

TabView.prototype.notifyUpdateModified = function (elt) {
  var holder = this.findHolder(elt);

  if (holder) {
    holder.tabButton.modified = elt.modified;
  }
};

TabView.prototype.findHolder = function (elt) {
  for (var i = 0; i < this._frameHolders.length; ++i) {
    var holder = this._frameHolders[i];

    if (holder.tabFrame == elt) {
      return holder;
    }
  }
};

TabView.prototype.addChild = function () {
  var self = this;
  Array.prototype.forEach.call(arguments, function (elt) {
    if (!elt.notifyAttached || !elt.notifyDetached) {
      throw new Error('element is not a tabframe');
    }

    var containerElt = _('.absol-tabview-container.absol-tabview-container-hidden');

    self.appendChild(containerElt); //origin function

    elt.selfRemove();
    var id = elt.attr('id');
    var desc = elt.attr('desc') || undefined;
    var name = elt.attr('name') || 'NoName';
    var modified = elt.modified;
    var tabButton = self.$tabbar.addTab({
      name: name,
      id: id,
      desc: desc,
      modified: modified
    });
    containerElt.addChild(elt);
    elt.notifyAttached(self);
    var holder = {};

    _OOP.default.drillProperty(holder, elt, 'id');

    _OOP.default.drillProperty(holder, elt, 'desc');

    _OOP.default.drillProperty(holder, elt, 'name');

    Object.defineProperties(holder, {
      tabButton: {
        value: tabButton,
        writable: false
      },
      tabFrame: {
        value: elt,
        writable: false
      },
      containerElt: {
        value: containerElt,
        writable: false
      }
    });

    self._frameHolders.push(holder);

    self.activeTab(id);
  });
};

TabView.prototype.activeLastTab = function () {
  var dict = this._frameHolders.reduce(function (ac, holder) {
    ac[holder.id] = true;
    return ac;
  }, {});

  while (this._history.length > 0) {
    var id = this._history[this._history.length - 1];

    if (dict[id]) {
      this.activeTab(id);
      break;
    } else {
      this._history.pop();
    }
  }
};

TabView.prototype.getChildAt = function (index) {
  return this._frameHolders[index].tabFrame;
};

TabView.prototype.getAllChild = function () {
  return this._frameHolders.map(function (holder) {
    return holder.tabFrame;
  });
};

TabView.prototype.getActiveTabHolder = function () {
  var holder = null;

  for (var i = 0; i < this._frameHolders.length; ++i) {
    holder = this._frameHolders[i];

    if (!holder.containerElt.containsClass('absol-tabview-container-hidden')) {
      return holder;
    }
  }

  return null;
};

TabView.prototype.getActiveTab = function () {
  var holder = this.getActiveTabHolder();
  return holder && holder.tabFrame;
};

TabView.prototype.getActiveTabId = function () {
  var holder = this.getActiveTabHolder();
  return holder && holder.id;
};

TabView.prototype.getTabById = function (id) {
  var holder = this.getTabHolderById(id);
  return holder && holder.tabFrame;
};

TabView.prototype.getTabHolderById = function (id) {
  var holder = null;

  for (var i = 0; i < this._frameHolders.length; ++i) {
    holder = this._frameHolders[i];

    if (holder.id === id) {
      return holder;
    }
  }

  return null;
};

TabView.prototype.activeFrame = function (elt) {
  if (typeof elt == "string") {
    return this.activeTab(elt);
  } else if (elt && elt.attr) {
    return this.activeTab(elt.attr('id'));
  } else {
    throw new Error("Invalid param, must be id or elt!");
  }
};

TabView.property = {};
TabView.property.historyOfTab = {
  get: function () {
    return this._history.slice();
  }
};

_ACore.default.install('tabview', TabView);

var _default = TabView;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TableScroller.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TableScroller.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/tablescroller.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _BScroller = _interopRequireDefault(require("./BScroller"));


var $ = _ACore.default.$;
var _ = _ACore.default._;

function TableScroller() {
  var thisTS = this;
  this.$content = undefined;
  this.$fixedViewport = $('.absol-table-scroller-fixed-viewport', this);
  this.$leftScroller = $('.absol-table-scroller-left-vscroller', this);
  this.$leftViewport = $('.absol-table-scroller-left-vscroller-viewport', this).on('scroll', thisTS.eventHandler.scrollLeftScrollerViewport);
  ;
  this.$headScroller = $('.absol-table-scroller-header-hscroller', this);
  this.$headScrollerViewport = $('.absol-table-scroller-header-hscroller-viewport', this).on('scroll', this.eventHandler.scrollHeadScrollerViewport);
  this.$attachHook = $('attachhook', this);
  this.$attachHook.requestUpdateSize = this._updateContentSize.bind(this);
  this.$attachHook.on('error', function () {
    _Dom.default.addToResizeSystem(this);
  });
  this.sync = new Promise(function (rs) {
    thisTS.$attachHook.once('error', rs);
  });
  this.$viewport = $('.absol-table-scroller-viewport', this).on('scroll', this.eventHandler.scrollViewport);
  this.$viewport.scrollInto = _BScroller.default.prototype.scrollInto;
  this.$leftLine = $('.absol-table-scroller-left-line', this);
  this.$headLine = $('.absol-table-scroller-head-line', this);
  this.$vscrollbarCtn = $('.absol-table-scroller-vscrollbar-container', this);
  this.$vscrollbar = $('.absol-table-scroller-vscrollbar-container vscrollbar', this).on('scroll', function () {
    thisTS.$viewport.scrollTop = this.innerOffset;
  });
  this.$hscrollbarCtn = $('.absol-table-scroller-hscrollbar-container', this);
  this.$hscrollbar = $('.absol-table-scroller-hscrollbar-container hscrollbar', this).on('scroll', function () {
    thisTS.$viewport.scrollLeft = this.innerOffset;
  });
  this.$vscrollbar.hidden = false;
  this.$hscrollbar.hidden = false;
  this._fixedTableThsVisible = [];
  this._fixedTableTr = [];
  this._fixedTableThs = [];
}

TableScroller.tag = 'TableScroller'.toLowerCase();

TableScroller.render = function () {
  return _({
    class: 'absol-table-scroller',
    child: ['.absol-table-scroller-viewport', '.absol-table-scroller-fixed-viewport', //place holder
    {
      class: 'absol-table-scroller-header-hscroller',
      child: '.absol-table-scroller-header-hscroller-viewport'
    }, {
      class: 'absol-table-scroller-left-vscroller',
      child: '.absol-table-scroller-left-vscroller-viewport'
    }, '.absol-table-scroller-head-line', '.absol-table-scroller-left-line', {
      class: 'absol-table-scroller-vscrollbar-container',
      child: {
        tag: 'vscrollbar'
      }
    }, {
      class: 'absol-table-scroller-hscrollbar-container',
      child: {
        tag: 'hscrollbar'
      }
    }, 'attachhook']
  });
};

TableScroller.scrollSize = 17; //default 

_Dom.default.getScrollSize().then(function (size) {
  TableScroller.scrollSize = size.width; //default scroller

  TableScroller.$style = _('style[id="table-scroller-css"]').addTo(document.head);
  TableScroller.$style.innerHTML = ['.absol-table-scroller .absol-table-scroller-viewport {', // 
  '    width: calc(100% + ' + size.width + 'px);', '    height: calc(100% + ' + size.width + 'px);', '}', '.absol-table-scroller .absol-table-scroller-header-hscroller-viewport {', '    margin-bottom: -' + size.width + 'px;/*default*/', '}'].join('\n');

  _Dom.default.updateResizeSystem();

  setTimeout(_Dom.default.updateResizeSystem.bind(_Dom.default), 30); // css load delay
});

TableScroller.eventHandler = {};

TableScroller.eventHandler.scrollViewport = function (event) {
  if (!this.__scrollingElement__ || this.__scrollingElement__ == this.$viewport) {
    this.__scrollingElement__ = this.$viewport;
    this.$headScrollerViewport.scrollLeft = this.$viewport.scrollLeft;
    this.$leftViewport.scrollTop = this.$viewport.scrollTop;
    this.$vscrollbar.innerOffset = this.$viewport.scrollTop;
    this.$hscrollbar.innerOffset = this.$viewport.scrollLeft;

    if (this.__scrollTimer__ > 0) {
      clearTimeout(this.__scrollTimer__);
    }

    this.__scrollTimer__ = setTimeout(function () {
      this.__scrollingElement__ = undefined;
      this.__scrollTimer__ = -1;
    }.bind(this), 300);
  }
};

TableScroller.eventHandler.scrollHeadScrollerViewport = function (event) {
  if (!this.__scrollingElement__ || this.__scrollingElement__ == this.$headScrollerViewport) {
    this.__scrollingElement__ = this.$headScrollerViewport;
    this.$viewport.scrollLeft = this.$headScrollerViewport.scrollLeft;

    if (this.__scrollTimer__ > 0) {
      clearTimeout(this.__scrollTimer__);
    }

    this.__scrollTimer__ = setTimeout(function () {
      this.__scrollingElement__ = undefined;
      this.__scrollTimer__ = -1;
    }.bind(this), 100);
  }
};

TableScroller.eventHandler.scrollLeftScrollerViewport = function () {
  if (!this.__scrollingElement__ || this.__scrollingElement__ == this.$leftViewport) {
    this.__scrollingElement__ = this.$leftViewport;
    this.$viewport.scrollTop = this.$leftViewport.scrollTop;

    if (this.__scrollTimer__ > 0) {
      clearTimeout(this.__scrollTimer__);
    }

    this.__scrollTimer__ = setTimeout(function () {
      this.__scrollingElement__ = undefined;
      this.__scrollTimer__ = -1;
    }.bind(this), 100);
  }
};

TableScroller.prototype.clearChild = function () {
  this.$viewport.clearChild();
  this.$fixedViewport.clearChild();
  this.$headScrollerViewport.clearChild();
  this.$leftViewport.clearChild();
  this.$content = null;
  return this;
};

TableScroller.prototype.addChild = function (elt) {
  if (this.$viewport.childNodes.length == 0) {
    if (elt.tagName && elt.tagName.toLowerCase() == 'table') {
      elt.classList.add('absol-table-scroller-origin');
      this.$viewport.addChild(elt);
      this.$content = elt;

      this._updateContent();

      this.sync.then(this._updateContentSize.bind(this)).then(function () {
        setTimeout(this._updateContentSize.bind(this), 30);
      }.bind(this));
    } else {
      throw new Error('Element must be a table!');
    }
  } else {
    throw new Error("Only 1 table accepted!");
  }
};

TableScroller.prototype._updateFixedTable = function () {
  var fixedCol = this.fixedCol;
  this.$fixedViewport.clearChild();
  this.$fixedTable = $(this.$content.cloneNode(false)).addClass('absol-table-scroller-fixed-table').removeClass('absol-table-scroller-origin').addTo(this.$fixedViewport);
  this.$fixedTableThead = $(this.$contentThead.cloneNode(false)).addTo(this.$fixedTable);
  this.$fixedTableThead.clearChild();
  this._fixedTableThsVisible = [];
  var self = this;
  this._fixedTableTr = Array.prototype.filter.call(this.$contentThead.childNodes, function (elt) {
    return elt.tagName == "TR";
  }).map(function (tr) {
    var cloneTr = $(tr.cloneNode(false));
    cloneTr.__originElement__ = tr;
    self.$fixedTableThead.appendChild(cloneTr);
    return cloneTr;
  });
  this._fixedTableThs = this._fixedTableTr.map(function (tr) {
    return Array.prototype.filter.call(tr.__originElement__.childNodes, function (elt1) {
      return elt1.tagName == "TH" || elt1.tagName == "TD";
    }).reduce(function (ac, th) {
      var colspan = th.getAttribute('colspan');

      if (colspan) {
        colspan = parseInt(colspan);
      } else {
        colspan = 1;
      }

      ac.colspanSum += colspan;
      var cloneTh = $(th.cloneNode(true));
      tr.appendChild(cloneTh);
      cloneTh.__originElement__ = th;
      ac.result.push(cloneTh);

      if (ac.colspanSum <= fixedCol) {
        self._fixedTableThsVisible.push(th);
      }

      return ac;
    }, {
      result: [],
      colspanSum: 0
    }).result;
  });
};

TableScroller.prototype._updateHeaderScroller = function () {
  var self = this;
  this.$headScrollerViewport.clearChild();
  this.$headScrollerTable = $(this.$content.cloneNode(false)).removeClass('absol-table-scroller-origin').addTo(this.$headScrollerViewport);
  this.$headScrollerThead = $(this.$contentThead.cloneNode(false)).addTo(this.$headScrollerTable);
  this._headScrollerTr = Array.prototype.filter.call(this.$contentThead.childNodes, function (elt) {
    return elt.tagName == "TR";
  }).map(function (tr) {
    var cloneTr = $(tr.cloneNode(false));
    cloneTr.__originElement__ = tr;
    self.$headScrollerThead.appendChild(cloneTr);
    return cloneTr;
  });
  this._headScrollerTds = this._headScrollerTr.map(function (tr) {
    return Array.prototype.filter.call(tr.__originElement__.childNodes, function (elt1) {
      return elt1.tagName == "TH";
    }).map(function (th) {
      var cloneTh = $(th.cloneNode(true)).addTo(tr);
      cloneTh.__originElement__ = th;
      return cloneTh;
    });
  });
};

TableScroller.prototype._updateLeftTable = function () {
  this.$leftViewport.clearChild();
  this.$leftTable = $(this.$content.cloneNode(true)).addTo(this.$leftViewport);
};

TableScroller.prototype._updateContent = function () {
  this.$contentThead = $('thead', this.$content);

  this._updateFixedTable();

  this._updateHeaderScroller();

  this._updateLeftTable();
};

TableScroller.prototype._updateFixedTableSize = function () {
  var l = 1000;
  var r = -1000;

  this._fixedTableThsVisible.forEach(function (elt) {
    var b = elt.getBoundingClientRect();
    l = Math.min(l, b.left);
    r = Math.max(r, b.right);
  });

  this._leftWidth = Math.max(r - l, 0);
  this.$fixedViewport.addStyle('width', this._leftWidth + 2 + 'px');

  this._fixedTableTr.forEach(function (elt) {
    var styleHeight = elt.__originElement__.getBoundingClientRect().height + 'px';
    elt.addStyle('height', styleHeight);
  });

  this._fixedTableThs.forEach(function (row) {
    row.forEach(function (elt) {
      var styleWidth = elt.__originElement__.getBoundingClientRect().width + 'px';
      elt.addStyle('width', styleWidth);
    });
  });

  this.$fixedTable.addStyle({
    height: this.$contentThead.getBoundingClientRect().height + 'px',
    width: this.$content.getBoundingClientRect().width + 'px'
  });
};

TableScroller.prototype._updateHeaderScrollerSize = function () {
  var headHeight = this.$contentThead.getBoundingClientRect().height + 'px';
  this.$headScrollerTable.addStyle('height', headHeight);
  this.$headScrollerTable.addStyle('width', this.$content.getBoundingClientRect().width + 'px');

  this._headScrollerTr.forEach(function (elt) {
    var styleHeight = elt.__originElement__.getBoundingClientRect().height + 'px';
    elt.addStyle('height', styleHeight);
  });

  this._headScrollerTds.forEach(function (row) {
    row.forEach(function (elt) {
      var styleWidth = elt.__originElement__.getBoundingClientRect().width + 'px';
      elt.addStyle('width', styleWidth);
    });
  });
};

TableScroller.prototype._updateLeftTableSize = function () {
  this.$leftTable.addStyle('width', this.$content.getBoundingClientRect().width + 'px');
  this.$leftTable.addStyle('height', this.$content.getBoundingClientRect().height + 'px');
  this.$leftScroller.addStyle('width', this._leftWidth + 2 + 'px');
};

TableScroller.prototype._updateLinesSize = function () {
  if (this.$viewport.clientHeight < this.$viewport.scrollHeight) {
    this.addClass('scroll-v');
  } else {
    this.removeClass('scroll-v');
  }

  if (this.$viewport.clientWidth < this.$viewport.scrollWidth) {
    this.addClass('scroll-h');
  } else {
    this.removeClass('scroll-h');
  }

  this.$leftLine.addStyle({
    maxHeight: this.$content.getBoundingClientRect().height + 'px',
    left: this._leftWidth + 'px'
  });
  this.$headLine.addStyle({
    top: this.$contentThead.getBoundingClientRect().height + 'px',
    maxWidth: this.$content.getBoundingClientRect().width + 'px'
  });
};

TableScroller.prototype._updateScrollBarSize = function () {
  var viewportBound = this.$viewport.getBoundingClientRect();
  var tableBound = this.$content.getBoundingClientRect();
  this.$vscrollbar.innerHeight = this.$viewport.scrollHeight;
  this.$vscrollbar.outerHeight = viewportBound.height - TableScroller.scrollSize;
  this.$hscrollbar.innerWidth = this.$viewport.scrollWidth;
  this.$hscrollbar.outerWidth = viewportBound.width - TableScroller.scrollSize;
  var overHeight = this.$viewport.clientHeight < this.$viewport.scrollHeight;
  var overWidth = this.$viewport.clientWidth < this.$viewport.scrollWidth;

  if (overHeight) {
    if (overWidth) {
      this.$hscrollbarCtn.removeStyle('bottom');
      this.$vscrollbarCtn.removeStyle('right');
    } else {
      this.$vscrollbarCtn.addStyle('right', viewportBound.width - TableScroller.scrollSize - tableBound.width + 'px');
    }
  } else {
    if (overWidth) {
      this.$hscrollbarCtn.addStyle('bottom', viewportBound.height - TableScroller.scrollSize - tableBound.height + 'px');
    }
  }
};

TableScroller.prototype._updateContentSize = function () {
  if (!this.$fixedTable) return;

  this._updateFixedTableSize();

  this._updateHeaderScrollerSize();

  this._updateLeftTableSize();

  this._updateLinesSize();

  this._updateScrollBarSize();
};

TableScroller.property = {};
TableScroller.property.fixedCol = {
  set: function (value) {
    value = value || 0;
    this._fixedCol = value;

    if (this.$content) {
      this._updateContent();

      this.sync.then(this._updateContentSize.bind(this)).then(function () {
        setTimeout(this._updateContentSize.bind(this), 30);
      }.bind(this));
    }
  },
  get: function () {
    return this._fixedCol || 0;
  }
};

_ACore.default.install(TableScroller);

var _default = TableScroller;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TableVScroller.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TableVScroller.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/tablevscroller.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function TableVScroller() {
  var thisTS = this;
  this.$attachHook = $('attachhook', this);
  this.$attachHook.updateSize = this.update.bind(this);
  this.sync = new Promise(function (rs) {
    thisTS.$attachHook.on('error', rs);
  });
  this.$viewport = $('.absol-table-vscroller-viewport', this);
  this.$attachHook.on('error', function () {
    _Dom.default.addToResizeSystem(thisTS.$attachHook);

    this.updateSize();
  });
  this.$topTable = $('.absol-table-vscroller-head', this);
  this.$headLine = $('.absol-table-vscroller-head-line', this);
}

TableVScroller.tag = 'TableVScroller'.toLowerCase();

TableVScroller.render = function () {
  return _({
    class: 'absol-table-vscroller',
    child: ['.absol-table-vscroller-viewport', 'table.absol-table-vscroller-head', '.absol-table-vscroller-head-line', 'attachhook']
  });
};

TableVScroller.prototype.clearChild = function () {
  this.$viewport.clearChild();
  this.$topTable.clearChild();
};

TableVScroller.prototype.addChild = function (elt) {
  if (this.$viewport.childNodes.length == 0) {
    if (elt.tagName && elt.tagName.toLowerCase() == 'table') {
      this.$viewport.addChild(elt);
      this.$table = $(elt);
      this.$thead = $('thead', elt);
      this.$tr = $('tr', this.$thead);
      this.$topThead = this.$thead.cloneNode(true);
      this.$topTr = $('tr', this.$topThead);
      this.$topTable.addChild(this.$topThead).addStyle('display', 'none');
      this.update();
    } else {
      throw new Error('Element must be a table!');
    }
  } else {
    throw new Error("Only 1 table accepted!");
  }
};

TableVScroller.prototype._trackBackgroundColor = function (element) {
  var current = this.$thead;
  var res;

  while (current && !res && res != 'rgba(0, 0, 0, 0)') {
    res = window.getComputedStyle(element).getPropertyValue('background-color');
    current = current.parentNode;
  }

  if (res == 'rgba(0, 0, 0, 0)') return 'white';
  return res;
};

TableVScroller.prototype.updateStyle = function () {
  if (!this.$thead) return;
  var clazz = this.$table.attr('class');

  if (clazz) {
    clazz = clazz.trim().split(/\s+/);

    for (var i = 0; i < clazz.length; ++i) {
      this.$topTable.addClass(clazz[i]);
    }
  }

  var bgColor = this._trackBackgroundColor(this.$thead);

  this.$topTable.addStyle('background-color', bgColor);
};

TableVScroller.prototype.updateSize = function () {
  var theadBound = this.$thead.getBoundingClientRect();
  var tableBound = this.$table.getBoundingClientRect();
  this.$topTable.addStyle({
    width: tableBound.width + 'px',
    height: theadBound.height + 'px'
  });
  this.$headLine.addStyle({
    top: theadBound.height + 'px',
    maxWidth: tableBound.width + 'px'
  });

  if (this.$viewport.clientHeight < this.$viewport.scrollHeight) {
    this.addClass('scroll-v');
  } else {
    this.removeClass('scroll-v');
  }

  var realNodes = this.$tr.childNodes;
  var topNodes = this.$topTr.childNodes;

  for (var i = 0; i < realNodes.length; ++i) {
    if (!realNodes[i].tagName) continue;
    var wstyle = window.getComputedStyle($(realNodes[i])).getPropertyValue('width');
    $(topNodes[i]).attr('style', realNodes[i].attr('style')).addStyle('width', wstyle);
  }

  this.$topTable.removeStyle('display');
};

TableVScroller.prototype.update = function () {
  if (!this.$thead) return;
  this.updateStyle();
  this.updateSize();
};

_ACore.default.install(TableVScroller);

var _default = TableVScroller;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/SelectMenu.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/SelectMenu.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/selectmenu.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _search = require("./list/search");

var _SelectList = _interopRequireDefault(require("./SelectList"));


/*global absol*/
var _ = _ACore.default._;
var $ = _ACore.default.$;

_ACore.default.creator['dropdown-ico'] = function () {
  return _(['<svg class="dropdown" width="100mm" height="100mm" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">', '<g transform="translate(0,-197)">', '<path d="m6.3152 218.09a4.5283 4.5283 0 0 0-3.5673 7.3141l43.361 55.641a4.5283 4.5283 0 0 0 7.1421 7e-3l43.496-55.641a4.5283 4.5283 0 0 0-3.5673-7.3216z" />', '</g>', '</svg>'].join(''));
};

function SelectMenu() {
  var thisSM = this;
  this._items = [];
  this._value = null;
  this._lastValue = null;
  this.$holderItem = $('.absol-selectmenu-holder-item', this);
  this.$anchorCtn = SelectMenu.getAnchorCtn();
  this.$anchor = _('.absol-selectmenu-anchor.absol-disabled').addTo(this.$anchorCtn);
  this.$anchorContentCtn = _('.absol-selectmenu-anchor-content-container').addTo(this.$anchor);
  this.$dropdownBox = _('.absol-selectmenu-dropdown-box').addTo(this.$anchorContentCtn);
  this.$searchTextInput = _('searchtextinput').addStyle('display', 'none').addTo(this.$dropdownBox);
  this.$vscroller = _('bscroller').addTo(this.$dropdownBox);
  this.$selectlist = _('selectlist', this).addTo(this.$vscroller).on('sizechangeasync', this.eventHandler.listSizeChangeAsync).on('valuevisibilityasync', this.eventHandler.listValueVisibility);
  this.$scrollTrackElts = [];
  this.$removableTrackElts = [];
  this._itemsByValue = {};
  this.$searchTextInput.on('stoptyping', this.eventHandler.searchModify);
  this._searchCache = {};
  this.$selectlist.on('pressitem', this.eventHandler.selectlistPressItem, true);
  this.$selectlist.on('pressitem', function () {
    thisSM.isFocus = false;
  }, true);
  this._lastValue = "NOTHING_VALUE";
  this._resourceReady = true;
  this.on('mousedown', this.eventHandler.click, true);
  this.on('blur', this.eventHandler.blur);
  this.selectListBound = {
    height: 0,
    width: 0
  };
  this.$attachhook = $('attachhook', this).on('error', this.eventHandler.attached);
  this.sync = new Promise(function (rs) {
    $('attachhook', this).once('error', function () {
      rs();
    });
  });
  this._selectListScrollSession = null;
  this._itemIdxByValue = null;
  return this;
}

SelectMenu.tag = 'selectmenu-old';

SelectMenu.render = function () {
  return _({
    class: ['absol-selectmenu'],
    extendEvent: ['change', 'minwidthchange'],
    attr: {
      tabindex: '1'
    },
    child: ['.absol-selectmenu-holder-item', {
      tag: 'button',
      class: 'absol-selectmenu-btn',
      child: ['dropdown-ico']
    }, 'attachhook']
  });
};

SelectMenu.optimizeResource = true; // //will remove after SelectMenu completed

SelectMenu.getRenderSpace = function () {
  if (!SelectMenu.getRenderSpace.warned) {
    console.warn('SelectMenu.getRenderSpace() will be removed in next version');
  }

  SelectMenu.getRenderSpace.warned = true;

  if (!SelectMenu.$renderSpace) {
    SelectMenu.$renderSpace = _('.absol-selectmenu-render-space').addTo(document.body);
  }

  return SelectMenu.$renderSpace;
};

SelectMenu.getAnchorCtn = function () {
  if (!SelectMenu.$anchorCtn) {
    SelectMenu.$anchorCtn = _('.absol-selectmenu-anchor-container').addTo(document.body);
  }

  return SelectMenu.$anchorCtn;
};

SelectMenu.prototype.updateItem = function () {
  this.$holderItem.clearChild();

  if (this._itemsByValue[this.value]) {
    var elt = _({
      tag: 'selectlistitem',
      props: {
        data: this._itemsByValue[this.value]
      }
    }).addTo(this.$holderItem);

    elt.$descCtn.addStyle('width', this.$selectlist._descWidth + 'px');
  }
};

SelectMenu.prototype._dictByValue = function (items) {
  var dict = {};
  var item;

  for (var i = 0; i < items.length; ++i) {
    item = items[i];
    dict[item.value + ''] = item;
  }

  return dict;
};

SelectMenu.prototype.init = function (props) {
  props = props || {};
  Object.keys(props).forEach(function (key) {
    if (props[key] === undefined) delete props[key];
  });

  if (!('value' in props)) {
    if (props.items && props.items.length > 0) props.value = typeof props.items[0] == 'string' ? props.items[0] : props.items[0].value;
  }

  var value = props.value;
  delete props.value;
  this.super(props);
  this.value = value;
};

SelectMenu.property = {};
SelectMenu.property.items = {
  set: function (value) {
    this._searchCache = {};
    this._itemIdxByValue = null;
    /**
     * verity data
     */

    if (value) {
      value.forEach(function (it) {
        if (it && it.text) {
          it.text = it.text + '';
        }
      });
    }

    this._items = value;
    this._itemsByValue = this._dictByValue(value);

    if (!this._itemsByValue[this.value] && value.length > 0) {
      this.value = value[0].value;
    } else this.updateItem();

    this.$dropdownBox.removeStyle('min-width');
    this.selectListBound = this.$selectlist.setItemsAsync(value || []);
    this.style.setProperty('--select-list-desc-width', this.$selectlist.measuredSize.descWidth + 'px');
    this._resourceReady = true;
    this.addStyle('min-width', this.selectListBound.width + 2 + 23 + 'px');
    this.emit('minwidthchange', {
      target: this,
      value: this.selectListBound.width + 2 + 23,
      type: 'minwidthchange'
    }, this);
  },
  get: function () {
    return this._items || [];
  }
};
SelectMenu.property.value = {
  set: function (value) {
    this.$selectlist.value = value;
    this._lastValue = value;
    this.updateItem();
  },
  get: function () {
    return this.$selectlist.value;
  }
};
SelectMenu.property.enableSearch = {
  set: function (value) {
    this._enableSearch = !!value;

    if (value) {
      this.$searchTextInput.removeStyle('display');
    } else {
      this.$searchTextInput.addStyle('display', 'none');
    }
  },
  get: function () {
    return !!this._enableSearch;
  }
};

SelectMenu.prototype.updateDropdownPostion = function (updateAnchor) {
  if (!this.isFocus) {
    this.$anchorContentCtn.removeStyle('left').removeStyle('top');
    this.$dropdownBox.removeStyle('min-width');
    return;
  }

  var bound = this.getBoundingClientRect();

  if (!updateAnchor) {
    var outBound = _Dom.default.traceOutBoundingClientRect(this);

    if (!this.isFocus || bound.top > outBound.bottom || bound.bottom < outBound.top) {
      this.isFocus = false;
      return;
    }

    var anchorOutBound = _Dom.default.traceOutBoundingClientRect(this.$anchor);

    var searchBound = this.$searchTextInput.getBoundingClientRect();
    var availableTop = bound.top - anchorOutBound.top - (this.enableSearch ? searchBound.height + 8 : 0) - 20;
    var availableBottom = anchorOutBound.bottom - bound.bottom - (this.enableSearch ? searchBound.height + 8 : 0) - 20;

    if (this.forceDown || availableBottom >= this.selectListBound.height || availableBottom > availableTop) {
      this.isDropdowUp = false;

      if (this.$dropdownBox.firstChild != this.$searchTextInput) {
        this.$searchTextInput.selfRemove();
        this.$dropdownBox.addChildBefore(this.$searchTextInput, this.$vscroller);
      }

      this.$vscroller.addStyle('max-height', availableBottom + 'px');
    } else {
      this.isDropdowUp = true;

      if (this.$dropdownBox.lastChild != this.$searchTextInput) {
        this.$searchTextInput.selfRemove();
        this.$dropdownBox.addChild(this.$searchTextInput);
      }

      this.$vscroller.addStyle('max-height', availableTop + 'px');
    }

    this.$dropdownBox.addStyle('min-width', bound.width + 'px');
  }

  var anchorBound = this.$anchor.getBoundingClientRect();

  if (this.isDropdowUp) {
    this.$anchorContentCtn.addStyle({
      left: bound.left - anchorBound.left + 'px',
      top: bound.top - anchorBound.top - this.$dropdownBox.clientHeight - 1 + 'px'
    });
  } else {
    this.$anchorContentCtn.addStyle({
      left: bound.left - anchorBound.left + 'px',
      top: bound.bottom - anchorBound.top + 'px'
    });
  }
};

SelectMenu.prototype.scrollToSelectedItem = function () {
  var self = this;
  setTimeout(function () {
    if (self.$selectlist.$selectedItem) {
      var fistChildBound = self.$selectlist.childNodes[1].getBoundingClientRect();
      var lastChildBound = self.$selectlist.lastChild.getBoundingClientRect();
      var listBound = {
        top: fistChildBound.top,
        height: lastChildBound.bottom - fistChildBound.top,
        bottom: lastChildBound.bottom
      };
      var itemBound = self.$selectlist.$selectedItem.getBoundingClientRect();

      if (self.isDropdowUp) {
        var scrollBound = self.$vscroller.getBoundingClientRect();
        self.$vscroller.scrollTop = Math.max(itemBound.bottom - scrollBound.height - listBound.top, 0);
      } else {
        self.$vscroller.scrollTop = itemBound.top - listBound.top;
      }
    }
  }.bind(this), 3);
};

SelectMenu.prototype.startTrackScroll = function () {
  var trackElt = this.parentElement;

  while (trackElt) {
    if (trackElt.addEventListener) {
      trackElt.addEventListener('scroll', this.eventHandler.scrollParent, false);
    } else {
      trackElt.attachEvent('onscroll', this.eventHandler.scrollParent, false);
    }

    this.$scrollTrackElts.push(trackElt);
    trackElt = trackElt.parentElement;
  }

  if (document.addEventListener) {
    document.addEventListener('scroll', this.eventHandler.scrollParent, false);
    document.addEventListener('wheel', this.eventHandler.wheelDocument, true);
  } else {
    document.attachEvent('onscroll', this.eventHandler.scrollParent, false);
  }

  this.$scrollTrackElts.push(document);
};

SelectMenu.prototype.stopTrackScroll = function () {
  var trackElt;

  for (var i = 0; i < this.$scrollTrackElts.length; ++i) {
    trackElt = this.$scrollTrackElts[i];

    if (trackElt.removeEventListener) {
      trackElt.removeEventListener('scroll', this.eventHandler.scrollParent, false);
    } else {
      trackElt.dettachEvent('onscroll', this.eventHandler.scrollParent, false);
    }
  }

  this.$scrollTrackElts = [];
};

SelectMenu.prototype.startListenRemovable = function () {
  var removableElt = this.parentElement;

  while (removableElt) {
    if (removableElt.isSupportedEvent && removableElt.isSupportedEvent('remove')) {
      removableElt.on('remove', this.eventHandler.removeParent);
    }

    removableElt = removableElt.parentElement;
  }
};

SelectMenu.prototype.stopListenRemovable = function () {
  var removableElt;

  while (this.$removableTrackElts.length > 0) {
    removableElt = this.$removableTrackElts.pop();
    removableElt.off('remove', this.eventHandler.removeParent);
  }
};

SelectMenu.prototype._releaseResource = function () {
  this.$selectlist.items = [];
};

SelectMenu.prototype._requestResource = function () {
  this.$selectlist.items = this._items || [];
};

SelectMenu.property.isFocus = {
  set: function (value) {
    var self = this;
    value = !!value;
    if (value == this.isFocus) return;
    this._isFocus = value;

    if (value) {
      this.startTrackScroll();
      this.selectListScrollToken = null; //force scroll

      var isAttached = false;
      setTimeout(function () {
        if (isAttached) return;
        $('body').on('mousedown', self.eventHandler.bodyClick);
        isAttached = true;
      }, 1000);
      $('body').once('click', function () {
        setTimeout(function () {
          if (isAttached) return;
          $('body').on('mousedown', self.eventHandler.bodyClick);
          isAttached = true;
        }, 10);
      });

      if (this.enableSearch) {
        setTimeout(function () {
          self.$searchTextInput.focus();
        }, 50);
      }

      this.updateDropdownPostion();
      this.scrollToSelectedItem();
      this.$anchor.removeClass('absol-disabled');
    } else {
      this.$anchor.addClass('absol-disabled');
      this.stopTrackScroll();
      $('body').off('mousedown', this.eventHandler.bodyClick);
      setTimeout(function () {
        if (self.$searchTextInput.value != 0) {
          self.$searchTextInput.value = '';
          self.$selectlist.items = self.items;
          self._resourceReady = true;
          self.$selectlist.removeClass('as-searching');
        }
      }, 100);
      this.updateItem();
    }
  },
  get: function () {
    return !!this._isFocus;
  }
};
SelectMenu.property.disabled = {
  set: function (value) {
    if (value) {
      this.addClass('disabled');
    } else {
      this.removeClass('disabled');
    }
  },
  get: function () {
    return this.containsClass('disabled');
  }
};
SelectMenu.property.hidden = {
  set: function (value) {
    if (value) {
      this.addClass('hidden');
    } else {
      this.removeClass('hidden');
    }
  },
  get: function () {
    return this.addClass('hidden');
  }
};
SelectMenu.property.selectedIndex = {
  get: function () {
    if (!this._itemIdxByValue) {
      this._itemIdxByValue = {};

      for (var i = 0; i < this._items.length; ++i) {
        this._itemIdxByValue[this._items[i].value] = i;
      }
    }

    var idx = this._itemIdxByValue[this._value];
    return idx >= 0 ? idx : -1;
  }
};
/**
 * @type {SelectMenu}
 */

SelectMenu.eventHandler = {};

SelectMenu.eventHandler.attached = function () {
  if (this._updateInterval) return;
  if (!this.$anchor.parentNode) this.$anchor.addTo(this.$anchorCtn);
  this.$attachhook.updateSize = this.$attachhook.updateSize || this.updateDropdownPostion.bind(this);

  _Dom.default.addToResizeSystem(this.$attachhook);

  this.stopListenRemovable();
  this.startListenRemovable();

  if (!this._resourceReady) {
    this._requestResource();

    this._resourceReady = true;
  }

  this._updateInterval = setInterval(function () {
    if (!this.isDescendantOf(document.body)) {
      clearInterval(this._updateInterval);
      this._updateInterval = undefined;
      this.$anchor.selfRemove();
      this.stopTrackScroll();
      this.stopListenRemovable();
      this.eventHandler.removeParent();
    }
  }.bind(this), 10000);
};

SelectMenu.eventHandler.scrollParent = function (event) {
  var self = this;

  if (this._scrollFrameout > 0) {
    this._scrollFrameout = 10;
    return;
  }

  this._scrollFrameout = this._scrollFrameout || 10;

  function update() {
    self.updateDropdownPostion(false);
    self.scrollToSelectedItem();
    self._scrollFrameout--;
    if (self._scrollFrameout > 0) requestAnimationFrame(update);
  }

  update();
};

SelectMenu.eventHandler.removeParent = function (event) {
  this._releaseResource();

  this._resourceReady = false;
};

SelectMenu.eventHandler.click = function (event) {
  if (_EventEmitter.default.isMouseRight(event)) return;
  this.isFocus = !this.isFocus;
};

SelectMenu.eventHandler.bodyClick = function (event) {
  if (!_EventEmitter.default.hitElement(this, event) && !_EventEmitter.default.hitElement(this.$anchor, event)) {
    setTimeout(function () {
      this.isFocus = false;
    }.bind(this), 5);
  }
};

SelectMenu.eventHandler.selectlistPressItem = function (event) {
  this.updateItem();

  if (this._lastValue != this.value) {
    event.lastValue = this._lastValue;
    event.value = this.value;
    setTimeout(function () {
      this.emit('change', event, this);
    }.bind(this), 1);
    this._lastValue = this.value;
  }
};

SelectMenu.eventHandler.searchModify = function (event) {
  var filterText = this.$searchTextInput.value.replace(/((\&nbsp)|(\s))+/g, ' ').trim();

  if (filterText.length == 0) {
    this._resourceReady = true;
    this.$selectlist.items = this.items;
    this.scrollToSelectedItem();
    this.$selectlist.removeClass('as-searching');
  } else {
    this.$selectlist.addClass('as-searching');
    var view = [];

    if (!this._searchCache[filterText]) {
      if (this._items.length > 0 && !this._items[0].__nvnText__) {
        (0, _search.prepareSearchForList)(this._items);
      }

      view = (0, _search.searchListByText)(filterText, this._items);
      this._searchCache[filterText] = view;
    } else {
      view = this._searchCache[filterText];
    }

    this.$selectlist.items = view;
    this._resourceReady = true;
    this.$vscroller.scrollTop = 0;
  }

  this.selectListBound = this.$selectlist.getBoundingClientRect();
  this.updateDropdownPostion(true);
};

SelectMenu.eventHandler.listSizeChangeAsync = function () {
  this.updateDropdownPostion();
};

SelectMenu.eventHandler.listValueVisibility = function (event) {
  if (!this.isFocus) return;
  if (this._selectListScrollSession == event.session) return;
  this._selectListScrollSession = event.session;
  this.scrollToSelectedItem();
};

_ACore.default.install(SelectMenu);

var _default = SelectMenu;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TextArea2.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TextArea2.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/textarea2.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _SelectMenu = _interopRequireDefault(require("./SelectMenu"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function TextArea2() {
  this.on('keydown', this.eventHandler.keydown);
  this.on('paste', this.eventHandler.paste);
  this.on('cut', this.eventHandler.paste);
}

TextArea2.tag = 'TextArea2'.toLowerCase();

TextArea2.render = function () {
  return _('textarea.absol-textarea2');
};

TextArea2.getRenderPre = function () {
  if (!TextArea2.$preSpace) {
    TextArea2.$preSpace = _('textarea').addStyle({
      'overflow': 'hidden',
      'height': '12px',
      'resize': 'none'
    }).addTo(_SelectMenu.default.getRenderSpace());
  }

  return TextArea2.$preSpace;
};

TextArea2.eventHandler = {};

TextArea2.eventHandler.keydown = function (event) {
  if (event.altKey || event.ctrlKey) return;
  var key = event.key;
  var selectPost = this.getInputSelection();
  var leftText = this.value.substring(0, selectPost.start);
  var rightText = this.value.substring(selectPost.end);
  var middText = '';

  if (key == 'Enter') {
    middText = '\n';
  } else if (key == 'Backspace') {
    if (leftText.length > 0) {
      leftText = leftText.substring(0, leftText.length - 1);
    }
  } else if (key == 'Delete') {
    if (selectPost.start < selectPost.end) {
      middText = '';
    } else if (rightText.length > 0) {
      rightText = rightText.substring(1);
    }
  } else if (key.length == 1) {
    //char
    middText = key;
  } else {
    return;
  }

  var newText = leftText + middText + rightText;

  var heightSyle = this._measureHeight(newText);

  this.addStyle('height', heightSyle);
};

TextArea2.eventHandler.paste = function (event) {
  // var text  = 
  var cl = event.clipboardData || window.clipboardData;
  var middText = cl.getData('Text') || '';
  var selectPost = this.getInputSelection();
  var leftText = this.value.substring(0, selectPost.start);
  var rightText = this.value.substring(selectPost.end);
  var newText = leftText + middText + rightText;

  var heightSyle = this._measureHeight(newText);

  this.addStyle('height', heightSyle);
};

TextArea2.eventHandler.cut = function (event) {
  // var text  = 
  var cl = event.clipboardData || window.clipboardData;
  var selectPost = this.getInputSelection();
  var leftText = this.value.substring(0, selectPost.start);
  var rightText = this.value.substring(selectPost.end);
  var newText = leftText + rightText;

  var heightSyle = this._measureHeight(newText);

  this.addStyle('height', heightSyle);
};

TextArea2.prototype._measureHeight = function (text) {
  var pre = TextArea2.getRenderPre();
  pre.addStyle('padding-left', this.getComputedStyleValue('padding-left'));
  pre.addStyle('padding-right', this.getComputedStyleValue('padding-right'));
  pre.addStyle('padding-top', this.getComputedStyleValue('padding-top'));
  pre.addStyle('padding-bottom', this.getComputedStyleValue('padding-bottom'));
  pre.addStyle('width', this.getComputedStyleValue('width'));
  pre.addStyle('height', this.getFontSize() + 'px');
  pre.addStyle('boder', this.getComputedStyleValue('boder'));
  pre.addStyle('font-size', this.getComputedStyleValue('font-size'));
  pre.addStyle('font-family', this.getComputedStyleValue('font-family'));
  pre.value = text;
  var result = pre.scrollHeight + 'px';
  return result;
};
/**
 * Return an object with the selection range or cursor position (if both have the same value)
 * @param {DOMElement} el A dom element of a textarea or input text.
 * @return {Object} reference Object with 2 properties (start and end) with the identifier of the location of the cursor and selected text.
 **/


TextArea2.prototype.getInputSelection = function () {
  var start = 0,
      end = 0,
      normalizedValue,
      range,
      textInputRange,
      len,
      endRange;

  if (typeof this.selectionStart == "number" && typeof this.selectionEnd == "number") {
    start = this.selectionStart;
    end = this.selectionEnd;
  } else {
    range = document.selection.createRange();

    if (range && range.parentElement() == this) {
      len = this.value.length;
      normalizedValue = this.value.replace(/\r\n/g, "\n"); // Create a working TextRange that lives only in the input

      textInputRange = this.createTextRange();
      textInputRange.moveToBookmark(range.getBookmark()); // Check if the start and end of the selection are at the very end
      // of the input, since moveStart/moveEnd doesn't return what we want
      // in those cases

      endRange = this.createTextRange();
      endRange.collapse(false);

      if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1) {
        start = end = len;
      } else {
        start = -textInputRange.moveStart("character", -len);
        start += normalizedValue.slice(0, start).split("\n").length - 1;

        if (textInputRange.compareEndPoints("EndToEnd", endRange) > -1) {
          end = len;
        } else {
          end = -textInputRange.moveEnd("character", -len);
          end += normalizedValue.slice(0, end).split("\n").length - 1;
        }
      }
    }
  }

  return {
    start: start,
    end: end
  };
};

_ACore.default.install(TextArea2);

var _default = TextArea2;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TextClipboard.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TextClipboard.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/textclipboard.css");

var _ACore = _interopRequireDefault(require("../ACore"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function TextClipboard() {
  this.$textarea = _('<textarea class="absol-text-clipboard" wrap="off" autocorrect="off"' + ' autocapitalize="off" spellcheck="false"></textarea>').addTo(this);
}

TextClipboard.tag = 'TextClipboard'.toLowerCase();

TextClipboard.render = function () {
  return _({
    style: {
      positon: 'fixed',
      opacity: 0,
      width: '1px',
      height: '1px',
      top: 0,
      left: 0
    }
  });
};

TextClipboard.prototype.copy = function (text) {
  this.$textarea.value = text;
  this.$textarea.select();
  document.execCommand('copy');
};

TextClipboard.prototype.paste = function () {
  this.$textarea.select();
  document.execCommand('paste');
};

_ACore.default.install(TextClipboard);

var _default = TextClipboard;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TimeInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TimeInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/timeinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _datetime = require("absol/src/Time/datetime");

var _ChromeTimePicker = _interopRequireDefault(require("./ChromeTimePicker"));

var _DomSignal = _interopRequireDefault(require("absol/src/HTML5/DomSignal"));

var _DateTimeInput = _interopRequireDefault(require("./DateTimeInput"));

var _utils = require("./utils");

var _EventEmitter = require("absol/src/HTML5/EventEmitter");


var STATE_NEW = 1;
var STATE_EDITED = 2;
var STATE_NONE = 0;
var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends {AElement}
 * @constructor
 */

function TimeInput() {
  this._editingData = {};
  this._isOpenPicker = false;
  this._lastEmitValue = null;
  this._hour = null;
  this._minute = null;
  this._format = 'hh:mm a';
  this.$clockBtn = $('.as-time-input-icon-btn', this).on('click', this.eventHandler.clickClockBtn);
  this.$text = $('input', this).on('mousedown', this.eventHandler.mouseDownInput).on('mouseup', this.eventHandler.mouseUpInput).on('dblclick', this.eventHandler.dblclickInput).on('keydown', this.eventHandler.keydown).on('blur', this.eventHandler.inputBlur).on('contextmenu', function (event) {
    event.preventDefault();
  });
  this.$clearBtn = $('button.as-time-input-clear-btn', this).on('click', this.clear.bind(this));
  this.$domSignal = _('attachhook').addTo(this);
  this.domSignal = new _DomSignal.default(this.$domSignal);
  this.domSignal.on('request_auto_select', this._autoSelect.bind(this));
  this.dayOffset = null;
  this.hour = null;
  this.minute = null;
  this.disabled = false;
  this.notNull = true;
}

TimeInput.tag = 'timeinput';

TimeInput.render = function () {
  return _({
    class: 'ac-time-input',
    extendEvent: ['change'],
    child: [{
      tag: 'input',
      class: 'as-time-input-text',
      attr: {
        type: 'text'
      }
    }, {
      tag: 'button',
      class: 'as-time-input-clear-btn',
      child: 'span.mdi.mdi-close-circle'
    }, {
      tag: 'button',
      class: 'as-time-input-icon-btn',
      child: 'span.mdi.mdi-clock-outline'
    }]
  });
};

TimeInput.prototype._autoSelect = _DateTimeInput.default.prototype._autoSelect;
TimeInput.prototype.tokenMap = {
  h: 'h',
  H: 'H',
  HH: 'H',
  hh: 'h',
  m: 'm',
  mm: 'm',
  a: 'a'
};
TimeInput.prototype.tokenRegex = _DateTimeInput.default.prototype.tokenRegex;
TimeInput.prototype._tokenAt = _DateTimeInput.default.prototype._tokenAt;
TimeInput.prototype._editNextToken = _DateTimeInput.default.prototype._editNextToken;
TimeInput.prototype._editPrevToken = _DateTimeInput.default.prototype._editPrevToken;
TimeInput.prototype._makeTokenDict = _DateTimeInput.default.prototype._makeTokenDict;

TimeInput.prototype._makeValueDict = function (hour, minute) {
  var res = {};

  if (typeof hour == 'number' && hour >= 0 && hour < 24) {
    res.h = {
      value: 1 + (hour - 1) % 12
    };
    res.H = {
      value: hour
    };
    res.a = {
      value: hour >= 12 ? 'PM' : 'AM'
    };
  } else {
    res.h = {
      value: NaN
    };
    res.H = {
      value: NaN
    };
    res.a = {
      value: 'a'
    };
  }

  if (typeof minute === "number" && minute >= 0 && minute < 60) {
    res.m = {
      value: minute
    };
  } else {
    res.m = {
      value: NaN
    };
  }

  return res;
};

TimeInput.prototype._applyValue = function (hour, minute) {
  this._hour = hour;
  this._minute = minute;
  this.$text.value = this._applyTokenDict(this._format, this._makeValueDict(hour, minute));

  this._updateNullClass();
};

TimeInput.prototype._updateNullClass = function () {
  if (this._hour == null && this._minute == null) {
    this.addClass('as-value-null');
  } else {
    this.removeClass('as-value-null');
  }
};

TimeInput.prototype._applyTokenDict = function (format, dict) {
  var rgx = new RegExp(this.tokenRegex.source, 'g');
  var tokenMap = this.tokenMap;
  return format.replace(rgx, function (full, g1, g2, sourceText) {
    if (g1 && g1 === 'a') {
      return dict[g1].value;
    } else if (g1 && tokenMap[g1]) {
      var ident = tokenMap[g1];

      if (dict[ident] && !isNaN(dict[ident].value)) {
        return (0, _utils.zeroPadding)(dict[ident].value, g1.length);
      } else {
        return full;
      }
    } else return full;
  });
};

TimeInput.prototype._correctingInput = function () {
  var tkDict = this._makeTokenDict(this.$text.value); // TODO: check min, max,

};

TimeInput.prototype._correctingCurrentToken = function () {
  var token = this._tokenAt(this.$text.selectionStart);

  if (!token) return;
  var value;

  if (token.ident === 'a') {
    if (token.text !== 'a' && token.text !== 'AM' && token.text !== 'PM') {
      token.replace('a', false);
    }
  } else {
    value = parseInt(token.text);
    var rqMin = {
      h: 1,
      hh: 1,
      m: 0,
      mm: 0,
      H: 0,
      HH: 0
    }[token.ident];
    var rqMax = {
      H: 23,
      HH: 23,
      h: 12,
      hh: 12,
      m: 59,
      mm: 59
    }[token.ident];

    if (rqMin !== undefined) {
      if (!isNaN(value)) {
        if (value < rqMin || value > rqMin) {
          value = Math.max(rqMin, Math.min(rqMax, value));
          token.replace((0, _utils.zeroPadding)(value, token.ident.length), false);
          this._editingData[this.tokenMap[token.ident]] = value;
        }
      } else if (token.text !== token.ident) {
        token.replace(token.ident, false);
      }
    }
  }
};

TimeInput.prototype._loadValueFromInput = function () {
  var tkDick = this._makeTokenDict(this.$text.value);

  var hour = NaN;
  var minute = NaN;

  if (tkDick.H) {
    hour = Math.min(23, Math.max(0, tkDick.H.value));
  } else if (tkDick.h) {
    hour = Math.min(12, Math.max(1, tkDick.h.value));

    if (tkDick.a && tkDick.a.value === 'PM') {
      hour += 12;
    }
  }

  if (tkDick.m) {
    minute = Math.min(59, Math.max(0, tkDick.m.value));
  }

  this._hour = isNaN(hour) ? null : hour;
  this._minute = isNaN(minute) ? null : minute;

  this._updateNullClass();
};

TimeInput.prototype.clear = function (event) {
  this._applyValue(null, null);

  this._notifyIfChange(event);
};

TimeInput.prototype._notifyIfChange = function (event) {
  if (this._lastEmitValue === this.dayOffset) return;
  this.emit('change', {
    type: 'change',
    target: this,
    dayOffset: this.dayOffset,
    hour: this.hour,
    minute: this.minute,
    originEvent: event
  }, this);
  this._lastEmitValue = this.dayOffset;
};

TimeInput.property = {};
TimeInput.property.hour = {
  set: function (value) {
    if (typeof value == "number") {
      value = value % 24 || 0;
    } else {
      value = null;
    }

    this._applyValue(value, this._minute);

    this._lastEmitValue = this.dayOffset;
  },
  get: function () {
    return this._hour;
  }
};
TimeInput.property.minute = {
  set: function (value) {
    if (typeof value == "number") {
      value = value % 60 || 0;
    } else {
      value = null;
    }

    this._applyValue(this._hour, value);

    this._lastEmitValue = this.dayOffset;
  },
  get: function () {
    return this._minute;
  }
};
TimeInput.property.dayOffset = {
  set: function (value) {
    if (typeof value == "number" || value && value.getTime) {
      value = value || 0;
      if (value.getTime) value = value.getTime() - (0, _datetime.beginOfDay)(value).getTime();else {
        value = value % _datetime.MILLIS_PER_DAY;
      }
      this.hour = Math.floor(value / _datetime.MILLIS_PER_HOUR);
      this.minute = Math.floor(value % _datetime.MILLIS_PER_HOUR / _datetime.MILLIS_PER_MINUTE);
    } else {
      this.hour = null;
      this.minute = null;
    }
  },
  get: function () {
    if (this._hour === null || this._minute === null) return null;
    return this._hour * _datetime.MILLIS_PER_HOUR + this._minute * _datetime.MILLIS_PER_MINUTE;
  }
};
TimeInput.property.disabled = {
  set: function (value) {
    value = !!value;
    this._disabled = value;
    if (value) this.addClass('as-disabled');else this.removeClass('as-disabled');
    this.$text.disabled = value;
  },
  get: function () {
    return this._disabled;
  }
};
TimeInput.property.format = {
  enumerable: true,
  configurable: true,
  set: function (value) {
    if (typeof value !== "string") value = "hh:mm a";
    value = value || 'hh:mm a';
    this._format = value;
    this.dayOffset = this['dayOffset'];
  },
  get: function () {
    return this._format;
  }
};
TimeInput.property.s24 = {
  get: function () {
    var t = this.format.match(new RegExp(this.tokenRegex.source, 'g'));
    return !t || t.indexOf('a') < 0;
  }
};
TimeInput.property.notNull = {
  set: function (value) {
    if (value) {
      if (this.dayOffset === null) {
        this.dayOffset = 0;
      }

      this.addClass('as-must-not-null');
    } else {
      this.removeClass('as-must-not-null');
    }
  },
  get: function () {
    return this.containsClass('as-must-not-null');
  }
};
TimeInput.eventHandler = {};

TimeInput.eventHandler.clickClockBtn = function () {
  this._attachPicker(this);
};

TimeInput.eventHandler.mouseUpInput = _DateTimeInput.default.eventHandler.mouseUpInput;
TimeInput.eventHandler.mouseDownInput = _DateTimeInput.default.eventHandler.mouseDownInput;
TimeInput.eventHandler.dblclickInput = _DateTimeInput.default.eventHandler.dblclickInput;
TimeInput.eventHandler.inputBlur = _DateTimeInput.default.eventHandler.inputBlur;

TimeInput.eventHandler.clickOut = function (event) {
  if ((0, _EventEmitter.hitElement)(this.share.$picker, event)) return;

  this._releasePicker();
};

TimeInput.eventHandler.pickerChange = function (event) {
  this._applyValue(event.hour, event.minute);

  this._notifyIfChange(event);
};
/***
 *
 * @param {KeyboardEvent} event
 */


TimeInput.eventHandler.keydown = function (event) {
  var token = this._tokenAt(this.$text.selectionStart);

  var endToken = this._tokenAt(this.$text.selectionEnd);

  if (!token) {
    if (event.key === 'Enter') {
      this._correctingInput();

      this._loadValueFromInput();

      this._notifyIfChange(event);
    }

    return;
  }

  var newTokenText;
  var value;

  if (event.key.startsWith('Arrow')) {
    event.preventDefault();

    switch (event.key) {
      case 'ArrowLeft':
        this._editPrevToken();

        break;

      case 'ArrowRight':
        this._editNextToken();

        break;

      case 'ArrowUp':
      case 'ArrowDown':
        switch (token.ident) {
          case "H":
          case "HH":
            value = parseInt(token.text);

            if (isNaN(value)) {
              this._editingData.H = event.key === 'ArrowUp' ? 0 : 23;
            } else {
              this._editingData.H = (value + (event.key === 'ArrowUp' ? 1 : 23)) % 24;
            }

            newTokenText = (0, _utils.zeroPadding)(this._editingData.H, token.ident.length);
            token.replace(newTokenText, true);
            break;

          case "hh":
          case 'h':
            value = parseInt(token.text);

            if (isNaN(value)) {
              this._editingData.h = event.key === 'ArrowUp' ? 1 : 12;
            } else {
              this._editingData.h = 1 + (value + (event.key === 'ArrowUp' ? 0 : 10)) % 12;
            }

            newTokenText = this._editingData.h + '';

            while (newTokenText.length < token.ident.length) newTokenText = '0' + newTokenText;

            token.replace(newTokenText, true);
            break;

          case "mm":
          case 'm':
            value = parseInt(token.text);

            if (isNaN(value)) {
              this._editingData.m = event.key === 'ArrowUp' ? 0 : 59;
            } else {
              this._editingData.m = (value + (event.key === 'ArrowUp' ? 1 : 59)) % 60;
            }

            newTokenText = this._editingData.m + '';

            while (newTokenText.length < token.ident.length) newTokenText = '0' + newTokenText;

            token.replace(newTokenText, true);
            break;

          case 'a':
            value = token.text;
            this._editingData.a = value === 'PM' ? "AM" : "PM";
            newTokenText = this._editingData.a;
            token.replace(newTokenText, true);
            break;
        }

        break;
    }
  } else if (event.key === "Delete" || event.key === 'Backspace') {
    event.preventDefault();

    if (endToken.idx !== token.idx) {
      if (this.notNull) {
        this.$text.value = (0, _datetime.formatDateTime)((0, _datetime.beginOfDay)(new Date()), this.format);
      } else {
        this.$text.value = this._format;
      }

      this.$text.select();
    } else {
      if (this.notNull) {
        token.replace(token.ident === 'a' ? 'AM' : (0, _utils.zeroPadding)(token.ident === 'hh' || token.ident === 'h' ? 12 : 0, token.ident.length), true);
      } else {
        token.replace(token.ident, true);
      }

      if (event.key === "Delete") this._editNextToken();else this._editPrevToken();
    }
  } else if (event.key === "Enter" || event.key === 'Tab') {
    this._correctingInput();

    this._loadValueFromInput();

    this._notifyIfChange(event);
  } else if (event.ctrlKey) {
    switch (event.key) {
      case 'a':
      case 'A':
        break;

      case 'c':
      case 'C':
        break;

      case 'x':
      case 'X':
        this.domSignal.once('clear_value', function () {
          this.$text.value = this._format;
          this.$text.select();
        }.bind(this));
        this.domSignal.emit('clear_value');
        break;

      default:
        event.preventDefault();
    }
  } else if (event.key.match(/^[0-9]$/g)) {
    event.preventDefault();
    var dVal = parseInt(event.key);

    if (this._editingData.state === STATE_NEW) {
      switch (token.ident) {
        case 'm':
        case 'mm':
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          this._editingData.state = STATE_EDITED;

          if (dVal > 5) {
            this._editNextToken();
          }

          break;

        case 'h':
        case 'hh':
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          this._editingData.state = STATE_EDITED;

          if (dVal > 1) {
            this._editNextToken();
          }

          break;

        case 'H':
        case 'HH':
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);
          this._editingData.state = STATE_EDITED;

          if (dVal > 2) {
            this._editNextToken();
          }

          break;
      }
    } else {
      switch (token.ident) {
        case 'm':
        case 'mm':
          dVal = (parseInt(token.text.split('').pop()) || 0) * 10 + dVal;
          dVal = Math.max(0, Math.min(59, dVal));
          this._editingData.m = dVal;
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);

          this._editNextToken();

          break;

        case 'h':
        case 'hh':
          dVal = (parseInt(token.text.split('').pop()) || 0) * 10 + dVal;
          dVal = Math.max(1, Math.min(12, dVal));
          this._editingData.h = dVal;
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);

          this._editNextToken();

          break;

        case 'H':
        case 'HH':
          dVal = (parseInt(token.text.split('').pop()) || 0) * 10 + dVal;
          dVal = Math.max(0, Math.min(23, dVal));
          this._editingData.H = dVal;
          token.replace((0, _utils.zeroPadding)(dVal, token.ident.length), true);

          this._editNextToken();

          break;
      }
    }
  } else if (event.key.match(/^[aApPSCsc]$/) && token.ident === 'a') {
    event.preventDefault();

    if (event.key.match(/^[aAsS]$/)) {
      token.replace('AM', true);
      this._editingData.a = "AM";
    } else {
      token.replace('PM', true);
      this._editingData.a = "PM";
    }

    this._editNextToken();
  } else {
    event.preventDefault();
  }
};

TimeInput.prototype.share = {
  $picker: null,
  $holdingInput: null,
  $follower: null
};

TimeInput.prototype._preparePicker = function () {
  if (this.share.$picker) return;
  this.share.$picker = _({
    tag: _ChromeTimePicker.default.tag,
    class: 'as-time-input-picker'
  });
  this.share.$follower = _({
    tag: 'follower',
    class: 'as-time-input-follower',
    child: this.share.$picker
  });
};

TimeInput.prototype._attachPicker = function () {
  this._preparePicker();

  if (this.share.$holdingInput) this.share.$holdingInput._releasePicker();
  this.share.$holdingInput = this;
  this.share.$follower.addTo(document.body);
  this.share.$follower.followTarget = this;
  this.share.$follower.addStyle('visibility', 'hidden');
  this.share.$picker.hour = this.hour || 0;
  this.share.$picker.minute = this.minute || 0;
  this.share.$picker.s24 = this.s24;
  this.share.$picker.domSignal.emit('request_scroll_into_selected');
  this.$clockBtn.off('click', this.eventHandler.clickClockBtn);
  this.share.$picker.on('change', this.eventHandler.pickerChange);
  setTimeout(function () {
    document.body.addEventListener('click', this.eventHandler.clickOut);
    this.share.$follower.removeStyle('visibility');
  }.bind(this), 5);
};

TimeInput.prototype._releasePicker = function () {
  if (this.share.$holdingInput !== this) return; // this.share.$calendar.off('pick', this.eventHandler.calendarPick);

  this.share.$follower.remove();
  document.body.removeEventListener('click', this.eventHandler.clickOut);
  this.share.$picker.off('change', this.eventHandler.pickerChange);
  setTimeout(function () {
    this.$clockBtn.on('click', this.eventHandler.clickClockBtn);
  }.bind(this), 5);
  this.share.$holdingInput = null;
};

_ACore.default.install(TimeInput);

var _default = TimeInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TimePicker.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TimePicker.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.isTouchDevice = void 0;

require("../css/timepicker.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Svg = _interopRequireDefault(require("absol/src/HTML5/Svg"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _datetime = require("absol/src/Time/datetime");

var _BrowserDetector = _interopRequireDefault(require("absol/src/Detector/BrowserDetector"));

var _NumberSpanInput = _interopRequireDefault(require("./NumberSpanInput"));


//todo: add this to absol
var isTouchDevice = _BrowserDetector.default.hasTouch && !_BrowserDetector.default.os.type.match(/windows|X11|Ubuntu|Linux/); //todo: re select text after click

exports.isTouchDevice = isTouchDevice;
var _ = _ACore.default._;
var $ = _ACore.default.$;
var $g = _Svg.default.ShareInstance.$;
var _g = _Svg.default.ShareInstance._;

function TimePicker() {
  this._hour = 0;
  this._minute = 0;
  this._lastDayOffset = 0;
  this._state = 'none';
  this._mode = 'CLOCK';
  this._latBound = {
    width: 0,
    height: 0
  };
  var thisPicker = this;
  if (isTouchDevice) this.addClass('ac-time-picker-touch');
  this.$attachook = _('attachhook').addTo(this).on('error', function () {
    _Dom.default.addToResizeSystem(this);

    this.requestUpdateSize();
    thisPicker.addStyle('font-size', thisPicker.getComputedStyleValue('font-size'));
  });
  this.$attachook.requestUpdateSize = this.updateSize.bind(this);
  /***
   *
   * @type {NumberSpanInput}
   */

  this.$hour = $('.ac-time-picker-hour', this).on({
    focus: this.eventHandler.focusHour,
    keydown: this.eventHandler.keydownHour,
    blur: this.eventHandler.blurHour
  });
  /***
   *
   * @type {NumberSpanInput}
   */

  this.$minute = $('.ac-time-picker-minute', this).on({
    keydown: this.eventHandler.keydownMinute,
    focus: this.eventHandler.focusMinute,
    blur: this.eventHandler.blurMinute
  });
  this.$hourInput = $('.ac-time-picker-hour-input', this).on({
    click: this.eventHandler.clickHourInput,
    keydown: this.eventHandler.keydownHourInput,
    blur: this.eventHandler.blurHourInput
  });
  this.$minuteInput = $('.ac-time-picker-minute-input', this).on({
    click: this.eventHandler.clickMinuteInput,
    keydown: this.eventHandler.keydownMinuteInput,
    blur: this.eventHandler.blurMinuteInput
  }); //only support if is none touch device

  if (isTouchDevice) {
    this.$hour.readOnly = true;
    this.$hour.on('click', this._editHourState.bind(this));
    this.$minute.readOnly = true;
    this.$minute.on('click', this._editMinuteState.bind(this));
  }

  this.$clock = $g('.ac-time-picker-clock', this).on(isTouchDevice ? 'touchstart' : 'mousedown', this.eventHandler.mousedownClock);
  this._clockWidth = 400;
  this._clockHeight = 400;
  this._clockRadius = 150;
  this._clockRadiusInner = 100;
  this.$clockContent = $g('.ac-time-picker-clock-content', this);
  this.$clockHourCtn = $g('.ac-time-picker-clock-hour-ctn', this);
  this.$clockMinuteCtn = $g('.ac-time-picker-clock-minute-ctn', this);
  this.$hourNumbers = Array(24).fill(0).map(function (u, i) {
    var h = i;
    if (h == 0) h = 12;else if (h == 12) h = '00';
    return _g({
      tag: 'text',
      attr: {
        'text-anchor': 'middle'
      },
      class: 'ac-time-picker-clock-hour-' + (i < 12 ? 'am' : 'pm'),
      child: {
        text: h + ''
      }
    }).addTo(thisPicker.$clockHourCtn);
  });
  this.$minuteNumbers = Array(12).fill(0).map(function (u, i) {
    return _g({
      tag: 'text',
      attr: {
        'text-anchor': 'middle'
      },
      class: 'ac-time-picker-clock-minute',
      child: {
        text: i * 5 + ''
      }
    }).addTo(thisPicker.$clockMinuteCtn);
  });
  this.$selectCtn = $g('.ac-time-picker-clock-select-ctn', this);
  this.$clockCenter = _g({
    tag: 'circle',
    class: 'ac-time-picker-clock-center',
    attr: {
      cx: "0",
      cy: '0'
    }
  }).addTo(this.$selectCtn);
  this.$clockSelectLine = _g({
    tag: 'path',
    class: 'ac-time-picker-clock-select-line'
  }).addTo(this.$selectCtn);
  this.$clockSelectCicle = _g({
    tag: 'circle',
    class: 'ac-time-picker-clock-select-circle',
    attr: {
      cx: 0,
      cy: 0
    }
  }).addTo(this.$selectCtn);
  this.$clockSelectCenter = _g({
    tag: 'circle',
    class: 'ac-time-picker-clock-select-center'
  }).addTo(this.$selectCtn);
  this.$finishBtn = $('.ac-time-picker-finish-btn', this).on('click', this.finishSelect.bind(this));
  this.$cancelBtn = $('.ac-time-picker-cancel-btn', this).on('click', this.cancelSelect.bind(this));
  this.$keyboardBtn = $('.ac-time-picker-keyboard-btn', this).on('click', this.timeMode.bind(this));
  this.$clockBtn = $('.ac-time-picker-clock-btn', this).on('click', this.clockMode.bind(this));
}

;

TimePicker.prototype.updateSize = function () {
  // var 
  this._fontSize = this.getFontSize();
  var cBound = this.$clock.getBoundingClientRect();
  this._clockWidth = cBound.width;
  this._clockHeight = cBound.height;
  this.$clock.attr({
    width: this._clockWidth,
    height: this._clockHeight,
    viewBox: '0 0 ' + this._clockWidth + ' ' + this._clockHeight
  });
  this.$clockContent.attr('transform', 'translate(' + this._clockWidth / 2 + ',' + this._clockHeight / 2 + ')');
  var clockRadius = this._clockWidth / 2 - this._fontSize;
  var clockRadiusInner = clockRadius - this._fontSize * 1.5;
  this._clockRadius = clockRadius;
  this._clockRadiusInner = clockRadiusInner;
  this.$clockCenter.attr('r', this._fontSize / 5);
  this.$clockSelectCicle.attr({
    r: this._fontSize * 0.7,
    cx: clockRadius
  });
  this.$clockSelectCenter.attr({
    r: this._fontSize / 10,
    cx: clockRadius
  });
  this.$hourNumbers.forEach(function (elt, i) {
    var angle = Math.PI * (i - 3) / 6;
    var r = i < 12 ? clockRadius : clockRadiusInner;
    var box = elt.getBBox();
    var x = r * Math.cos(angle);
    var y = r * Math.sin(angle) + box.height / 2;
    elt.attr({
      x: x,
      y: y
    });
  });
  this.$minuteNumbers.forEach(function (elt, i) {
    var angle = Math.PI * (i - 3) / 6;
    var box = elt.getBBox();
    var x = clockRadius * Math.cos(angle);
    var y = clockRadius * Math.sin(angle) + box.height / 3;
    elt.attr({
      x: x,
      y: y
    });
  });
  this.updateSelectPosition();
  this.notifySizeChange();
};

TimePicker.prototype.updateSelectPosition = function () {
  var angle, radius;

  if (this._state == "EDIT_MINUTE") {
    angle = Math.PI * (this._minute - 15) / 30;
    radius = this._clockRadius;
  } else if (this._state == "EDIT_HOUR") {
    angle = Math.PI * (this._hour - 3) / 6;

    if (this._hour > 0 && this._hour <= 12) {
      radius = this._clockRadius;
    } else {
      radius = this._clockRadiusInner;
    }
  } else {
    return;
  }

  this._drawSelect(radius, angle);
};

TimePicker.prototype.editHour = function () {
  this.clockMode();

  if (this.$hour.readOnly) {
    this._editHourState();
  } else {
    this.$hour.focus();
  }
};

TimePicker.prototype._drawSelect = function (radius, angle) {
  var x = radius * Math.cos(angle);
  var y = radius * Math.sin(angle);
  this.$clockSelectCicle.attr({
    cx: x,
    cy: y
  });
  this.$clockSelectCenter.attr({
    cx: x,
    cy: y
  });
  this.$clockSelectLine.attr('d', 'M0,0L' + x + ',' + y);
};

TimePicker.prototype.notifyChange = function (force) {
  if (this._lastDayOffset != this.dayOffset || force) {
    this.emit('change', {
      target: this,
      hour: this.hour,
      minute: this.minute,
      dayOffset: this.dayOffset,
      name: 'change'
    }, this);
    this._lastDayOffset = this.dayOffset;
  }
};

TimePicker.prototype.notifySizeChange = function () {
  var bound = this.getBoundingClientRect();

  if (this._latBound.width != bound.width || this._latBound.height != bound.height) {
    this._latBound.width = bound.width;
    this._latBound.height = bound.height;
    this.emit('sizechange', {
      name: 'sizechange',
      bound: bound,
      target: this
    }, this);
  }
};

TimePicker.tag = 'TimePicker';

TimePicker.render = function () {
  return _({
    extendEvent: ['change', 'finish', 'cancel', 'sizechange'],
    class: ['ac-time-picker', 'ac-time-picker-clock-mode'],
    //clock mode is default
    child: [{
      class: 'ac-time-picker-set-clock',
      child: [{
        class: 'ac-time-picker-set-clock-header',
        child: [{
          tag: 'numberspaninput',
          class: 'ac-time-picker-hour',
          props: {
            value: 0,
            zeroInt: 2
          }
        }, {
          tag: 'span',
          text: ':'
        }, {
          tag: 'numberspaninput',
          class: 'ac-time-picker-minute',
          props: {
            value: 0,
            zeroInt: 2
          }
        }]
      }, _g({
        tag: 'svg',
        class: 'ac-time-picker-clock',
        child: [{
          class: 'ac-time-picker-clock-content',
          child: ['.ac-time-picker-clock-select-ctn', '.ac-time-picker-clock-hour-ctn', '.ac-time-picker-clock-minute-ctn']
        }]
      })]
    }, {
      class: 'ac-time-picker-set-time',
      child: [{
        class: 'ac-time-picker-set-time-header',
        child: {
          text: 'Set time'
        }
      }, {
        class: 'ac-time-picker-set-time-label',
        child: {
          text: 'Type in time'
        }
      }, {
        class: 'ac-time-picker-set-time-input-group',
        child: [{
          class: 'ac-time-picker-set-time-input-hm',
          child: [{
            tag: 'input',
            class: 'ac-time-picker-hour-input',
            attr: {
              type: 'number',
              placeHolder: '00',
              tabindex: '2'
            }
          }, {
            tag: 'span',
            child: {
              text: ':'
            }
          }, {
            tag: 'input',
            class: 'ac-time-picker-minute-input',
            attr: {
              type: 'number',
              placeHolder: '00',
              tabindex: '3'
            }
          }]
        }, {
          class: 'ac-time-picker-set-time-input-label-hm',
          child: [{
            tag: 'span',
            child: {
              text: 'hour'
            }
          }, {
            tag: 'span',
            style: {
              visibility: 'hidden'
            },
            child: {
              text: ':'
            }
          }, {
            tag: 'span',
            child: {
              text: 'minute'
            }
          }]
        }]
      }]
    }, {
      class: 'ac-time-picker-footer',
      child: [{
        tag: 'button',
        class: 'ac-time-picker-keyboard-btn',
        child: 'span.mdi.mdi-keyboard-outline'
      }, {
        tag: 'button',
        class: 'ac-time-picker-clock-btn',
        child: 'span.mdi.mdi-clock-outline'
      }, {
        class: 'ac-time-picker-footer-right',
        child: [{
          tag: 'button',
          class: 'ac-time-picker-cancel-btn',
          attr: {
            tabindex: '4'
          },
          child: {
            text: 'CANCEL'
          }
        }, {
          tag: 'button',
          attr: {
            tabindex: '4'
          },
          class: 'ac-time-picker-finish-btn',
          child: {
            text: 'OK'
          }
        }]
      }]
    }]
  });
};

TimePicker.prototype.clockMode = function () {
  if (this._mode == "CLOCK") return;
  this._mode = 'CLOCK';
  this.removeClass('ac-time-picker-time-mode').addClass('ac-time-picker-clock-mode');
  this.$hour.value = this._hour < 10 ? '0' + this._hour : this._hour;
  this.$minute.value = this._minute < 10 ? '0' + this._minute : this._minute;

  this._editHourState();

  this.updateSize();

  this._showSelectHour(this._hour);
};

TimePicker.prototype.timeMode = function () {
  if (this._mode == "TIME") return;
  this._mode = 'TIME';
  this.addClass('ac-time-picker-time-mode').removeClass('ac-time-picker-clock-mode');
  this.$hourInput.value = this._hour < 10 ? '0' + this._hour : this._hour;
  this.$minuteInput.value = this._minute < 10 ? '0' + this._minute : this._minute;
  this.editHourInput();
  this.updateSize();
};

TimePicker.prototype._editHourState = function () {
  this._state = "EDIT_HOUR";
  this._preHour = this._hour;
  this.removeClass('ac-time-picker-edit-minute').addClass('ac-time-picker-edit-hour').removeClass('ac-time-picker-edit-hour-input').removeClass('ac-time-picker-edit-minute-input');
  this.updateSize();
};

TimePicker.prototype._editMinuteState = function () {
  this._state = "EDIT_MINUTE";
  this._preMinute = this._minute;
  this.addClass('ac-time-picker-edit-minute').removeClass('ac-time-picker-edit-hour').removeClass('ac-time-picker-edit-hour-input').removeClass('ac-time-picker-edit-minute-input');
  this.updateSize();
};

TimePicker.prototype.editHourInput = function () {
  var thisPicker = this;
  this._state = "EDIT_HOUR_INPUT";
  this._preHour = this._hour;
  this.removeClass('ac-time-picker-edit-minute').removeClass('ac-time-picker-edit-hour').addClass('ac-time-picker-edit-hour-input').removeClass('ac-time-picker-edit-minute-input');
  this.updateSize();
  setTimeout(function () {
    thisPicker.$hourInput.focus();
    thisPicker.$hourInput.select();
  }, 10);
};

TimePicker.prototype.editMinuteInput = function () {
  var thisPicker = this;
  this._state = "EDIT_MINUTE_INPUT";
  this._preMinute = this._minute;
  this.removeClass('ac-time-picker-edit-minute').removeClass('ac-time-picker-edit-hour').removeClass('ac-time-picker-edit-hour-input').addClass('ac-time-picker-edit-minute-input');
  this.updateSize();
  setTimeout(function () {
    thisPicker.$minuteInput.focus();
    thisPicker.$minuteInput.select();
  }, 1);
};

TimePicker.prototype.finishSelect = function () {
  this.emit('finish', {
    target: this,
    hour: this.hour,
    minute: this.minute,
    dayOffset: this.dayOffset,
    name: 'finish'
  }, this);
};

TimePicker.prototype.cancelSelect = function () {
  this.emit('cancel', {
    target: this,
    name: 'cancel'
  }, this);
};

TimePicker.eventHandler = {};

TimePicker.eventHandler.focusHour = function () {
  this._editHourState();

  this.$hour.selectAll();
};

TimePicker.eventHandler.blurHour = function () {
  var newText = this.$hour.value;
  var hour = parseFloat(newText) || 0;
  if (hour < 0 || hour >= 24) hour = this._preHour;
  this.$hour.value = hour < 10 ? '0' + hour : hour;
  this._hour = hour;

  this._showSelectHour(hour);

  this.notifyChange();
};

TimePicker.eventHandler.focusMinute = function () {
  this._editMinuteState();

  this.$minute.selectAll();
};

TimePicker.eventHandler.blurMinute = function () {
  var newText = this.$minute.innerHTML;
  var minute = parseFloat(newText) || 0;
  if (minute < 0 || minute >= 60) minute = this._preMinute;
  this.$minute.value = minute < 10 ? '0' + minute : minute;
  this._minute = minute;

  this._showSelectByMinuteText();

  this.notifyChange();
};

TimePicker.eventHandler.clickHourInput = function () {
  if (this._state != 'EDIT_HOUR') this.editHourInput();else {
    this.$hourInput.focus();
    this.$hourInput.select();
  }
};

TimePicker.eventHandler.clickMinuteInput = function () {
  if (this._state != 'EDIT_MINUTE_INPUT') this.editMinuteInput();else {
    this.$minuteInput.focus();
    this.$minuteInput.select();
  }
};

TimePicker.eventHandler.blurHourInput = function () {
  var hour = parseFloat(this.$hourInput.value) || 0;
  if (hour < 0 || hour >= 24) hour = this._preHour;
  this.hour = hour;
};

TimePicker.eventHandler.blurMinuteInput = function () {
  var minute = parseFloat(this.$minuteInput.value) || 0;
  if (minute < 0 || minute >= 60) minute = this._preMinute;
  this.minute = minute;
};

TimePicker.property = {};
TimePicker.property.hour = {
  set: function (value) {
    value = value % 24 || 0;
    this._hour = value;
    var text = (value < 10 ? '0' : '') + value + '';
    this.$hour.clearChild().addChild(_({
      text: text
    }));
    this.$hourInput.value = text;
    this.updateSelectPosition();
  },
  get: function () {
    return this._hour;
  }
};
TimePicker.property.minute = {
  set: function (value) {
    value = value % 60 || 0;
    this._minute = value;
    var text = (value < 10 ? '0' : '') + value + '';
    this.$minute.value = text;
    this.$minuteInput.value = text;
    this.updateSelectPosition();
  },
  get: function () {
    return this._minute;
  }
};
TimePicker.property.dayOffset = {
  set: function (value) {
    value = value || 0;
    if (value.getTime) value = value.getTime() - (0, _datetime.beginOfDay)(value).getTime();else {
      value = value % _datetime.MILLIS_PER_DAY;
    }
    this.hour = Math.floor(value / _datetime.MILLIS_PER_HOUR);
    this.minute = Math.floor(value % _datetime.MILLIS_PER_HOUR / _datetime.MILLIS_PER_MINUTE);
  },
  get: function () {
    return this._hour * _datetime.MILLIS_PER_HOUR + this._minute * _datetime.MILLIS_PER_MINUTE;
  }
};

TimePicker.prototype._showSelectHour = function (hour) {
  var radius;
  var angle = Math.PI * (hour - 3) / 6;

  if (hour < 24 && hour > 12 || hour == 0) {
    radius = this._clockRadiusInner;
  } else if (hour <= 12) {
    radius = this._clockRadius;
  } else {
    return;
  }

  this._drawSelect(radius, angle);
};

TimePicker.prototype._showSelectByHourText = function () {
  var hour = parseFloat(this.$hour.innerHTML) || 0;
  if (hour < 0 || hour >= 24) return;

  this._showSelectHour(hour);
};

TimePicker.prototype._showSelectMinute = function (minute) {
  var angle = Math.PI * (minute - 15) / 30;

  this._drawSelect(this._clockRadius, angle);
};

TimePicker.prototype._showSelectByMinuteText = function () {
  var minute = parseFloat(this.$minute.innerHTML) || 0;
  if (minute < 0 || minute >= 60) return;

  this._showSelectMinute(minute);
};
/***
 *
 * @param {KeyboardEvent} event
 */


TimePicker.eventHandler.keydownHour = function (event) {
  var thisPicker = this;

  if (event.key == 'Enter' || event.key == 'Tab') {
    event.preventDefault();
    this.$hour.blur();

    this._editMinuteState();

    setTimeout(function () {
      thisPicker.$minute.focus();
      thisPicker.$minute.selectAll();
    }, 30);
  } else {
    setTimeout(function () {
      var newText = thisPicker.$hour.value;
      var hour = parseFloat(newText) || 0;
      if (hour < 0 || hour >= 24) hour = thisPicker._preHour;else {
        thisPicker._hour = hour;

        thisPicker._showSelectHour(hour);
      }
    }, 30);
  }
};

TimePicker.eventHandler.keydownMinute = function (event) {
  var thisPicker = this;

  if (event.key == 'Enter') {
    this.$minute.blur();
    event.preventDefault();
    setTimeout(this.finishSelect.bind(this), 30);
  } else if (event.key == 'Tab') {
    this.$minute.selectNone();
    this.$finishBtn.focus();
    event.preventDefault();
  } else {
    setTimeout(function () {
      var newText = thisPicker.$minute.value;
      var minute = parseFloat(newText) || 0;
      if (minute < 0 || minute >= 60) minute = thisPicker._preMinute;else {
        thisPicker._minute = minute;

        thisPicker._showSelectMinute(minute);
      }
    }, 30);
  }
};

TimePicker.eventHandler.keydownHourInput = function (event) {
  var thisPicker = this;

  if (isTouchDevice && event.key == "Unidentified" || event.key && event.key.length == 1 && !event.ctrlKey && !event.altKey) {
    if (event.key.match(/[0-9]/)) {
      setTimeout(this.notifyChange.bind(this), 2);
    } else {
      event.preventDefault();
    }
  } else if (event.key == 'Enter') {
    event.preventDefault();
    this.$hourInput.blur();
    this.editMinuteInput();
  } else if (!event.key && !event.key.toLowerCase().match(/arrow|back/)) {
    var cText = this.$hourInput.value;
    setTimeout(function () {
      var newText = thisPicker.$hourInput.value;

      if (cText != newText) {
        var hour = parseFloat(newText) || 0;
        if (hour < 0 || hour >= 24) hour = thisPicker._preHour;
        thisPicker.hour = hour;
        thisPicker.$hourInput.blur();
        thisPicker.editMinuteInput();
        thisPicker.notifyChange();
      }
    }, 1);
  }
};

TimePicker.eventHandler.keydownMinuteInput = function (event) {
  var thisPicker = this;

  if (isTouchDevice && event.key == "Unidentified" || event.key.length == 1 && !event.ctrlKey && !event.altKey) {
    if (isTouchDevice && event.key == "Unidentified" || event.key.match(/[0-9]/)) {
      setTimeout(this.notifyChange.bind(this), 2);
    } else {
      event.preventDefault();
    }
  } else if (event.key == 'Enter') {
    this.$minute.blur();
    this.eventHandler.blurMinuteInput();
    event.preventDefault();
    setTimeout(this.finishSelect.bind(this), 100);
  } else if (event.key == "Backspace") {} else if (event.key != 'Enter') {
    var cText = this.$minuteInput.value;
    setTimeout(function () {
      var newText = thisPicker.$minuteInput.value;

      if (cText != newText) {
        var minute = parseFloat(newText) || 0;
        if (minute < 0 || minute >= 60) minute = thisPicker._preMinute;
        thisPicker.minute = minute;
        thisPicker.$minuteInput.focus();
        thisPicker.$minuteInput.select();
        thisPicker.notifyChange();
      }
    }, 1);
  }
};

TimePicker.eventHandler.dragOnClock = function (event) {
  event = event.changedTouches && event.changedTouches[0] || event;
  var cBound = this.$clock.getBoundingClientRect();
  var cx = (cBound.left + cBound.right) / 2;
  var cy = (cBound.top + cBound.bottom) / 2;
  var x = event.clientX - cx;
  var y = event.clientY - cy;
  var angle = Math.atan2(y, x);
  var radius = Math.sqrt(x * x + y * y);
  var index;

  if (this._state == "EDIT_HOUR") {
    angle += Math.PI * 2;
    index = Math.round(angle / (Math.PI / 6));
    var hour = (index + (12 + 3)) % 12;

    if (radius < (this._clockRadiusInner + this._clockRadius) / 2) {
      if (hour != 0) hour += 12;
    } else {
      if (hour == 0) hour = 12;
    }

    this._hour = hour;

    this._showSelectHour(hour);

    this.$hour.value = hour < 10 ? '0' + hour : hour;
    this.$hour.selectEnd();
  } else if (this._state == "EDIT_MINUTE") {
    radius = this._clockRadius;
    angle += Math.PI * 2;
    index = Math.round(angle / (Math.PI / 30));
    angle = index * (Math.PI / 30);
    var minute = (index + (60 + 15)) % 60;
    this._minute = minute;
    this.$minute.value = minute < 10 ? '0' + minute : minute;

    this._showSelectMinute(minute);

    this.$minute.selectEnd();
    this.notifyChange();
  } else {
    return;
  }
};

TimePicker.eventHandler.mousedownClock = function (event) {
  event.preventDefault();
  this.eventHandler.dragOnClock(event);
  document.body.addEventListener(isTouchDevice ? 'touchmove' : 'mousemove', this.eventHandler.mousemoveClock);
  document.body.addEventListener(isTouchDevice ? 'touchend' : 'mouseup', this.eventHandler.mousefinishClock);
  if (!isTouchDevice) document.body.addEventListener('mouseleave', this.eventHandler.mousefinishClock);
};

TimePicker.eventHandler.mousemoveClock = function (event) {
  event.preventDefault();
  this.eventHandler.dragOnClock(event);
};

TimePicker.eventHandler.mousefinishClock = function () {
  document.body.removeEventListener('mousemove', this.eventHandler.mousemoveClock);
  document.body.removeEventListener('mouseup', this.eventHandler.mousefinishClock);
  document.body.removeEventListener('mouseleave', this.eventHandler.mousefinishClock);

  if (this._state == 'EDIT_HOUR') {
    if (this.$minute.readOnly) {
      this._editMinuteState();
    } else {
      this.$minute.focus();
    }
  } else if (this._state == 'EDIT_MINUTE') {
    this.$minute.selectAll(); // refocus
  }
};

_ACore.default.install('timepicker', TimePicker);

var _default = TimePicker;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TimeSelectInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TimeSelectInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/timeselectinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));

var _datetime = require("absol/src/Time/datetime");

var _TimeInput = _interopRequireDefault(require("./TimeInput"));

var _EventEmitter = _interopRequireDefault(require("absol/src/HTML5/EventEmitter"));

var _utils = require("./utils");

var _Dom = require("absol/src/HTML5/Dom");


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends AElement
 * @constructor
 */

function TimeSelectInput() {
  /***
   *
   * @type {SelectListBox}
   */
  this.$selectlistBox = _({
    tag: 'selectlistbox',
    props: {
      anchor: [1, 6, 2, 5]
    },
    on: {
      preupdateposition: this.eventHandler.preUpdateListPosition
    }
  });
  this.$text = $('.as-time-select-input-text', this).on('change', this.eventHandler.textChange).on('keyup', this.eventHandler.textKeyUp).on('keydown', this.eventHandler.textKeyDown);
  this.$toggleBtn = $('absol-selectmenu-btn', this);
  this.$selectlistBox.on('pressitem', this.eventHandler.selectListBoxPressItem);
  this.$selectlistBox.followTarget = this;

  this._makeTimeList(0, _datetime.MILLIS_PER_DAY, _datetime.MILLIS_PER_MINUTE * 15);

  this._hour = 0;
  this._minute = 0;
  this._lastDayOffset = 0;
  this.dayOffset = 0;
  this.on('click', this.eventHandler.click);
}

TimeSelectInput.tag = 'TimeSelectInput'.toLowerCase();

TimeSelectInput.render = function () {
  return _({
    class: 'as-time-select-input',
    extendEvent: 'change',
    attr: {
      tabindex: 0
    },
    child: [{
      tag: 'input',
      class: 'as-time-select-input-text',
      attr: {
        type: 'text'
      }
    }, {
      tag: 'button',
      class: 'absol-selectmenu-btn',
      child: ['dropdown-ico']
    }]
  });
};

TimeSelectInput.prototype._makeTimeList = function (start, end, step) {
  var items = [];

  for (var t = 0; t < end; t += step) {
    items.push({
      text: this._mil2Text(t),
      value: t
    });
  }

  this.$selectlistBox.items = items;
  this.addStyle('--list-min-width', this.$selectlistBox._estimateWidth + 'px');
};

TimeSelectInput.prototype.textRegx = /^((1[0-2])|[1-9]):([0-5][0-9]) (AM|PM)$/;

TimeSelectInput.prototype._mil2Text = function (mil) {
  if (mil < 0) {
    mil = mil + Math.ceil(-mil / _datetime.MILLIS_PER_DAY) * _datetime.MILLIS_PER_DAY;
  }

  var min = Math.floor(mil / _datetime.MILLIS_PER_MINUTE);
  var hour = Math.floor(min / 60) % 24;
  min = min % 60;
  return (hour % 12 == 0 ? 12 : hour % 12) + ':' + (min < 10 ? '0' : '') + min + ' ' + (hour < 12 ? 'AM' : 'PM');
};
/***
 *
 * @param {string} s
 * @private
 */


TimeSelectInput.prototype._text2mil = function (s) {
  s = s.toLowerCase();
  var nums = s.match(/[0-9]+/g) || [0, 0];

  while (nums.length < 2) {
    nums.push(0);
  }

  var h = (0, _utils.positiveIntMod)(parseInt(nums[0]), 24);
  var m = (0, _utils.positiveIntMod)(parseInt(nums[1]), 60);
  var pm = s.indexOf('pm') > 0 || h > 12;

  if (pm) {
    if (h < 12) h += 12;
  } else {
    if (h == 12) h = 0;
  }

  return h * _datetime.MILLIS_PER_HOUR + m * _datetime.MILLIS_PER_MINUTE;
};

TimeSelectInput.prototype.isActive = function () {
  return document.activeElement == this || _AElement.default.prototype.isDescendantOf.call(document.activeElement, this) || _AElement.default.prototype.isDescendantOf.call(document.activeElement, this.$selectlistBox);
};

TimeSelectInput.prototype._updateValueText = function () {
  this.$text.value = this._mil2Text(this.dayOffset);
};

TimeSelectInput.prototype.notifyCanBeChange = function () {
  var dayOffset = this.dayOffset;

  if (this._lastDayOffset !== dayOffset) {
    this.emit('change', {
      type: 'change',
      lastDayOffset: this._lastDayOffset,
      dayOffset: dayOffset,
      target: this
    }, this);
    this._lastDayOffset = dayOffset;
  }
};

TimeSelectInput.property = {};
TimeSelectInput.property.isFocus = {
  get: function () {
    return this.containsClass('as-focus');
  },
  set: function (value) {
    value = !!value;
    if (this.isFocus == value) return;

    if (value) {
      this.addClass('as-focus');
    } else {
      this.removeClass('as-focus');
    }

    var thisI = this;

    if (value) {
      document.body.appendChild(this.$selectlistBox);
      this.$selectlistBox.domSignal.$attachhook.emit('attached');
      var bound = this.getBoundingClientRect();
      this.$selectlistBox.addStyle('min-width', bound.width + 'px');
      this.$selectlistBox.refollow();
      this.$selectlistBox.updatePosition();
      setTimeout(function () {
        if (thisI.enableSearch) {
          thisI.$selectlistBox.$searchInput.focus();
        }

        $(document.body).on('click', thisI.eventHandler.bodyClick);
      }, 1);
      this.$selectlistBox.viewListAtFirstSelected();
    } else {
      $(document.body).off('click', thisI.eventHandler.bodyClick);
      this.$selectlistBox.selfRemove();
      this.$selectlistBox.unfollow();
      this.$selectlistBox.resetSearchState();
    }
  }
};
TimeSelectInput.property.hour = {
  set: function (value) {
    this._hour = (0, _utils.positiveIntMod)(value, 24);
    this._lastDayOffset = this.dayOffset;

    this._updateValueText();
  },
  get: function () {
    return this._hour;
  }
};
TimeSelectInput.property.minute = {
  set: function (value) {
    this._minute = (0, _utils.positiveIntMod)(value, 60);
    this._lastDayOffset = this.dayOffset;

    this._updateValueText();
  },
  get: function () {
    return this._minute;
  }
};
TimeSelectInput.property.dayOffset = _TimeInput.default.property.dayOffset;
TimeSelectInput.property.disabled = {
  set: function (value) {
    this.$text.disabled = !!value;

    if (value) {
      this.addClass('as-disabled');
    } else {
      this.removeClass('as-disabled');
    }
  },
  get: function () {
    return this.containsClass('as-disabled');
  }
};
/***
 *
 * @type {{}|TimeSelectInput}
 */

TimeSelectInput.eventHandler = {};

TimeSelectInput.eventHandler.selectListBoxPressItem = function (event) {
  var lastValue = this._lastDayOffset;
  var value = event.value;

  var text = this._mil2Text(value);

  this.dayOffset = value;
  this.$selectlistBox.values = [value];
  this.focus();
  setTimeout(function () {
    this.isFocus = false;
  }.bind(this), 100);
  this._lastDayOffset = lastValue; // restore last value after set dayOffset

  this.notifyCanBeChange();
};

TimeSelectInput.eventHandler.preUpdateListPosition = function () {
  var bound = this.getBoundingClientRect();
  var screenSize = (0, _Dom.getScreenSize)();
  var availableTop = bound.top - 5;
  var availableBot = screenSize.height - 5 - bound.bottom;
  this.$selectlistBox.addStyle('--max-height', Math.max(availableBot, availableTop) + 'px');
  var outBound = (0, _Dom.traceOutBoundingClientRect)(this);

  if (bound.bottom < outBound.top || bound.top > outBound.bottom || bound.right < outBound.left || bound.left > outBound.right) {
    this.isFocus = false;
  }
};

TimeSelectInput.eventHandler.textChange = function () {
  setTimeout(function () {
    if (!this.textRegx.test(this.$text.value)) {
      this.$text.value = this._mil2Text(this.dayOffset);
    }
  }.bind(this), 10);
};
/***
 *
 * @param {KeyboardEvent} event
 */


TimeSelectInput.eventHandler.textKeyDown = function (event) {
  if (event.key == 'Enter') {
    this.isFocus = false;
    this.$text.blur();
    this.notifyCanBeChange();
  }
};

TimeSelectInput.eventHandler.textKeyUp = function (event) {
  var s = this.$text.value;

  var mil = this._text2mil(s);

  this._hour = Math.floor(mil / _datetime.MILLIS_PER_HOUR);
  this._minute = Math.floor(mil / _datetime.MILLIS_PER_MINUTE) % 60;
  this.$selectlistBox.values = [mil];
  this.$selectlistBox.viewListAtFirstSelected();
};

TimeSelectInput.eventHandler.click = function (event) {
  if (!_EventEmitter.default.hitElement(this.$text, event)) {
    this.isFocus = !this.isFocus;
    setTimeout(function () {
      if (this.isFocus && this.$text != document.activeElement) {
        this.$text.select();
      }
    }.bind(this), 1);
  } else {
    if (!this.isFocus) this.isFocus = true;
  }
};

TimeSelectInput.eventHandler.bodyClick = function (event) {
  if (_EventEmitter.default.hitElement(this, event) || _EventEmitter.default.hitElement(this.$selectlistBox, event)) return;
  this.isFocus = false;
};

_ACore.default.install(TimeSelectInput);

var _default = TimeSelectInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/VariantColors.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/VariantColors.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/variantcolors.css");

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));


function VariantColor() {
  this.keys = ['primary', 'secondary', 'success', 'info', 'warning', 'error', 'danger', 'light', 'dark', 'link', 'note'];
  this.base = {
    primary: "#007bff",
    secondary: "#6c757d",
    success: "#28a745",
    info: "#17a2b8",
    warning: "#ffc107",
    error: "#ff4052",
    danger: "#dc3545",
    light: "#f8f9fa",
    dark: "#343a40",
    link: "#007bff",
    note: '#ffff88'
  };
  this.mediumContract = {
    primary: '#e2edd5',
    secondary: '#fca75b',
    success: '#fce8e8',
    info: '#fcf5e8',
    warning: '#5e5a75',
    error: '#e0dfce',
    danger: "#e5e8d5",
    light: '#7a5b3c',
    dark: "#bf7d3b",
    link: "#dde8c9",
    note: '#1e1ec8'
  };

  _Dom.default.documentReady.then(this.loadFromCss.bind(this));
}

VariantColor.prototype.has = function (name) {
  return this.keys.indexOf(name) >= 0;
};

VariantColor.prototype.loadFromCss = function () {
  this.base = this.keys.reduce(function (ac, name) {
    var style = window.getComputedStyle(document.body);
    ac[name] = style.getPropertyValue('--variant-color-' + name);
    return ac;
  }, {});
  this.mediumContract = this.keys.reduce(function (ac, name) {
    var style = window.getComputedStyle(document.body);
    ac[name] = style.getPropertyValue('--variant-medium-contract-color-' + name);
    return ac;
  }, {});
};

var _default = new VariantColor();

exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/JSMaker/TemplateString.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/JSMaker/TemplateString.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function TemplateString(props) {
  this.parts = props.parts;
}

TemplateString.prototype.toJSCode = function () {
  return this.parts.map(function (e) {
    if (e.type == TemplateString.TYPE_EXPRESSION) {
      return '(' + e.data + ')';
    } else {
      return JSON.stringify(e.data);
    }
  }).join('+');
};

TemplateString.__partRegex = /(\{\{(([^\}]|(\}[^\}]))*)\}\})|(([^\{]|(\{[^\{]))+)/g;
/**
 *  @param  {String} text 
 */

TemplateString.__matchExpression = function (text) {
  if (text[0] == '{' && text[1] == '{' && text[text.length - 1] == '}' && text[text.length - 2] == '}') {
    return [text, text.substr(2, text.length - 4).trim()];
  } else {
    return false;
  }
};

TemplateString.TYPE_STRING = 0;
TemplateString.TYPE_EXPRESSION = 1;

TemplateString.parse = function (text) {
  text = text + '';
  var matchedParts = text.match(this.__partRegex);

  if (matchedParts) {
    var parts = matchedParts.map(function (e) {
      var matchedExp = this.__matchExpression(e);

      if (matchedExp) {
        return {
          type: this.TYPE_EXPRESSION,
          data: matchedExp[1]
        };
      } else {
        return {
          type: this.TYPE_STRING,
          data: e
        };
      }
    }.bind(this));
    return new TemplateString({
      parts: parts
    });
  } else {
    return undefined;
  }
};

var _default = TemplateString;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol/src/Color/Color.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol/src/Color/Color.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TemplateString = _interopRequireDefault(require("../JSMaker/TemplateString"));


function Color(rgba) {
  this.rgba = rgba.slice();
}

Color.prototype.toHex6 = function () {
  return this.rgba.slice(0, 3).map(function (b) {
    b = b * 255 >> 0;
    return (b < 16 ? '0' : '') + b.toString(16);
  }).join('');
};

Color.prototype.toHex8 = function () {
  return this.rgba.map(function (b) {
    b = b * 255 >> 0;
    return (b < 16 ? '0' : '') + b.toString(16);
  }).join('');
};

Color.prototype.toHex3 = function () {
  return this.rgba.slice(0, 3).map(function (b) {
    b = b * 255 / 17 >> 0;
    return b.toString(16);
  }).join('');
};

Color.prototype.toHex4 = function () {
  return this.rgba.map(function (b) {
    b = b * 255 / 17 >> 0;
    return b.toString(16);
  }).join('');
};

Color.prototype.toHSLA = function () {
  return Color.rgbaToHSLA(this.rgba);
};

Color.prototype.toHSBA = function () {
  return Color.rgbaToHSBA(this.rgba);
};

Color.prototype.toHWBA = function () {
  return Color.rgbaToHWBA(this.rgba);
};

Color.prototype.getHightContrastColor = function () {
  var hsba = this.toHSBA();
  var h, s, b;
  h = hsba[0] > 0.5 ? hsba[0] - 0.5 : hsba[0] + 0.5;
  s = hsba[1] > 0.5 ? hsba[1] - 0.5 : hsba[1] + 0.5;
  b = hsba[2] > 0.5 ? hsba[2] - 0.5 : hsba[2] + 0.5;
  return Color.fromHSB(h, s, b);
};

Color.prototype.getContrastYIQ = function () {
  var r = this.rgba[0] * 255;
  var g = this.rgba[1] * 255;
  var b = this.rgba[2] * 255;
  var yiq = (r * 299 + g * 587 + b * 114) / 1000;
  return yiq >= 128 ? new Color([0, 0, 0, 1]) : new Color([1, 1, 1, 1]);
};

Color.prototype.clone = function () {
  return new Color(this.rgba.slice());
};

Color.prototype.toString = function (mode) {
  mode = mode || 'rgba';
  mode = mode.toLocaleLowerCase();
  return Color.templates[mode](this);
};
/***
 *
 */


Color.prototype.nearestNamedColor = function (notStandard, hsbWeight) {
  hsbWeight = hsbWeight || [5, 3, 1];
  var hsba = this.toHSBA();
  var bestMatch = null;
  var dist = 1000;
  Object.keys(Color.namedColors).concat(notStandard ? Object.keys(Color.nonStandarNamedColors) : []).forEach(function (name) {
    var c = Color.parse(Color.namedColors[name] || Color.nonStandarNamedColors[name]);
    var cHSBA = c.toHSBA();
    var cDist = Math.abs(hsba[0] - cHSBA[0]) * hsbWeight[0] + Math.abs(hsba[1] - cHSBA[1]) * hsbWeight[1] + Math.abs(hsba[2] - cHSBA[2]) * hsbWeight[2];

    if (cDist < dist) {
      dist = cDist;
      bestMatch = name;
    }
  });
  return bestMatch;
};

Color.templates = [['rgba', 'rgba', 'rgba({{x[0]*255>>0}}, {{x[1]*255>>0}}, {{x[2]*255>>0}}, {{x[3]}})'], ['rgb', 'rgba', 'rgb({{x[0]*255>>0}}, {{x[1]*255>>0}}, {{x[2]*255>>0}})'], ['hsl', 'toHSLA()', 'hsl({{x[0] * 360}}, {{x[1] * 100}}%, {{x[2] * 100}}%)'], ['hsla', 'toHSLA()', 'hsla({{x[0] * 360}}, {{x[1] * 100}}%, {{x[2] * 100}}%, {{x[3]}})'], ['hsb', 'toHSBA()', 'hsb({{x[0] * 360}}, {{x[1] * 100}}%, {{x[2] * 100}}%)'], ['hsba', 'toHSBA()', 'hsba({{x[0] * 360}}, {{x[1] * 100}}%, {{x[2] * 100}}%, {{x[3]}})'], ['hex3', 'toHex3()', '#{{x}}'], ['hex4', 'toHex4()', '#{{x}}'], ['hex6', 'toHex6()', '#{{x}}'], ['hex8', 'toHex8()', '#{{x}}'], ['hwb', 'toHWBA()', 'hwb({{x[0] * 360}}, {{x[1] * 100}}%, {{x[2] * 100}}%)'], ['hwba', 'toHWBA()', 'hwba({{x[0] * 360}}, {{x[1] * 100}}%, {{x[2] * 100}}%, {{x[3]}})']].reduce(function (ac, cr) {
  ac[cr[0]] = new Function('color', ['var x = color.' + cr[1] + ';', 'return ' + _TemplateString.default.parse(cr[2]).toJSCode() + ';'].join('\n'));
  return ac;
}, {});
Color.regexes = {
  whiteSpace: /\s*/,
  // Match zero or more whitespace characters.
  integer: /(\d{1,3})/,
  // Match integers: 79, 255, etc.
  decimal: /((?:\d+(?:\.\d+)?)|(?:\.\d+))/,
  // Match 129.6, 79, .9, etc.
  percent: /((?:\d+(?:\.\d+)?)|(?:\.\d+))%/,
  // Match 12.9%, 79%, .9%, etc.
  hex3: /^#([a-f0-9])([a-f0-9])([a-f0-9])$/i,
  // Match colors in format #XXXX, e.g. #5123.
  hex4: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])$/i,
  // Match colors in format #XXXXXX, e.g. #b4d455.
  hex6: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i,
  // Match colors in format #XXXXXXXX, e.g. #b4d45535.
  hex8: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i
};
Color.regexes.percent = new RegExp(Color.regexes.decimal.source + '%');
Color.regexes.rgb = new RegExp(['^rgb\\(', Color.regexes.integer.source, ',', Color.regexes.integer.source, ',', Color.regexes.integer.source, '\\)$'].join(Color.regexes.whiteSpace.source), 'i');
Color.regexes.rgbPercent = new RegExp(['^rgb\\(', Color.regexes.percent.source, ',', Color.regexes.percent.source, ',', Color.regexes.percent.source, '\\)$'].join(Color.regexes.whiteSpace.source), 'i'); // Match colors in format rgb(R, G, B, A), e.g. rgb(255, 0, 128, 0.25).

Color.regexes.rgba = new RegExp(['^rgba\\(', Color.regexes.integer.source, ',', Color.regexes.integer.source, ',', Color.regexes.integer.source, ',', Color.regexes.decimal.source, '\\)$'].join(Color.regexes.whiteSpace.source), 'i'); // Match colors in format rgb(R%, G%, B%, A), e.g. rgb(100%, 0%, 28.9%, 0.5).

Color.regexes.rgbaPercent = new RegExp(['^rgba\\(', Color.regexes.percent.source, ',', Color.regexes.percent.source, ',', Color.regexes.percent.source, ',', Color.regexes.decimal.source, '\\)$'].join(Color.regexes.whiteSpace.source), 'i'); // Match colors in format hsla(H, S%, L%), e.g. hsl(100, 40%, 28.9%).

Color.regexes.hsl = new RegExp(['^hsl\\(', Color.regexes.integer.source, '[deg]*', ',', Color.regexes.percent.source, ',', Color.regexes.percent.source, '\\)$'].join(Color.regexes.whiteSpace.source), 'i'); // Match colors in format hsla(H, S%, L%, A), e.g. hsla(100, 40%, 28.9%, 0.5).

Color.regexes.hsla = new RegExp(['^hsla\\(', Color.regexes.integer.source, '[deg]*', ',', Color.regexes.percent.source, ',', Color.regexes.percent.source, ',', Color.regexes.decimal.source, '\\)$'].join(Color.regexes.whiteSpace.source), 'i'); // Match colors in format hsb(H, S%, B%), e.g. hsb(100, 40%, 28.9%).

Color.regexes.hsb = new RegExp(['^hsb\\(', Color.regexes.integer.source, '[deg]*', ',', Color.regexes.percent.source, ',', Color.regexes.percent.source, '\\)$'].join(Color.regexes.whiteSpace.source), 'i'); // Match colors in format hsba(H, S%, B%, A), e.g. hsba(100, 40%, 28.9%, 0.5).

Color.regexes.hsba = new RegExp(['^hsba\\(', Color.regexes.integer.source, '[deg]*', ',', Color.regexes.percent.source, ',', Color.regexes.percent.source, ',', Color.regexes.decimal.source, '\\)$'].join(Color.regexes.whiteSpace.source), 'i');
Color.regexes.hwb = new RegExp(['^hwb\\(', Color.regexes.integer.source, '[deg]*', ',', Color.regexes.percent.source, ',', Color.regexes.percent.source, '\\)$'].join(Color.regexes.whiteSpace.source), 'i'); // Match colors in format hsba(H, S%, B%, A), e.g. hsba(100, 40%, 28.9%, 0.5).

Color.regexes.hwba = new RegExp(['^hwba\\(', Color.regexes.integer.source, '[deg]*', ',', Color.regexes.percent.source, ',', Color.regexes.percent.source, ',', Color.regexes.decimal.source, '\\)$'].join(Color.regexes.whiteSpace.source), 'i');

Color.fromInt = function (code, bits) {
  var r, g, b, a;

  if (bits == 32) {
    b = (code & 0xff) / 255;
    g = ((code & 0xff00) >> 8) / 255;
    r = ((code & 0xff0000) >> 16) / 255;
    a = (code >> 24) / 255;
  } else if (bits == 24) {
    b = (code & 0xff) / 255;
    g = ((code & 0xff00) >> 8) / 255;
    r = ((code & 0xff0000) >> 16) / 255;
    a = 1;
  } else if (bits == 16) {
    b = (code & 0x1f) / 0x1f;
    g = ((code & 0x7e0) >> 5) / 0x3f;
    b = (code >> 10) / 0x1f;
    a = 1;
  } else if (bits == 8) {
    //gray-scale
    b = (code & 0x3) / 0x3;
    g = ((code & 0x1c) >> 2) / 0x7;
    b = (code >> 5) / 0x7;
    a = 1;
  }

  return new Color([r, g, b, a]);
};

Color.fromRGB = function (r, g, b) {
  return new Color([r, g, b, 1]);
};

Color.fromRGBA = function (r, g, b, a) {
  return new Color([r, g, b, a]);
};

Color.fromHSL = function (h, s, l) {
  var rgba = this.hslaToRGBA([h, s, l, 1]);
  return new Color(rgba);
};

Color.fromHSLA = function (h, s, l, a) {
  var rgba = this.hslaToRGBA([h, s, l, a]);
  return new Color(rgba);
};

Color.fromHSB = function (h, s, b) {
  var rgba = this.hsbaToRGBA([h, s, b, 1]);
  return new Color(rgba);
};

Color.fromHSBA = function (h, s, b, a) {
  var rgba = this.hsbaToRGBA([h, s, b, a]);
  return new Color(rgba);
};

Color.fromHWB = function (h, s, b) {
  var rgba = this.hwbaToRGBA([h, s, b, 1]);
  return new Color(rgba);
};

Color.fromHWBA = function (h, s, b, a) {
  var rgba = this.hwbaToRGBA([h, s, b, a]);
  return new Color(rgba);
};
/**
 * @param {String} text
 * @returns {Color}
 */


Color.parse = function (text) {
  if (this.namedColors[text]) text = this.namedColors[text];
  if (this.nonStandarNamedColors[text]) text = this.nonStandarNamedColors[text];

  if (this.regexes.hex8.test(text)) {
    return this.fromRGBA.apply(this, this.regexes.hex8.exec(text).slice(1).map(function (v) {
      return parseInt(v, 16) / 255;
    }));
  } else if (this.regexes.hex6.test(text)) {
    return this.fromRGB.apply(this, this.regexes.hex6.exec(text).slice(1).map(function (v) {
      return parseInt(v, 16) / 255;
    }));
  } else if (this.regexes.hex4.test(text)) {
    return this.fromRGBA.apply(this, this.regexes.hex4.exec(text).slice(1).map(function (v) {
      return parseInt(v + v, 16) / 255;
    }));
  } else if (this.regexes.hex3.test(text)) {
    return this.fromRGB.apply(this, this.regexes.hex3.exec(text).slice(1).map(function (v) {
      return parseInt(v + v, 16) / 255;
    }));
  } else if (this.regexes.rgba.test(text)) {
    return this.fromRGBA.apply(this, this.regexes.rgba.exec(text).slice(1).map(function (v, i) {
      return i < 3 ? parseFloat(v, 10) / 255 : parseFloat(v, 10);
    }));
  } else if (this.regexes.rgb.test(text)) {
    return this.fromRGB.apply(this, this.regexes.rgb.exec(text).slice(1).map(function (v, i) {
      return parseFloat(v, 10) / 255;
    }));
  } else if (this.regexes.rgbPercent.test(text)) {
    return this.fromRGB.apply(this, this.regexes.rgbPercent.exec(text).slice(1).map(function (v, i) {
      return parseFloat(v, 10) / 100;
    }));
  } else if (this.regexes.rgbaPercent.test(text)) {
    return this.fromRGBA.apply(this, this.regexes.rgbaPercent.exec(text).slice(1).map(function (v, i) {
      return parseFloat(v, 10) / (i < 3 ? 100 : 1);
    }));
  } else if (this.regexes.hsl.test(text)) {
    return this.fromHSL.apply(this, this.regexes.hsl.exec(text).slice(1).map(function (v, i) {
      return parseFloat(v, 10) / (i == 0 ? 360 : 100);
    }));
  } else if (this.regexes.hsla.test(text)) {
    return this.fromHSLA.apply(this, this.regexes.hsla.exec(text).slice(1).map(function (v, i) {
      return parseFloat(v, 10) / (i == 0 ? 360 : i < 3 ? 100 : 1);
    }));
  } else if (this.regexes.hsb.test(text)) {
    return this.fromHSB.apply(this, this.regexes.hsb.exec(text).slice(1).map(function (v, i) {
      return parseFloat(v, 10) / (i == 0 ? 360 : 100);
    }));
  } else if (this.regexes.hsba.test(text)) {
    return this.fromHSBA.apply(this, this.regexes.hsba.exec(text).slice(1).map(function (v, i) {
      return parseFloat(v, 10) / (i == 0 ? 360 : i < 3 ? 100 : 1);
    }));
  } else if (this.regexes.hwb.test(text)) {
    return this.fromHWB.apply(this, this.regexes.hwb.exec(text).slice(1).map(function (v, i) {
      return parseFloat(v, 10) / (i == 0 ? 360 : 100);
    }));
  } else if (this.regexes.hwba.test(text)) {
    return this.fromHWBA.apply(this, this.regexes.hwba.exec(text).slice(1).map(function (v, i) {
      return parseFloat(v, 10) / (i == 0 ? 360 : i < 3 ? 100 : 1);
    }));
  } else {
    throw new Error("Fail to parse " + text);
  }
};
/***
 * @typedef {"aliceblue"|"antiquewhite"|"aqua"|"aquamarine"|"azure"|"beige"|"bisque"|"black"|"blanchedalmond"|"blue"|"blueviolet"|"brown"|"burlywood"|"cadetblue"|"chartreuse"|"chocolate"|"coral"|"cornflowerblue"|"cornsilk"|"crimson"|"cyan"|"darkblue"|"darkcyan"|"darkgoldenrod"|"darkgray"|"darkgreen"|"darkgrey"|"darkkhaki"|"darkmagenta"|"darkolivegreen"|"darkorange"|"darkorchid"|"darkred"|"darksalmon"|"darkseagreen"|"darkslateblue"|"darkslategray"|"darkslategrey"|"darkturquoise"|"darkviolet"|"deeppink"|"deepskyblue"|"dimgray"|"dimgrey"|"dodgerblue"|"firebrick"|"floralwhite"|"forestgreen"|"fuchsia"|"gainsboro"|"ghostwhite"|"gold"|"goldenrod"|"gray"|"green"|"greenyellow"|"grey"|"honeydew"|"hotpink"|"indianred"|"indigo"|"ivory"|"khaki"|"lavender"|"lavenderblush"|"lawngreen"|"lemonchiffon"|"lightblue"|"lightcoral"|"lightcyan"|"lightgoldenrodyellow"|"lightgray"|"lightgreen"|"lightgrey"|"lightpink"|"lightsalmon"|"lightseagreen"|"lightskyblue"|"lightslategray"|"lightslategrey"|"lightsteelblue"|"lightyellow"|"lime"|"limegreen"|"linen"|"magenta"|"maroon"|"mediumaquamarine"|"mediumblue"|"mediumorchid"|"mediumpurple"|"mediumseagreen"|"mediumslateblue"|"mediumspringgreen"|"mediumturquoise"|"mediumvioletred"|"midnightblue"|"mintcream"|"mistyrose"|"moccasin"|"navajowhite"|"navy"|"oldlace"|"olive"|"olivedrab"|"orange"|"orangered"|"orchid"|"palegoldenrod"|"palegreen"|"paleturquoise"|"palevioletred"|"papayawhip"|"peachpuff"|"peru"|"pink"|"plum"|"powderblue"|"purple"|"red"|"rosybrown"|"royalblue"|"saddlebrown"|"salmon"|"sandybrown"|"seagreen"|"seashell"|"sienna"|"silver"|"skyblue"|"slateblue"|"slategray"|"slategrey"|"snow"|"springgreen"|"steelblue"|"tan"|"teal"|"thistle"|"tomato"|"turquoise"|"violet"|"wheat"|"white"|"whitesmoke"|"yellow"|"yellowgreen"|"transparent"} NamedColor
 */


Color.namedColors = {
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aqua: '#00ffff',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  black: '#000000',
  blanchedalmond: '#ffebcd',
  blue: '#0000ff',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkgrey: '#a9a9a9',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkslategrey: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dimgrey: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  fuchsia: '#ff00ff',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  gold: '#ffd700',
  goldenrod: '#daa520',
  gray: '#808080',
  green: '#008000',
  greenyellow: '#adff2f',
  grey: '#808080',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavender: '#e6e6fa',
  lavenderblush: '#fff0f5',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgray: '#d3d3d3',
  lightgreen: '#90ee90',
  lightgrey: '#d3d3d3',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#778899',
  lightslategrey: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  lime: '#00ff00',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  maroon: '#800000',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370db',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  navy: '#000080',
  oldlace: '#fdf5e6',
  olive: '#808000',
  olivedrab: '#6b8e23',
  orange: '#ffa500',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#db7093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  purple: '#800080',
  red: '#ff0000',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  silver: '#c0c0c0',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  slategrey: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  teal: '#008080',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  white: '#ffffff',
  whitesmoke: '#f5f5f5',
  yellow: '#ffff00',
  yellowgreen: '#9acd32',
  transparent: '#00000000'
};
Color.nonStandarNamedColors = {
  night: '#0C090A',
  gunmetal: '#2C3539',
  midnight: '#2B1B17',
  charcoal: '#34282C',
  oil: '#3B3131',
  blackcat: '#413839',
  iridium: '#3D3C3A',
  blackeel: '#463E3F',
  blackcow: '#4C4646',
  graywolf: '#504A4B',
  vampiregray: '#565051',
  graydolphin: '#5C5858',
  carbongray: '#625D5D',
  ashgray: '#666362',
  cloudygray: '#6D6968',
  smokeygray: '#726E6D',
  granite: '#837E7C',
  battleshipgray: '#848482',
  graycloud: '#B6B6B4',
  graygoose: '#D1D0CE',
  platinum: '#E5E4E2',
  metallicsilver: '#BCC6CC',
  bluegray: '#98AFC7',
  raven: '#657383',
  jetgray: '#616D7E',
  mistblue: '#646D7E',
  marbleblue: '#566D7E',
  shipcove: '#737CA1',
  mariner: '#4863A0',
  bluejay: '#2B547E',
  biscay: '#2B3856',
  navyblue: '#000080',
  bluewhale: '#342D7E',
  lapisblue: '#15317E',
  denimdarkblue: '#151B8D',
  earthblue: '#0000A0',
  cobaltblue: '#0020C2',
  blueberryblue: '#0041C2',
  sapphireblue: '#2554C7',
  blueeyes: '#1569C7',
  blueorchid: '#1F45FC',
  bluelotus: '#6960EC',
  lightslateblue: '#736AFF',
  windowsblue: '#357EC7',
  glacialblueice: '#368BC1',
  silkblue: '#488AC7',
  blueivy: '#3090C7',
  bluekoi: '#659EC7',
  columbiablue: '#87AFC7',
  babyblue: '#95B9C7',
  oceanblue: '#2B65EC',
  blueribbon: '#306EFF',
  bluedress: '#157DEC',
  butterflyblue: '#38ACEC',
  iceberg: '#56A5EC',
  crystalblue: '#5CB3FF',
  denimblue: '#79BAEC',
  dayskyblue: '#82CAFF',
  jeansblue: '#A0CFEC',
  blueangel: '#B7CEEC',
  pastelblue: '#B4CFEC',
  seablue: '#C2DFFF',
  coralblue: '#AFDCEC',
  robineggblue: '#BDEDFF',
  palebluelily: '#CFECEC',
  water: '#EBF4FA',
  lightslate: '#CCFFFF',
  lightaquamarine: '#93FFE8',
  electricblue: '#9AFEFF',
  cyanoraqua: '#00FFFF',
  tronblue: '#7DFDFE',
  bluezircon: '#57FEFF',
  bluelagoon: '#8EEBEC',
  celeste: '#50EBEC',
  bluediamond: '#4EE2EC',
  tiffanyblue: '#81D8D0',
  cyanopaque: '#92C7C7',
  bluehosta: '#77BFC7',
  northernlightsblue: '#78C7C7',
  jellyfish: '#46C7C7',
  bluegreen: '#7BCCB5',
  macawbluegreen: '#43BFC7',
  seaturtlegreen: '#438D80',
  greenishblue: '#307D7E',
  grayishturquoise: '#5E7D7E',
  beetlegreen: '#4C787E',
  camouflagegreen: '#78866B',
  sagegreen: '#848b79',
  hazelgreen: '#617C58',
  venomgreen: '#728C00',
  ferngreen: '#667C26',
  darkforestgreen: '#254117',
  mediumforestgreen: '#347235',
  seaweedgreen: '#437C17',
  pinegreen: '#387C44',
  junglegreen: '#347C2C',
  shamrockgreen: '#347C17',
  greenonion: '#6AA121',
  clovergreen: '#3EA055',
  greensnake: '#6CBB3C',
  aliengreen: '#6CC417',
  greenapple: '#4CC417',
  kellygreen: '#4CC552',
  zombiegreen: '#54C571',
  froggreen: '#99C68E',
  greenpeas: '#89C35C',
  dollarbillgreen: '#85BB65',
  iguanagreen: '#9CB071',
  avocadogreen: '#B2C248',
  pistachiogreen: '#9DC209',
  saladgreen: '#A1C935',
  hummingbirdgreen: '#7FE817',
  nebulagreen: '#59E817',
  stoplightgogreen: '#57E964',
  algaegreen: '#64E986',
  jadegreen: '#5EFB6E',
  emeraldgreen: '#5FFB17',
  dragongreen: '#6AFB92',
  mintgreen: '#98FF98',
  greenthumb: '#B5EAAA',
  lightjade: '#C3FDB8',
  teagreen: '#CCFB5D',
  slimegreen: '#BCE954',
  harvestgold: '#EDE275',
  sunyellow: '#FFE87C',
  cornyellow: '#FFF380',
  parchment: '#FFFFC2',
  cream: '#FFFFCC',
  blonde: '#FBF6D9',
  champagne: '#F7E7CE',
  vanilla: '#F3E5AB',
  tanbrown: '#ECE5B6',
  peach: '#FFE5B4',
  mustard: '#FFDB58',
  rubberduckyyellow: '#FFD801',
  brightgold: '#FDD017',
  goldenbrown: '#EAC117',
  macaroniandcheese: '#F2BB66',
  saffron: '#FBB917',
  beer: '#FBB117',
  cantaloupe: '#FFA62F',
  beeyellow: '#E9AB17',
  brownsugar: '#E2A76F',
  deeppeach: '#FFCBA4',
  gingerbrown: '#C9BE62',
  schoolbusyellow: '#E8A317',
  fallleafbrown: '#C8B560',
  orangegold: '#D4A017',
  sand: '#C2B280',
  cookiebrown: '#C7A317',
  caramel: '#C68E17',
  brass: '#B5A642',
  camelbrown: '#C19A6B',
  bronze: '#CD7F32',
  tigerorange: '#C88141',
  cinnamon: '#C58917',
  bulletshell: '#AF9B60',
  copper: '#B87333',
  wood: '#966F33',
  oakbrown: '#806517',
  armybrown: '#827B60',
  sandstone: '#786D5F',
  mocha: '#493D26',
  taupe: '#483C32',
  coffee: '#6F4E37',
  brownbear: '#835C3B',
  reddirt: '#7F5217',
  sepia: '#7F462C',
  orangesalmon: '#C47451',
  rust: '#C36241',
  redfox: '#C35817',
  sedona: '#CC6600',
  papayaorange: '#E56717',
  halloweenorange: '#E66C2C',
  pumpkinorange: '#F87217',
  constructionconeorange: '#F87431',
  sunriseorange: '#E67451',
  mangoorange: '#FF8040',
  basketballorange: '#F88158',
  tangerine: '#E78A61',
  beanred: '#F75D59',
  valentinered: '#E55451',
  shockingorange: '#E55B3C',
  scarlet: '#FF2400',
  rubyred: '#F62217',
  ferrarired: '#F70D1A',
  fireenginered: '#F62817',
  lavared: '#E42217',
  lovered: '#E41B17',
  grapefruit: '#DC381F',
  chestnutred: '#C34A2C',
  cherryred: '#C24641',
  mahogany: '#C04000',
  chillipepper: '#C11B17',
  cranberry: '#9F000F',
  redwine: '#990012',
  burgundy: '#8C001A',
  chestnut: '#954535',
  bloodred: '#7E3517',
  sangria: '#7E3817',
  plumpie: '#7D0541',
  velvetmaroon: '#7E354D',
  plumvelvet: '#7D0552',
  rosyfinch: '#7F4E52',
  puce: '#7F5A58',
  dullpurple: '#7F525D',
  khakirose: '#C5908E',
  pinkbow: '#C48189',
  lipstickpink: '#C48793',
  rose: '#E8ADAA',
  rosegold: '#ECC5C0',
  desertsand: '#EDC9AF',
  pigpink: '#FDD7E4',
  cottoncandy: '#FCDFFF',
  pinkbubblegum: '#FFDFDD',
  flamingopink: '#F9A7B0',
  pinkrose: '#E7A1B0',
  pinkdaisy: '#E799A3',
  cadillacpink: '#E38AAE',
  carnationpink: '#F778A1',
  blushred: '#E56E94',
  watermelonpink: '#FC6C85',
  violetred: '#F6358A',
  pinkcupcake: '#E45E9D',
  pinklemonade: '#E4287C',
  neonpink: '#F535AA',
  dimorphothecamagenta: '#E3319D',
  brightneonpink: '#F433FF',
  tulippink: '#C25A7C',
  roguepink: '#C12869',
  burntpink: '#C12267',
  bashfulpink: '#C25283',
  darkcarnationpink: '#C12283',
  violapurple: '#7E587E',
  purpleiris: '#571B7E',
  plumpurple: '#583759',
  purplemonster: '#461B7E',
  purplehaze: '#4E387E',
  eggplant: '#614051',
  grape: '#5E5A80',
  purplejam: '#6A287E',
  purpleflower: '#A74AC7',
  purpleamethyst: '#6C2DC7',
  purplesagebush: '#7A5DC7',
  lovelypurple: '#7F38EC',
  aztechpurple: '#893BFF',
  jasminepurple: '#A23BEC',
  purpledaffodil: '#B041FF',
  tyrianpurple: '#C45AEC',
  crocuspurple: '#9172EC',
  purplemimosa: '#9E7BFF',
  heliotropepurple: '#D462FF',
  purpledragon: '#C38EC7',
  lilac: '#C8A2C8',
  blushpink: '#E6A9EC',
  mauve: '#E0B0FF',
  wisteriapurple: '#C6AEC7',
  blossompink: '#F9B7FF',
  periwinkle: '#E9CFEC',
  lavenderpinocchio: '#EBDDE2',
  lavenderblue: '#E3E4FA',
  pearl: '#FDEEF4',
  milkwhite: '#FEFCFF'
};
/********************** COLOR CONVERTER *******************/

Color.rgbToHex = function (rgb) {
  return '#' + rgb.slice(0, 3).map(function (c) {
    var res = (c * 255 >> 0).toString(16);
    if (res < 10) res = '0' + res;
    return res.toUpperCase();
  }).join('');
};

Color.rgbaToHex = function (rgb) {
  return '#' + rgb.map(function (c) {
    var res = (c * 255 >> 0).toString(16);
    if (res < 10) res = '0' + res;
    return res.toUpperCase();
  }).join('');
};

Color.hsbaToText = function (hsba) {
  return 'hsba(' + (hsba[0] * 360 >> 0) + 'deg, ' + (hsba[1] * 100 >> 0) + '%, ' + (hsba[2] * 100 >> 0) + '%, ' + hsba[3].toFixed(3) + ')';
};

Color.hslaToText = function (hsla) {
  return 'hsla(' + (hsla[0] * 360 >> 0) + 'deg, ' + (hsla[1] * 100 >> 0) + '%, ' + (hsla[2] * 100 >> 0) + '%, ' + hsla[3].toFixed(3) + ')';
};

Color.rgbaToText = function (rgba) {
  return 'rgba(' + (rgba[0] * 255 >> 0) + ', ' + (rgba[1] * 255 >> 0) + ', ' + (rgba[2] * 255 >> 0) + ', ' + rgba[3].toFixed(3) + ')';
};

Color.hsbToText = function (hsba) {
  return 'hsb(' + (hsba[0] * 360 >> 0) + 'deg, ' + (hsba[1] * 100 >> 0) + '%, ' + (hsba[2] * 100 >> 0) + '%)';
};

Color.hslToText = function (hsl) {
  return 'hsl(' + (hsl[0] * 360 >> 0) + 'deg, ' + (hsl[1] * 100 >> 0) + '%, ' + (hsl[2] * 100 >> 0) + '%)';
};

Color.rgbToText = function (rgba) {
  return 'rgb(' + (rgba[0] * 255 >> 0) + ', ' + (rgba[1] * 255 >> 0) + ', ' + (rgba[2] * 255 >> 0) + ')';
};

Color.hsbaToHSLA = function (hsba) {
  var hue = hsba[0];
  var sat = hsba[1];
  var val = hsba[2]; // Calculate lightness.

  var li = (2 - sat) * val / 2; // Convert saturation.

  if (li !== 0) {
    if (li === 1) {
      sat = 0;
    } else if (li < 0.5) {
      sat = sat / (2 - sat);
    } else {
      sat = sat * val / (2 - li * 2);
    }
  } // Hue and alpha stay the same.


  return [hue, sat, li, hsba[3]];
};

Color.hsbaToRGBA = function (hsba) {
  var hue = hsba[0] * 6; // We will split hue into 6 sectors.

  var sat = hsba[1];
  var val = hsba[2];
  var RGBA = [];

  if (sat === 0) {
    RGBA = [val, val, val, hsba[3]]; // Return early if grayscale.
  } else {
    var sector = Math.floor(hue);
    var tint1 = val * (1 - sat);
    var tint2 = val * (1 - sat * (hue - sector));
    var tint3 = val * (1 - sat * (1 + sector - hue));
    var red, green, blue;

    if (sector === 1) {
      // Yellow to green.
      red = tint2;
      green = val;
      blue = tint1;
    } else if (sector === 2) {
      // Green to cyan.
      red = tint1;
      green = val;
      blue = tint3;
    } else if (sector === 3) {
      // Cyan to blue.
      red = tint1;
      green = tint2;
      blue = val;
    } else if (sector === 4) {
      // Blue to magenta.
      red = tint3;
      green = tint1;
      blue = val;
    } else if (sector === 5) {
      // Magenta to red.
      red = val;
      green = tint1;
      blue = tint2;
    } else {
      // Red to yellow (sector could be 0 or 6).
      red = val;
      green = tint3;
      blue = tint1;
    }

    RGBA = [red, green, blue, hsba[3]];
  }

  return RGBA;
};

Color.hslaToHSBA = function (hsla) {
  var hue = hsla[0];
  var sat = hsla[1];
  var li = hsla[2]; // Calculate brightness.

  var val;

  if (li < 0.5) {
    val = (1 + sat) * li;
  } else {
    val = li + sat - li * sat;
  } // Convert saturation.


  sat = 2 * (val - li) / val; // Hue and alpha stay the same.

  return [hue, sat, val, hsla[3]];
};

Color.hslaToRGBA = function (hsla) {
  var hue = hsla[0] * 6; // We will split hue into 6 sectors.

  var sat = hsla[1];
  var li = hsla[2];
  var RGBA = [];

  if (sat === 0) {
    RGBA = [li, li, li, hsla[3]]; // Return early if grayscale.
  } else {
    // Calculate brightness.
    var val;

    if (li < 0.5) {
      val = (1 + sat) * li;
    } else {
      val = li + sat - li * sat;
    } // Define zest.


    var zest = 2 * li - val; // Implement projection (project onto green by default).

    var hzvToRGB = function (hue, zest, val) {
      if (hue < 0) {
        // Hue must wrap to allow projection onto red and blue.
        hue += 6;
      } else if (hue >= 6) {
        hue -= 6;
      }

      if (hue < 1) {
        // Red to yellow (increasing green).
        return zest + (val - zest) * hue;
      } else if (hue < 3) {
        // Yellow to cyan (greatest green).
        return val;
      } else if (hue < 4) {
        // Cyan to blue (decreasing green).
        return zest + (val - zest) * (4 - hue);
      } else {
        // Blue to red (least green).
        return zest;
      }
    }; // Perform projections, offsetting hue as necessary.


    RGBA = [hzvToRGB(hue + 2, zest, val), hzvToRGB(hue, zest, val), hzvToRGB(hue - 2, zest, val), hsla[3]];
  }

  return RGBA;
};

Color.rgbaToHSBA = function (rgba) {
  var red = rgba[0];
  var green = rgba[1];
  var blue = rgba[2];
  var val = Math.max(red, green, blue);
  var chroma = val - Math.min(red, green, blue);
  var hue, sat;

  if (chroma === 0) {
    // Return early if grayscale.
    hue = 0;
    sat = 0;
  } else {
    sat = chroma / val;

    if (red === val) {
      // Magenta to yellow.
      hue = (green - blue) / chroma;
    } else if (green === val) {
      // Yellow to cyan.
      hue = 2 + (blue - red) / chroma;
    } else if (blue === val) {
      // Cyan to magenta.
      hue = 4 + (red - green) / chroma;
    }

    if (hue < 0) {
      // Confine hue to the interval [0, 1).
      hue += 6;
    } else if (hue >= 6) {
      hue -= 6;
    }
  }

  return [hue / 6, sat, val, rgba[3]];
};

Color.rgbaToHSLA = function (rgba) {
  var red = rgba[0];
  var green = rgba[1];
  var blue = rgba[2];
  var val = Math.max(red, green, blue);
  var min = Math.min(red, green, blue);
  var li = val + min; // We will halve this later.

  var chroma = val - min;
  var hue, sat;

  if (chroma === 0) {
    // Return early if grayscale.
    hue = 0;
    sat = 0;
  } else {
    if (li < 1) {
      sat = chroma / li;
    } else {
      sat = chroma / (2 - li);
    }

    if (red === val) {
      // Magenta to yellow.
      hue = (green - blue) / chroma;
    } else if (green === val) {
      // Yellow to cyan.
      hue = 2 + (blue - red) / chroma;
    } else if (blue === val) {
      // Cyan to magenta.
      hue = 4 + (red - green) / chroma;
    }

    if (hue < 0) {
      // Confine hue to the interval [0, 1).
      hue += 6;
    } else if (hue >= 6) {
      hue -= 6;
    }
  }

  return [hue / 6, sat, li / 2, rgba[3]];
};

Color.hwbaToHSBA = function (hwba) {
  return [hwba[0], 1 - hwba[1] / (1 - hwba[2]), 1 - hwba[2], hwba[3]];
};

Color.hsbaToHWBA = function (hsla) {
  return [hsla[0], (1 - hsla[1]) * hsla[2], 1 - hsla[2], hsla[3]];
};

Color.rgbaToHWBA = function (rgba) {
  return this.hsbaToHWBA(this.rgbaToHSBA(rgba));
};

Color.hwbaToRGBA = function (hwba) {
  return this.hsbaToRGBA(this.hwbaToHSBA(hwba));
};

var _default = Color;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/Toast.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/Toast.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/toast.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));

var _Element = _interopRequireDefault(require("absol/src/HTML5/Element"));

var _VariantColors = _interopRequireDefault(require("./VariantColors"));

var _utils = require("./utils");

var _Dom = _interopRequireWildcard(require("absol/src/HTML5/Dom"));

var _Color = _interopRequireDefault(require("absol/src/Color/Color"));




var $ = _ACore.default.$;
var _ = _ACore.default._;
var toastBg = {
  success: "#a4f3b6",
  info: "#67d5e7"
};
var toastTextColor = {
  success: '#454040',
  info: '#48433b'
};
(0, _utils.buildCss)(_VariantColors.default.keys.reduce(function (ac, cr) {
  var color = _Color.default.parse(toastBg[cr] || _VariantColors.default.base[cr]);

  var textColor = color.getContrastYIQ();
  var headerColor = toastTextColor[cr] || _VariantColors.default.mediumContract[cr] || color.getHightContrastColor();
  ac['.as-toast.as-variant-' + cr + ' .as-toast-variant-color'] = {
    'background-color': color.toString('hex6')
  };
  ac['.as-toast.as-variant-background.as-variant-' + cr] = {
    'background-color': color.toString('hex6'),
    color: textColor.toString('hex6')
  };
  ac['.as-toast.as-variant-background.as-variant-' + cr + ' .as-toast-header'] = {
    color: headerColor.toString('hex6')
  };
  return ac;
}, {}));
/***
 * @extends {AElement}
 * @constructor
 */

function Toast() {
  this._state = 0;
  this.$closeBtn = $('.as-toast-close-btn', this).on('click', this.disappear.bind(this));
  this.$title = $('.as-toast-title', this);
  this.$timeText = $('.as-toast-time-text', this);
  this.$body = $('.toast-body', this);
  this.$attachhook = $('attachhook', this).on('attached', this.appear.bind(this));

  _OOP.default.drillProperty(this, this.$title.firstChild, 'htitle', 'data');

  this._message = null;
  this.$message = null;
  this.disappearTimeout = 0;
  this.htitle = 'Toast.htitle';
  this.timeText = new Date();
  this.message = null;
  this.variant = null;
}

Toast.tag = 'toast';
['addChild', 'removeChild', 'clearChild', 'addChildBefore', 'addChildAfter'].forEach(function (key) {
  Toast.prototype[key] = function () {
    this.$body[key].apply(this.$body, arguments);
  };
});

Toast.render = function () {
  return _({
    extendEvent: ['appeared', 'disappeared'],
    class: ['as-toast', 'as-not-appeared'],
    child: [{
      class: 'as-toast-header',
      child: ['.as-toast-variant-color', {
        tag: 'strong',
        class: 'as-toast-title',
        child: {
          text: "Absol Js"
        }
      }, {
        tag: 'smal',
        class: 'as-toast-time-text',
        child: {
          text: '20 mis ago'
        }
      }, {
        tag: 'button',
        class: 'as-toast-close-btn',
        child: {
          tag: 'span',
          child: {
            text: '×'
          }
        }
      }]
    }, {
      class: 'toast-body'
    }, 'attachhook']
  });
};

Toast.prototype.disappear = function () {
  if (this._state !== 2) return;
  this._state = 3;
  this.addClass('as-disappearing');
  setTimeout(function () {
    this.removeClass('as-disappeared').removeClass('as-disappearing').addClass('as-not-appeared');
    this.remove();
    this.emit('disappeared', {
      target: this,
      type: 'disappeared'
    }, this);
  }.bind(this), 500);
};

Toast.prototype.appear = function () {
  if (this._state !== 0) return;
  this._state = 1;
  this.addClass('as-appearing');
  setTimeout(function () {
    this.removeClass('as-not-appeared').addClass('as-appeared').removeClass('as-appearing');
    this._state = 2;
    this.emit('appeared', {
      target: this,
      type: 'appeared'
    }, this);

    if (this.disappearTimeout > 0 && this.disappearTimeout < Infinity) {
      setTimeout(this.disappear.bind(this), this.disappearTimeout);
    }
  }.bind(this), 100);
};

Toast.property = {};
Toast.property.variant = {
  set: function (value) {
    if (this._variant && this._variant !== value) {
      this.removeClass('as-variant-' + this._variant);
    }

    if (_VariantColors.default.has(value) || ['sticky-note'].indexOf(value) >= 0) {
      this._variant = value;
      this.addClass('as-variant-' + this._variant);
    }
  },
  get: function () {
    return this._variant;
  }
};
Toast.property.message = {
  set: function (value) {
    if (typeof value !== "string" || value.length === 0) {
      value = null;
    }

    if (value) {
      if (!this.$message) {
        this.$message = _({
          class: 'as-toast-message',
          child: {
            text: ''
          }
        });
      }

      if (!this.$message.parentElement) this.$body.addChild(this.$message);
      this.$message.firstChild.data = value;
    } else {
      if (this.$message && this.$message.parentElement) {
        this.$message.remove();
      }
    }

    this._message = value;
  },
  get: function () {
    return this._message;
  }
};
Toast.property.timeText = {
  set: function (value) {
    if (value instanceof Date) {
      value = value.toLocaleTimeString();
    } else {
      value = value + '';
    }

    this.$timeText.firstChild.data = value;
  },
  get: function () {
    return this.$timeText.firstChild.data;
  }
};
Toast.$toastList = _('.as-toast-list.as-se.as-bscroller');
Toast.$toastList4Pos = {
  se: Toast.$toastList,
  sw: _('.as-toast-list.as-sw.as-bscroller'),
  nw: _('.as-toast-list.as-nw.as-bscroller'),
  ne: _('.as-toast-list.as-ne.as-bscroller')
};

_Dom.default.documentReady.then(function () {
  Toast.$toastList.addTo(document.body);
  Toast.$toastList4Pos.sw.addTo(document.body);
  Toast.$toastList4Pos.nw.addTo(document.body);
  Toast.$toastList4Pos.ne.addTo(document.body);
});
/***
 *
 * @param {AbsolConstructDescriptor|{}} aObject,
 * @param {"se"|"sw"|"ne"|"nw" } [pos="se"]
 * @return {AElementNS|AElement|Text}
 */


Toast.make = function (aObject, pos) {
  pos = pos || 'se';
  aObject = aObject || {};
  if (typeof aObject !== "object") throw new Error("param must be AbsolConstructDescriptor object!");

  if ((0, _Dom.isDomNode)(aObject)) {} else {
    aObject.tag = aObject.tag || 'toast';
  }

  var toastElt = _(aObject);

  var toastListElt = Toast.$toastList4Pos[pos] || Toast.$toastList;
  toastListElt.addChild(toastElt);
  return toastElt;
};

_ACore.default.install(Toast);

var _default = Toast;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TokenField.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TokenField.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ACore = _interopRequireWildcard(require("../ACore"));

var _SelectBoxItem = _interopRequireDefault(require("./SelectBoxItem"));

var _ResizeSystem = _interopRequireDefault(require("absol/src/HTML5/ResizeSystem"));

require("../css/tokenfield.css");

var _utils = require("./utils");

var _Vec = _interopRequireDefault(require("absol/src/Math/Vec2"));

var _Text = require("absol/src/HTML5/Text");

var _Dom = require("absol/src/HTML5/Dom");

var _EventEmitter = require("absol/src/HTML5/EventEmitter");




/***
 * @extends AElement
 * @constructor
 */
function TokenField() {
  this.on('click', this.eventHandler.click);
  this.$input = (0, _ACore.$)('input', this).on('keydown', this.eventHandler.inputKeyDown).on('focus', this.eventHandler.inputInteract).on('click', this.eventHandler.inputInteract).on('keydown', this.eventHandler.inputInteract);
  this.$attachhook = (0, _ACore.$)('attachhook', this).on('attached', function () {
    _ResizeSystem.default.add(this);

    this.requestUpdateSize();
  });
  this.$attachhook.requestUpdateSize = this.updateSize.bind(this);
  /***
   *
   * @type {SelectListBox}
   */

  this.$selectlistBox = (0, _ACore._)({
    tag: 'selectlistbox',
    props: {
      anchor: [1, 6, 2, 5]
    },
    on: {
      preupdateposition: this.eventHandler.preUpdateListPosition
    }
  });
  this.$selectlistBox.on('pressitem', this.eventHandler.selectListBoxPressItem);
  this.$selectlistBox.followTarget = this;
  this.autocomplete = null;
  this.separator = ' ';
  this.placeHolder = '';
}

TokenField.tag = 'TokenField'.toLowerCase();

TokenField.render = function () {
  return (0, _ACore._)({
    class: 'as-token-field',
    extendEvent: ['change'],
    child: [{
      tag: 'input',
      class: 'as-token-field-input-text',
      attr: {
        type: 'text',
        tabindex: '1'
      }
    }, 'attachhook']
  });
};

TokenField.prototype._makeItem = function (text) {
  var itemElt = (0, _ACore._)({
    tag: _SelectBoxItem.default.tag,
    class: 'as-token-field-item',
    attr: {
      tabindex: 1
    },
    props: {
      data: {
        text: text,
        value: text
      }
    }
  });
  itemElt.on({
    keydown: this.eventHandler.itemKeyDown.bind(this, itemElt),
    close: this.eventHandler.itemClose.bind(this, itemElt),
    focus: this.eventHandler.itemFocus.bind(this, itemElt)
  });
  return itemElt;
};

TokenField.prototype._appendItem = function (itemElt) {
  this.addChildBefore(itemElt, this.$input);
};

TokenField.prototype._updateInputWidth = function () {
  var lastItem = this.findChildBefore(this.$input);

  if (lastItem) {
    var lastItemBound = lastItem.getBoundingClientRect();
    var bound = this.getBoundingClientRect();
    var aRight = bound.right - 4 - lastItemBound.right;

    if (aRight > 60) {
      this.$input.addStyle('width', aRight + 'px');
    } else {
      this.$input.addStyle('width', '100%');
    }
  } else {
    this.$input.addStyle('width', '100%');
  }
};

TokenField.prototype._isSeparatorKey = function (key) {
  if (key === 'Enter') return true;
  if (this.separator === ' ') return key === ' ';
  if (this.separator === '\n') return key === 'Enter';
  if (this.separator === '\t') return key === 'Tab';
  return key === this.separator;
};

TokenField.prototype.updateSize = function () {
  this._updateInputWidth();
};

TokenField.prototype._notifyChange = function (data) {
  this.emit('change', Object.assign({
    type: 'change',
    target: this
  }, data), this);
};

TokenField.prototype._searchInList = function () {
  if (this._searchTimeout > 0) {
    clearTimeout(this._searchTimeout);
  }

  this._searchTimeout = setTimeout(function () {
    var text = this.$input.value;

    if (this.$selectlistBox.isDescendantOf(document.body)) {
      this.$selectlistBox.$searchInput.value = text;
      this.$selectlistBox.eventHandler.searchModify();

      if (this.$selectlistBox._displayItems.length === 0) {
        this.$selectlistBox.addStyle('visibility', 'hidden');
      } else {
        this.$selectlistBox.removeStyle('visibility');
      }
    }
  }.bind(this), 100);
};

TokenField.eventHandler = {};
TokenField.property = {};
TokenField.property.separator = {
  set: function (value) {
    if (typeof value !== "string") value = ' ';
    this._separator = value;
  },
  get: function () {
    return this._separator;
  }
};
TokenField.property.placeHolder = {
  set: function (value) {
    this.$input.attr('placeholder', value || '');
  },
  get: function () {
    return this.$input.attr('placeholder');
  }
};
TokenField.property.items = {
  set: function (items) {
    items = items || [];

    while (this.firstChild && this.firstChild && this.firstChild.containsClass('as-token-field-item')) {
      this.firstChild.remove();
    }

    for (var i = 0; i < items.length; ++i) {
      this._appendItem(this._makeItem(items[i]));
    }
  },
  get: function () {
    return Array.prototype.slice.call(this.childNodes).filter(function (elt) {
      return elt.containsClass && elt.containsClass('as-token-field-item');
    }).map(function (elt) {
      return elt.data.value;
    });
  }
};
TokenField.property.autocomplete = {
  set: function (value) {
    this._autocomplete = value || null;

    if (this._autocomplete) {
      this.$selectlistBox.items = this._autocomplete.map(function (it) {
        return {
          value: it + '',
          text: it + ''
        };
      });
    } else {
      this.$selectlistBox.items = [];
    }
  },
  get: function () {
    return this._autocomplete;
  }
};

TokenField.eventHandler.inputKeyDown = function (event) {
  if (this._isSeparatorKey(event.key)) {
    var text = this.$input.value;

    if (text.length > 0) {
      this.$input.value = '';

      var newItem = this._makeItem(text);

      this._appendItem(newItem);

      this.updateSize();

      this._notifyChange({
        action: 'add',
        item: text,
        itemElt: newItem
      });

      this.eventHandler.inputOut();
    }

    event.preventDefault();
  } else if (event.key.startsWith('Arrow') || event.key === 'Backspace') {
    if (this.$input.selectionStart === 0 && this.$input.selectionEnd === 0) {
      if (event.key === 'ArrowLeft' || event.key === 'Backspace') {
        event.preventDefault();
        var prevChild = this.findChildBefore(this.$input);
        if (prevChild) prevChild.focus();
      } else if (event.key === 'ArrowUp') {
        var item, itemBound;
        var inputBound = this.$input.getBoundingClientRect();
        var anchorPos = new _Vec.default(inputBound.left + 5, inputBound.top + inputBound.height / 2);
        var minDis = Infinity;
        var dis;
        var aboveItem;

        for (var i = 0; i < this.childNodes.length; ++i) {
          item = this.childNodes[i];

          if (item.containsClass && item.containsClass('as-token-field-item')) {
            itemBound = item.getBoundingClientRect();

            if (itemBound.bottom < inputBound.top) {
              dis = new _Vec.default(itemBound.left + itemBound.width / 2, itemBound.top + itemBound.height / 2).sub(anchorPos).abs();

              if (dis < minDis) {
                minDis = dis;
                aboveItem = item;
              }
            }
          }
        }

        if (aboveItem) {
          aboveItem.focus();
          event.preventDefault();
        }
      }
    } else {
      this._searchInList();
    }
  } else {
    this._searchInList();
  }
};

TokenField.eventHandler.inputInteract = function (event) {
  var lt = this._lastInteractTime;
  this._lastInteractTime = new Date().getTime();

  if (lt && this._lastInteractTime - lt < 100) {
    return;
  }

  if (this.$selectlistBox.isDescendantOf(document.body)) return;
  this.$selectlistBox.addTo(document.body);
  this.$selectlistBox.domSignal.$attachhook.emit('attached');

  this._searchInList();

  var bound = this.getBoundingClientRect();
  this.$selectlistBox.addStyle('min-width', bound.width + 'px');
  this.$selectlistBox.refollow();
  this.$selectlistBox.updatePosition();
  setTimeout(document.addEventListener.bind(document, 'click', this.eventHandler.inputOut), 100);
};

TokenField.eventHandler.inputOut = function (event) {
  if (event && ((0, _EventEmitter.hitElement)(this.$selectlistBox, event) || (0, _EventEmitter.hitElement)(this.$input, event))) return;
  document.removeEventListener('click', this.eventHandler.inputOut);
  this.$selectlistBox.remove();
  this._lastInteractTime = new Date().getTime();
};

TokenField.eventHandler.itemKeyDown = function (itemElt, event) {
  var nextElt;

  if (event.key === 'Delete' || event.key === 'Backspace') {
    if (event.key === 'Delete') {
      nextElt = this.findChildAfter(itemElt);
    } else {
      nextElt = this.findChildBefore(itemElt) || this.$input;
    }

    itemElt.remove();

    this._notifyChange({
      item: itemElt.data.value,
      action: 'remove',
      itemElt: itemElt
    });

    if (nextElt === this.$input) {
      this.$input.focus();
      (0, _Text.setCaretPosition)(this.$input, 0);
    } else {
      nextElt.focus();
    }
  } else if (event.key === 'ArrowLeft') {
    nextElt = this.findChildBefore(itemElt);
    if (nextElt) nextElt.focus();
  } else if (event.key === 'ArrowRight') {
    nextElt = this.findChildAfter(itemElt);

    if (nextElt === this.$input) {
      this.$input.focus();
      (0, _Text.setCaretPosition)(this.$input, 0);
    } else {
      nextElt.focus();
    }
  } else if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
    var currentItemBound = itemElt.getBoundingClientRect();
    var center = new _Vec.default(currentItemBound.left + currentItemBound.width / 2, currentItemBound.top + currentItemBound.height / 2);
    var childElt, itemBound, dis;
    var minDis = Infinity;
    var i;

    if (event.key === 'ArrowUp') {
      for (i = 0; i < this.childNodes.length; ++i) {
        childElt = this.childNodes[i];

        if (childElt.containsClass && childElt.containsClass('as-token-field-item') || childElt === this.$input) {
          itemBound = childElt.getBoundingClientRect();

          if (itemBound.bottom < currentItemBound.top) {
            dis = new _Vec.default(itemBound.left + itemBound.width / 2, itemBound.top + itemBound.height / 2).sub(center).abs();

            if (dis < minDis) {
              minDis = dis;
              nextElt = childElt;
            }
          }
        }
      }
    } else {
      for (i = 0; i < this.childNodes.length; ++i) {
        childElt = this.childNodes[i];

        if (childElt.containsClass && childElt.containsClass('as-token-field-item') || childElt === this.$input) {
          itemBound = childElt.getBoundingClientRect();

          if (itemBound.top > currentItemBound.bottom) {
            dis = new _Vec.default(itemBound.left + itemBound.width / 2, itemBound.top + itemBound.height / 2).sub(center).abs();

            if (dis < minDis) {
              minDis = dis;
              nextElt = childElt;
            }
          }
        }
      }
    }

    if (nextElt) {
      nextElt.focus();
    }
  }
};

TokenField.eventHandler.itemFocus = function (itemElt) {
  this.eventHandler.inputOut();
};

TokenField.eventHandler.itemClose = function (itemElt) {
  itemElt.remove();

  this._notifyChange({
    action: 'remove',
    item: itemElt.data.value,
    itemElt: itemElt
  });

  this.$input.focus();
};

TokenField.eventHandler.click = function (event) {
  if (event.target === this) this.$input.focus();
};

TokenField.eventHandler.preUpdateListPosition = function () {
  var bound = this.getBoundingClientRect();
  var screenSize = (0, _Dom.getScreenSize)();
  var availableTop = bound.top - 5;
  var availableBot = screenSize.height - 5 - bound.bottom;
  this.$selectlistBox.addStyle('--max-height', Math.max(availableBot, availableTop) + 'px');
  var outBound = (0, _Dom.traceOutBoundingClientRect)(this);

  if (bound.bottom < outBound.top || bound.top > outBound.bottom || bound.right < outBound.left || bound.left > outBound.right) {
    // this.isFocus = false;
    //
    console.log("OUT");
  }
};

TokenField.eventHandler.selectListBoxPressItem = function (event) {
  var text = event.data.value;

  var newItem = this._makeItem(text);

  this._appendItem(newItem);

  this.updateSize();

  this._notifyChange({
    action: 'add',
    item: text,
    itemElt: newItem
  });

  this.eventHandler.inputOut();
  this.$input.focus();
  this.$input.value = '';
};

_ACore.default.install(TokenField);

var _default = TokenField;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TrackBar.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TrackBar.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/trackbar.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Hanger = _interopRequireDefault(require("./Hanger"));

var _int = require("absol/src/Math/int");


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 * @extends Hanger
 * @constructor
 */

function TrackBar() {
  this.$bar = $('.absol-trackbar', this);
  this.$button = $('.absol-trackbar-button', this);
  this.$line = $('.absol-trackbar-line', this);
  this.on('predrag', this.eventHandler.predrag).on('drag', this.eventHandler.drag);
  this.leftValue = 0;
  this.rightValue = 1;
  this._dragValue = 0;
}

TrackBar.tag = 'trackbar';

TrackBar.render = function () {
  return _({
    tag: 'hanger',
    extendEvent: 'change',
    class: 'absol-trackbar',
    child: [{
      class: 'absol-trackbar-line',
      child: '.absol-trackbar-button'
    }, 'attachhook']
  });
};

TrackBar.prototype._updateValue = function () {
  var left = (0, _int.map)(this.value, this.leftValue, this.rightValue, 0, 100);
  this.$button.addStyle('left', left + '%');
};

TrackBar.eventHandler = {};

TrackBar.eventHandler.predrag = function (event) {
  if (event.target === this) {
    event.cancel();
  } else {
    event.preventDefault();
    var lineBound = this.$line.getBoundingClientRect();
    var newValue = this.leftValue + (this.rightValue - this.leftValue) * (event.clientX - lineBound.left) / lineBound.width;
    newValue = Math.max(this.leftValue, Math.min(this.rightValue, newValue));

    if (newValue !== this.value) {
      this.value = newValue;
      event.trackbarValue = this.value;
      this._dragValue = this.value;
      this.emit('change', event);
    }
  }
};

TrackBar.eventHandler.drag = function (event) {
  var lineWidth = this.$line.getBoundingClientRect().width;
  var d = event.currentPoint.sub(event.startingPoint);
  var delta = d.x / lineWidth * (this.rightValue - this.leftValue);
  var newValue = Math.max(this.leftValue, Math.min(this.rightValue, this._dragValue + delta));

  if (newValue != this.value) {
    this.value = newValue;
    event.trackbarValue = this.value;
    this.emit('change', event);
  }
};

TrackBar.property = {};
TrackBar.property.value = {
  set: function (value) {
    value = parseFloat(value + '');
    if (isNaN(value)) value = 0;
    this._value = value;

    this._updateValue();
  },
  get: function () {
    return Math.max(this.leftValue, Math.min(this.rightValue, this._value));
  }
};
TrackBar.property.leftValue = {
  set: function (value) {
    value = parseFloat(value + '');
    if (isNaN(value)) value = 0;
    this._leftValue = value;

    this._updateValue();
  },
  get: function () {
    return this._leftValue || 0;
  }
};
TrackBar.property.rightValue = {
  set: function (value) {
    value = parseFloat(value + '');
    if (isNaN(value)) value = 1;
    this._rightValue = value;

    this._updateValue();
  },
  get: function () {
    return this._rightValue || 1;
  }
};
TrackBar.property.disabled = {
  get: function () {
    return this.containsClass('as-disabled');
  },
  set: function (value) {
    if (value) {
      this.addClass('as-disabled');
    } else {
      this.removeClass('as-disabled');
    }
  }
};

_ACore.default.install(TrackBar);

var _default = TrackBar;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TrackBarInput.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TrackBarInput.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/trackbarinput.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _AElement = _interopRequireDefault(require("absol/src/HTML5/AElement"));


var _ = _ACore.default._;
var $ = _ACore.default.$;
/***
 *
 * @extends {AElement}
 * @constructor
 */

function TrackBarInput() {
  var thisTI = this;
  this.$trackbar = $('trackbar', this);
  this.$input = $('flexiconinput', this);
  absol.OOP.drillProperty(this, this.$input, ['unit', 'icon']);
  this.$trackbar.on('change', function () {
    thisTI.$input.value = thisTI.value + '';
    thisTI.emit('change', thisTI.value);
  });
  this.$input.on('keyup', this.eventHandler.inputChange);
  this.inputTextWidth = 2;
  this.valueFixed = undefined;
  return this;
}

TrackBarInput.tag = 'TrackBarInput'.toLowerCase();

TrackBarInput.render = function () {
  return _({
    class: 'absol-trackbar-input',
    extendEvent: 'change',
    child: ['trackbar', 'flexiconinput']
  });
};

TrackBarInput.prototype.init = function (props) {
  props = props || {};
  props.leftValue = props.leftValue || 0;
  props.value = props.value || props.leftValue;
  Object.assign(this, props);
  this.value = props.value;
};

TrackBarInput.prototype._calInputTextWidth = function () {
  var l = Math.max(this.leftValue.toFixed(this.valueFixed || 0).length, this.rightValue.toFixed(this.valueFixed || 0).length, 2);

  if (this.valueFixed > 0) {
    l -= 0.8;
  }

  this.inputTextWidth = l;
}; // absol.OOP.drillProperty(this, this.$trackbar, ['leftValue', 'rightValue']);


TrackBarInput.property = {};
TrackBarInput.property.leftValue = {
  set: function (value) {
    this.$trackbar.leftValue = value;

    this._calInputTextWidth();
  },
  get: function () {
    return this.$trackbar.leftValue;
  }
};
TrackBarInput.property.rightValue = {
  set: function (value) {
    this.$trackbar.rightValue = value;

    this._calInputTextWidth();
  },
  get: function () {
    return this.$trackbar.rightValue;
  }
};
TrackBarInput.property.value = {
  set: function (value) {
    this.$trackbar.value = value || 0;
    this.$input.value = this.value + '';
  },
  get: function () {
    return parseFloat((this.valueFixed === undefined ? this.$trackbar.value : this.$trackbar.value.toFixed(this.valueFixed)) + '');
  }
};
TrackBarInput.property.valueFixed = {
  set: function (value) {
    if (value === undefined || value === null) value = undefined;
    this._valueFixed = value;
    this.$input.value = this.value + '';

    this._calInputTextWidth();
  },
  get: function () {
    return this._valueFixed;
  }
};
TrackBarInput.property.inputTextWidth = {
  set: function (value) {
    if (typeof value == 'number') {
      this._inputTextWidth = value;
      this.addStyle('--input-width', 3 + (value - 2) * 0.42 + 0.3 + 'em');
    } else {
      this._inputTextWidth = value;
      this.addStyle('--input-width', value);
    }
  },
  get: function () {
    return this._inputTextWidth;
  }
};
TrackBarInput.property.disabled = {
  get: function () {
    return this.containsClass('as-disabled');
  },
  set: function (value) {
    if (value) {
      this.addClass('as-disabled');
    } else {
      this.removeClass('as-disabled');
    }

    this.$input.disabled = !!value;
    this.$trackbar.disabled = !!value;
  }
};
TrackBarInput.eventHandler = {};

TrackBarInput.eventHandler.inputChange = function (event) {
  var newValue = parseFloat(this.$input.value);

  if (!isNaN(newValue)) {
    newValue = Math.max(this.leftValue, Math.min(this.rightValue, newValue));
    this.$trackbar.value = newValue;
    this.emit('change', this.value);
  }
};

var _default = TrackBarInput;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TreeListItem.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TreeListItem.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/treelist.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function TreeListItem() {
  var thisTI = this;
  this.$list = $('treelist', this).on('press', function (event, sender) {
    thisTI.emit('press', event, this);
  });
  this.$parent = $('.absol-tree-list-item-parent', this).on('mousedown', this.eventHandler.clickParent);
  this.$text = $('span.absol-tree-list-item-text', this);
  this.$desc = $('span.absol-tree-list-item-desc', this);
  this.$descCtn = $('.absol-tree-list-item-desc-container', this);
  this.$list.level = 1;

  _OOP.default.drillProperty(this, this.$list, 'items');
}

TreeListItem.tag = 'TreeListItem'.toLowerCase();

TreeListItem.render = function () {
  return _({
    extendEvent: ['press', 'clickparent'],
    class: 'absol-tree-list-item',
    child: [{
      class: 'absol-tree-list-item-parent',
      child: ['span.absol-tree-list-item-text', {
        class: 'absol-tree-list-item-desc-container',
        child: 'span.absol-tree-list-item-desc'
      }]
    }, 'treelist']
  });
};

TreeListItem.eventHandler = {};

TreeListItem.eventHandler.clickParent = function (event) {
  event.preventDefault();
  var prevented = false;
  var self = this;
  this.emit('press', {
    target: self,
    preventDefault: function () {
      prevented = true;
    },
    isPrevented: function () {
      return prevented;
    },
    data: this.data
  }, this);

  if (!prevented) {
    var top = self.getTopLevelElt();
    $('treelistitem', top, function (e) {
      if (e != self) e.active = false;
    });
    self.active = true;
  }
};

TreeListItem.prototype.getTopLevelElt = function () {
  var current = this;

  while (current) {
    var parent = current.parentNode;
    if (!parent || !parent.classList.contains('absol-tree-list') && !parent.classList.contains('absol-tree-list-item')) break;
    current = current.parentNode;
  }

  return current;
};

TreeListItem.property = {
  text: {
    set: function (value) {
      value = value + '';
      this.$text.innerHTML = value;
    },
    get: function () {
      return this.$text.innerHTML;
    }
  },
  desc: {
    set: function (value) {
      value = value + '';
      this.$desc.innerHTML = value;
    },
    get: function () {
      return this.$desc.innerHTML;
    }
  },
  level: {
    set: function (value) {
      value = value || 0;
      if (value == this.level) return;
      this._level = value;
      this.$parent.addStyle('padding-left', this._level * 0.4 * 3 + 'em');
      this.$list.level = value + 1;
    },
    get: function () {
      return this._level || 0;
    }
  },
  active: {
    set: function (value) {
      if (value) {
        this.addClass('active');
      } else {
        this.removeClass('active');
      }
    },
    get: function () {
      return this.containsClass('active');
    }
  },
  data: {
    set: function (value) {
      this._data = value;
    },
    get: function () {
      return this._data;
    }
  },
  value: {
    get: function () {
      var data = this.data;
      if (typeof data == 'string') return data;

      if (typeof data.value == "undefined") {
        return data.text;
      } else {
        return data.value;
      }
    }
  }
};
TreeListItem.property.extendClasses = {
  set: function (value) {
    var self = this;
    this.extendClasses.forEach(function (className) {
      self.$parent.removeClass(className);
    });
    this._extendClass = [];
    if (!value) return;

    if (typeof value == 'string') {
      value = value.split(/\s+/).filter(function (c) {
        return c.length > 0;
      });
    }

    if (value instanceof Array) {
      this._extendClass = value;

      this._extendClass.forEach(function (className) {
        self.$parent.addClass(className);
      });
    } else {
      throw new Error('Invalid extendClasses');
    }
  },
  get: function () {
    return this._extendClass || [];
  }
};
TreeListItem.property.extendStyle = {
  set: function (value) {
    this.$parent.removeStyle(this._extendStyle || {});
    this._extendStyle = value || {};
    this.$parent.addStyle(this.extendStyle);
  },
  get: function () {
    return this._extendStyle || {};
  }
};

_ACore.default.install(TreeListItem);

var _default = TreeListItem;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/TreeList.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/TreeList.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/treelist.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _TreeListItem = _interopRequireDefault(require("./TreeListItem"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function TreeList() {}

TreeList.tag = 'treelist';

TreeList.render = function () {
  return _({
    class: 'absol-tree-list',
    extendEvent: 'press'
  });
};

TreeList.prototype.realignDescription = function (extMarginLeft) {
  extMarginLeft = extMarginLeft || 0;
  var maxWidth = 0;
  var ctns = [];
  $('.absol-tree-list-item-desc-container', this, function (elt) {
    ctns.push(elt);
    var bound = elt.getBoundingClientRect();
    maxWidth = Math.max(maxWidth, bound.width);
  });
  var fontSize = this.getFontSize();
  var cntWidth = maxWidth / fontSize + 'em';
  var extMarginRight = maxWidth / fontSize + extMarginLeft + 'em';
  ctns.forEach(function (e) {
    e.addStyle('width', cntWidth);
  });
  $('span.absol-tree-list-item-text', this, function (elt) {
    elt.addStyle('margin-right', extMarginRight);
  });
  return this;
};

TreeList.prototype.clearItems = function () {
  this._items = [];
  this.clearChild();
};

TreeList.prototype.getAllItem = function () {
  return this._items || [];
};

TreeList.prototype.getAllItemElement = function () {
  return Array.apply(null, this.childNodes);
};

TreeList.prototype.addItem = function (item) {
  var self = this;
  var props = {
    level: this.level,
    data: item
  };

  if (typeof item == 'string') {
    props.text = item;
  } else {
    props.text = item.text;

    if (item.items) {
      props.items = item.items;
    }

    if (item.desc) {
      props.desc = item.desc;
    }

    if (item.extendClasses) {
      props.extendClasses = item.extendClasses;
    }

    if (item.extendStyle) {
      props.extendStyle = item.extendStyle;
    }
  }

  var elt = _({
    tag: 'treelistitem',
    props: props,
    on: {
      press: function (event) {
        self.emit('press', event, this);
      }
    }
  });

  this.addChild(elt);

  this._items.push(item);

  return this;
};

TreeList.property = {};
TreeList.property.items = {
  set: function (value) {
    this.clearItems();
    (value || []).forEach(this.addItem.bind(this));
  },
  get: function () {
    return this.getAllItem();
  }
};
TreeList.property.level = {
  set: function (value) {
    value = value || 0;
    if (this.level == value) return;
    this._level = value;
    this.getAllItemElement().forEach(function (e) {
      e.level = value;
    });
  },
  get: function () {
    return this._level || 0;
  }
};

_ACore.default.install(TreeList);

var _default = TreeList;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/VRuler.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/VRuler.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/vruler.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));


var _ = _ACore.default._;
var $ = _ACore.default.$;

function VRuler() {
  var self = this;
  this.$attachHook = _('attachhook').on('error', function () {
    this.updateSize = self.update.bind(self);

    _Dom.default.addToResizeSystem(this);

    this.updateSize();
  }).addTo(this);
  this.$lines = [];
  this.$numbers = [];
  this.$measureTarget = undefined;
  this._viewingNumberCount = 0;
  this._viewingLineCount = 0;
  this._spacing = 10;
  this._major = 10;
  this._valueFloat = 'top';
}

VRuler.tag = 'vruler';

VRuler.render = function () {
  return _({
    class: 'as-vruler'
  });
};

VRuler.prototype.measureElement = function (elt) {
  if (typeof elt == "string") elt = $(elt);
  this.$measureTarget = elt;
  this.update();
};

VRuler.prototype.update = function () {
  var fontSize = this.getFontSize();
  var measureBound;
  var bound = this.getBoundingClientRect();
  var contentBound = {
    left: bound.left + 1,
    right: bound.right - 1,
    top: bound.top + 1,
    bottom: bound.bottom - 1,
    width: bound.width - 2,
    height: bound.height - 2
  };

  if (this.$measureTarget) {
    measureBound = this.$measureTarget.getBoundingClientRect();
  } else {
    measureBound = contentBound;
  }

  var startOfset = (measureBound[this._valueFloat] - contentBound[this._valueFloat]) * (this.inverse ? -1 : 1) % this._spacing;
  if (startOfset < 0) startOfset += this._spacing;
  var lineIndexOfset = Math.round(((contentBound[this._valueFloat] - measureBound[this._valueFloat]) * (this.inverse ? -1 : 1) + startOfset) / this._spacing);
  var lineCount = Math.floor((contentBound.height - startOfset) / this._spacing) + 1;

  while (this.$lines.length < lineCount) {
    this.$lines.push(_('.as-vruler-line'));
  }

  var i;
  var lineElt;

  for (i = 0; i < lineCount; ++i) {
    lineElt = this.$lines[i];

    if ((i + lineIndexOfset) % this._major == 0) {
      lineElt.addClass('major');
    } else {
      lineElt.removeClass('major');
    }

    lineElt.addStyle(this._valueFloat, startOfset + this._spacing * i - 0.5 + 'px');
  }

  while (this._viewingLineCount < lineCount) {
    this.$lines[this._viewingLineCount++].addTo(this);
  }

  while (this._viewingLineCount > lineCount) {
    this.$lines[--this._viewingLineCount].remove();
  }

  var numberCount = Math.floor((lineCount + lineIndexOfset - 1) / this._major) - Math.ceil(lineIndexOfset / this._major) + 1;

  while (this.$numbers.length < numberCount) {
    this.$numbers.push(_('.as-vruler-major-number'));
  }

  var numberElt;
  var number;
  var majorStartOfset = startOfset;

  if (lineIndexOfset > 0) {
    majorStartOfset += (this._major - lineIndexOfset % this._spacing) * this._spacing;
  } else {
    majorStartOfset += (this._major - (this._spacing + lineIndexOfset % this._spacing)) * this._spacing;
  }

  for (i = 0; i < numberCount; ++i) {
    number = (Math.ceil(lineIndexOfset / this._major) + i) * this._spacing * this._major;
    numberElt = this.$numbers[i];

    if (numberElt.__cacheNumber__ != number) {
      numberElt.__cacheNumber__ = number;
      numberElt.innerHTML = number + '';
    }

    numberElt.addStyle(this._valueFloat, majorStartOfset + this._major * i * this._spacing - 0.7 * 0.5 * fontSize + 'px');
  }

  while (this._viewingNumberCount < numberCount) {
    this.$numbers[this._viewingNumberCount++].addTo(this);
  }

  while (this._viewingNumberCount > numberCount) {
    this.$numbers[--this._viewingNumberCount].remove();
  }
};

VRuler.property = {};
VRuler.property.major = {
  set: function (value) {
    if (value > 0) {
      this._major = value;
      this.update();
    }
  },
  get: function () {
    return this._major;
  }
};
VRuler.property.spacing = {
  set: function (value) {
    if (value > 0) {
      this._spacing = value;
      this.update();
    }
  },
  get: function () {
    return this._spacing;
  }
};
VRuler.property.inverse = {
  set: function (value) {
    this._valueFloat = value ? 'bottom' : 'top';
    this.update();
  },
  get: function () {
    return this._valueFloat == 'bottom';
  }
};

_ACore.default.install('vruler', VRuler);

var _default = VRuler;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/VerticalTreeDiagram.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/VerticalTreeDiagram.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalTreeDiagramNode = VerticalTreeDiagramNode;
exports.default = void 0;

require("../css/verticaltreediagram.css");

var _ACore = _interopRequireWildcard(require("../ACore"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));




function VerticalTreeDiagramNode() {
  this.$childCtn = (0, _ACore.$)('.as-vertical-tree-diagram-child-ctn', this);
  this.$name = (0, _ACore.$)('.as-vertical-tree-diagram-node-name', this);

  _OOP.default.drillProperty(this, this.$name.firstChild, 'name', 'data');

  this.name = "UndefinedNodeName";
}

VerticalTreeDiagramNode.tag = 'VerticalTreeDiagramNode'.toLowerCase();

VerticalTreeDiagramNode.render = function () {
  return (0, _ACore._)({
    class: 'as-vertical-tree-diagram-node',
    child: [{
      class: 'as-vertical-tree-diagram-node-name-ctn',
      child: {
        class: 'as-vertical-tree-diagram-node-name',
        child: {
          text: ""
        }
      }
    }, {
      class: 'as-vertical-tree-diagram-child-ctn'
    }]
  });
};

['addChild', 'removeChild', 'clearChild', 'addChildBefore', 'addChildAfter', 'findChildBefore', 'findChildAfter'].forEach(function (name) {
  VerticalTreeDiagramNode.prototype[name] = function () {
    this.$childCtn[name].apply(this.$childCtn, arguments);

    if (this.$childCtn.childNodes.length > 0) {
      this.addClass('as-has-child');

      if (this.$childCtn.childNodes.length === 1) {
        this.addClass('as-has-1-child');
      } else {
        this.removeClass('as-has-1-child');
      }
    } else {
      this.removeClass('as-has-child');
      this.removeClass('as-has-1-child');
    }
  };
});

function VerticalTreeDiagram(data) {
  this.data = data || {};
}

VerticalTreeDiagram.tag = 'VerticalTreeDiagram'.toLowerCase();

VerticalTreeDiagram.render = function () {
  return (0, _ACore._)(VerticalTreeDiagramNode.tag, true);
};

VerticalTreeDiagram.property = {};
VerticalTreeDiagram.property.data = {
  set: function (data) {
    data = data || {};
    this._data = data;

    function makeNode(nodeData) {
      return (0, _ACore._)({
        tag: VerticalTreeDiagramNode.tag,
        props: {
          name: nodeData.name
        },
        child: nodeData.child && nodeData.child.length > 0 && nodeData.child.map(makeNode) || []
      });
    }

    this.name = data.name + '';
    this.clearChild();
    if (data.child) this.addChild(data.child.map(makeNode));
  },
  get: function () {
    return this._data;
  }
};

_ACore.default.install(VerticalTreeDiagramNode);

_ACore.default.install(VerticalTreeDiagram);

var _default = VerticalTreeDiagram;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/WidthHeightSizer.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/WidthHeightSizer.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("../css/widthheightresizer.css");

var _ACore = _interopRequireDefault(require("../ACore"));

var _Draggable = _interopRequireDefault(require("./Draggable"));

var _OOP = _interopRequireDefault(require("absol/src/HTML5/OOP"));


//can replace with other module
var _ = _ACore.default._;
var $ = _ACore.default.$;

function WidthHeightResizer() {
  var res = _({
    extendEvent: 'sizechange',
    class: 'absol-width-height-resizer',
    child: ['.absol-width-height-resizer-content', '.absol-width-height-resizer-anchor-bot-right', '.absol-width-height-resizer-anchor-bot-left', '.absol-width-height-resizer-anchor-top-right', '.absol-width-height-resizer-anchor-top-left']
  });

  res.eventHandler = _OOP.default.bindFunctions(res, WidthHeightResizer.eventHandler);
  res.$anchorBotRight = $('.absol-width-height-resizer-anchor-bot-right', res);
  res.$anchorTopRight = $('.absol-width-height-resizer-anchor-top-right', res);
  res.$anchorBotLeft = $('.absol-width-height-resizer-anchor-bot-left', res);
  res.$anchorTopLeft = $('.absol-width-height-resizer-anchor-top-left', res);
  res.$content = $('.absol-width-height-resizer-content', res);
  (0, _Draggable.default)(res.$anchorBotRight).on('drag', res.eventHandler.dragBotRight).on('predrag', res.eventHandler.preDrag);
  (0, _Draggable.default)(res.$anchorTopRight).on('drag', res.eventHandler.dragTopRight).on('predrag', res.eventHandler.preDrag);
  (0, _Draggable.default)(res.$anchorBotLeft).on('drag', res.eventHandler.dragBotLeft).on('predrag', res.eventHandler.preDrag);
  (0, _Draggable.default)(res.$anchorTopLeft).on('drag', res.eventHandler.dragTopLeft).on('predrag', res.eventHandler.preDrag);
  return res;
}

['addChild', 'addChildBefore', 'addChildAfter', 'clearChild'].forEach(function (key) {
  WidthHeightResizer.prototype[key] = function () {
    return this.$content[key].apply(this.$content, arguments);
  };
});
WidthHeightResizer.tag = 'WidthHeightResizer'.toLowerCase();
WidthHeightResizer.eventHandler = {};

WidthHeightResizer.eventHandler.preDrag = function (event) {
  this._whrWidth = parseFloat(this.getComputedStyleValue('width').replace('px', ''));
  this._whrHeight = parseFloat(this.getComputedStyleValue('height').replace('px', ''));
};

WidthHeightResizer.eventHandler.dragBotRight = function (event) {
  var newEvent = {
    target: this,
    data: {}
  };

  if (event.moveDX != 0) {
    this.addStyle('width', this._whrWidth + event.moveDX + 'px');
    newEvent.data.changeWidth = true;
  }

  if (event.moveDY != 0) {
    this.addStyle('height', this._whrHeight + event.moveDY + 'px');
    newEvent.data.changeHeight = true;
  }

  newEvent.data.height = this.getComputedStyleValue('height');
  newEvent.data.width = this.getComputedStyleValue('width');
  this.emit('sizechange', newEvent);
};

WidthHeightResizer.eventHandler.dragTopRight = function (event) {
  var newEvent = {
    target: this,
    data: {}
  };

  if (event.moveDX != 0) {
    this.addStyle('width', this._whrWidth + event.moveDX + 'px');
    newEvent.data.changeWidth = true;
  }

  if (event.moveDY != 0) {
    this.addStyle('height', this._whrHeight - event.moveDY + 'px');
    newEvent.data.changeHeight = true;
  }

  newEvent.data.height = this.getComputedStyleValue('height');
  newEvent.data.width = this.getComputedStyleValue('width');
  this.emit('sizechange', newEvent);
};

WidthHeightResizer.eventHandler.dragBotLeft = function (event) {
  var newEvent = {
    target: this,
    data: {}
  };

  if (event.moveDX != 0) {
    this.addStyle('width', this._whrWidth - event.moveDX + 'px');
    newEvent.data.changeWidth = true;
  }

  if (event.moveDY != 0) {
    this.addStyle('height', this._whrHeight + event.moveDY + 'px');
    newEvent.data.changeHeight = true;
  }

  newEvent.data.height = this.getComputedStyleValue('height');
  newEvent.data.width = this.getComputedStyleValue('width');
  this.emit('sizechange', newEvent);
};

WidthHeightResizer.eventHandler.dragTopLeft = function (event) {
  var newEvent = {
    target: this,
    data: {}
  };

  if (event.moveDX != 0) {
    this.addStyle('width', this._whrWidth - event.moveDX + 'px');
    newEvent.data.changeWidth = true;
  }

  if (event.moveDY != 0) {
    this.addStyle('height', this._whrHeight - event.moveDY + 'px');
    newEvent.data.changeHeight = true;
  }

  newEvent.data.height = this.getComputedStyleValue('height');
  newEvent.data.width = this.getComputedStyleValue('width');
  this.emit('sizechange', newEvent);
};

_ACore.default.creator.widthheightresizer = WidthHeightResizer;
var _default = WidthHeightResizer;
exports.default = _default;
return module.exports;
};

moduleFactories["node_modules/absol-acomp/js/dom/install.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: node_modules/absol-acomp/js/dom/install.js ***/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.publicCreators = void 0;

var _AutoCompleteInput = _interopRequireDefault(require("../AutoCompleteInput"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _BoardTable = _interopRequireDefault(require("../BoardTable"));

var _Board = _interopRequireDefault(require("../Board"));

var _BScroller = _interopRequireDefault(require("../BScroller"));

var _ButtonArray = _interopRequireDefault(require("../ButtonArray"));

var _CalendarInput = _interopRequireWildcard(require("../CalendarInput"));

var _CheckBoxInput = _interopRequireDefault(require("../CheckBoxInput"));

var _CheckBox = _interopRequireDefault(require("../CheckBox"));

var _ChromeCalendar = _interopRequireDefault(require("../ChromeCalendar"));

var _CircleSectionLabel = _interopRequireDefault(require("../CircleSectionLabel"));

var _Scroller = require("../Scroller");

var _ContextMenu = _interopRequireDefault(require("../ContextMenu"));

var _Menu = require("../Menu");

var _DateInput = _interopRequireDefault(require("../DateInput2"));

var _DraggableHStack = _interopRequireDefault(require("../DraggableHStack"));

var _DraggableVStack = _interopRequireDefault(require("../DraggableVStack"));

var _Hanger = _interopRequireDefault(require("../Hanger"));

var _DropPanel = _interopRequireDefault(require("../DropPanel"));

var _DropPanelStack = _interopRequireDefault(require("../DropPanelStack"));

var _EditableText = _interopRequireDefault(require("../EditableText"));

var _EmojiPicker = _interopRequireDefault(require("../EmojiPicker"));

var _Sprite = _interopRequireDefault(require("../Sprite"));

var _ExpTree = _interopRequireWildcard(require("../ExpTree"));

var _FlexiconButton = _interopRequireDefault(require("../FlexiconButton"));

var _FlexiconInput = _interopRequireDefault(require("../FlexiconInput"));

var _Follower = _interopRequireDefault(require("../Follower"));

var _Frame = _interopRequireDefault(require("../Frame"));

var _FrameView = _interopRequireDefault(require("../FrameView"));

var _TabFrame = _interopRequireDefault(require("../TabFrame"));

var _TabView = _interopRequireDefault(require("../TabView"));

var _SinglePage = _interopRequireDefault(require("../SinglePage"));

var _HexaSectionLabel = _interopRequireDefault(require("../HexaSectionLabel"));

var _VRuler = _interopRequireDefault(require("../VRuler"));

var _HRuler = _interopRequireDefault(require("../HRuler"));

var _IconSprite = _interopRequireDefault(require("../IconSprite"));

var _LinearColorBar = _interopRequireDefault(require("../LinearColorBar"));

var _MediaInput = _interopRequireDefault(require("../MediaInput"));

var _MessageInput = _interopRequireWildcard(require("../MessageInput"));

var _NumberInput = _interopRequireDefault(require("../NumberInput"));

var _NumberSpanInput = _interopRequireDefault(require("../NumberSpanInput"));

var _OnsScreenWindow = _interopRequireDefault(require("../OnsScreenWindow"));

var _PageSelector = _interopRequireDefault(require("../PageSelector"));

var _PreInput = _interopRequireDefault(require("../PreInput"));

var _ProgressBar = _interopRequireDefault(require("../ProgressBar"));

var _QuickListButton = _interopRequireDefault(require("../QuickListButton"));

var _FollowerToggler = _interopRequireDefault(require("../FollowerToggler"));

var _SelectList = _interopRequireDefault(require("../SelectList"));

var _QuickMenu = _interopRequireDefault(require("../QuickMenu"));

var _QuickPath = _interopRequireDefault(require("../QuickPath"));

var _RadioButton = _interopRequireDefault(require("../RadioButton"));

var _Radio = _interopRequireDefault(require("../Radio"));

var _RemoteSvg = _interopRequireDefault(require("../RemoteSvg"));

var _ResizeBox = _interopRequireDefault(require("../ResizeBox"));

var _Searcher = _interopRequireDefault(require("../Searcher"));

var _SelectBox = _interopRequireDefault(require("../SelectBox"));

var _SelectBoxItem = _interopRequireDefault(require("../SelectBoxItem"));

var _SelectTable = _interopRequireDefault(require("../SelectTable"));

var _SelectTable2 = _interopRequireDefault(require("../SelectTable2"));

var _SpanInput = _interopRequireDefault(require("../SpanInput"));

var _StaticTabbar = _interopRequireDefault(require("../StaticTabbar"));

var _Switch = _interopRequireDefault(require("../Switch"));

var _CheckboxButton = _interopRequireDefault(require("../CheckboxButton"));

var _TableScroller = _interopRequireDefault(require("../TableScroller"));

var _TableVScroller = _interopRequireDefault(require("../TableVScroller"));

var _TextArea = _interopRequireDefault(require("../TextArea2"));

var _TextClipboard = _interopRequireDefault(require("../TextClipboard"));

var _TimeInput = _interopRequireDefault(require("../TimeInput"));

var _TimePicker = _interopRequireDefault(require("../TimePicker"));

var _Tooltip = _interopRequireDefault(require("../Tooltip"));

var _TreeList = _interopRequireDefault(require("../TreeList"));

var _TreeListItem = _interopRequireDefault(require("../TreeListItem"));

var _SelectTreeMenu = _interopRequireDefault(require("../SelectTreeMenu"));

var _WidthHeightSizer = _interopRequireDefault(require("../WidthHeightSizer"));

var _Modal = _interopRequireDefault(require("../Modal"));

var _TrackBar = _interopRequireDefault(require("../TrackBar"));

var _TrackBarInput = _interopRequireDefault(require("../TrackBarInput"));

var _SelectMenu = _interopRequireDefault(require("../SelectMenu2"));

var _ButtonRange = _interopRequireDefault(require("../ButtonRange"));

var _DropZone = _interopRequireDefault(require("../DropZone"));

var _RadioInput = _interopRequireDefault(require("../RadioInput"));

var _OnScreenWidget = _interopRequireDefault(require("../OnScreenWidget"));

var _SelectListBox = _interopRequireDefault(require("../SelectListBox"));

var _SelectTreeBox = _interopRequireDefault(require("../SelectTreeBox"));

var _RibbonSplitButton = _interopRequireDefault(require("../RibbonSplitButton"));

var _RibbonButton = _interopRequireDefault(require("../RibbonButton"));

var _TimeSelectInput = _interopRequireDefault(require("../TimeSelectInput"));

var _Snackbar = _interopRequireDefault(require("../Snackbar"));

var _MultiSelectMenu = _interopRequireDefault(require("../MultiSelectMenu"));

var _CountdownClock = _interopRequireDefault(require("../CountdownClock"));

var _Toast = _interopRequireDefault(require("../Toast"));

var _Icons = require("../Icons");

var _EmojiPickerTooltip = _interopRequireDefault(require("../EmojiPickerTooltip"));

var _PageIndicator = _interopRequireDefault(require("../PageIndicator"));

var _EmojiCounter = _interopRequireDefault(require("../EmojiCounter"));

var _EmojiCounterList = _interopRequireDefault(require("../EmojiCounterList"));

var _RotatedText = _interopRequireDefault(require("../RotatedText"));

var _VerticalTreeDiagram = _interopRequireWildcard(require("../VerticalTreeDiagram"));

var _TokenField = _interopRequireDefault(require("../TokenField"));

var _DateTimeInput = _interopRequireDefault(require("../DateTimeInput"));

var _ChromeTimePicker = _interopRequireDefault(require("../ChromeTimePicker"));

var _DVExpTree = _interopRequireDefault(require("../DVExpTree"));




var publicCreators = [_AutoCompleteInput.default, _BoardTable.default, _Board.default, _BScroller.default, _ButtonArray.default, _ButtonRange.default, _CalendarInput.default, _CalendarInput.OldCalendarInput, _CheckBoxInput.default, _CheckBox.default, _CheckboxButton.default, _ChromeCalendar.default, _ChromeTimePicker.default, _CircleSectionLabel.default, _CountdownClock.default, _DropZone.default, _EmojiPickerTooltip.default, _Scroller.Scrollbar, _Scroller.VScrollbar, _Scroller.HScrollbar, _Scroller.VScroller, _Scroller.HScroller, _ContextMenu.default, _Menu.HMenu, _Menu.VMenuItem, _Menu.VMenu, _Menu.Dropright, _Menu.VMenuLine, _Menu.Dropdown, _Menu.HMenuItem, _Menu.VMenu, _Menu.VRootMenu, _Menu.MenuButton, _DateInput.default, _Hanger.default, _DraggableHStack.default, _DraggableVStack.default, _DropPanel.default, _DropPanelStack.default, _EditableText.default, _EmojiPicker.default, _EmojiCounter.default, _EmojiCounterList.default, _Sprite.default, _ExpTree.ExpNode, _ExpTree.default, _ExpTree.ExpGroup, _DVExpTree.default, _FlexiconButton.default, _FlexiconInput.default, _Follower.default, _FollowerToggler.default, _Frame.default, _FrameView.default, _TabFrame.default, _TabView.default, _SinglePage.default, _HexaSectionLabel.default, _VRuler.default, _HRuler.default, _IconSprite.default, _LinearColorBar.default, _MediaInput.default, _MessageInput.default, _MessageInput.MessageQuote, _Modal.default, _NumberInput.default, _NumberSpanInput.default, _OnsScreenWindow.default, _OnScreenWidget.default, _PageIndicator.default, _PageSelector.default, _PreInput.default, _ProgressBar.default, _QuickListButton.default, _QuickMenu.default, _QuickPath.default, _Radio.default, _RadioButton.default, _RadioInput.default, _RibbonSplitButton.default, _RibbonButton.default, _RotatedText.default, _SelectList.default, _RemoteSvg.default, _ResizeBox.default, _Searcher.default, _SelectListBox.default, _SelectTreeBox.default, _SelectMenu.default, _SelectBox.default, _MultiSelectMenu.default, _SelectBoxItem.default, _SelectTable.default, _SelectTable2.default, _SelectTreeMenu.default, _SpanInput.default, _Snackbar.default, _StaticTabbar.default, _Switch.default, _TableScroller.default, _TableVScroller.default, _TextArea.default, _TextClipboard.default, _TimeInput.default, _TimeSelectInput.default, _TimePicker.default, _DateTimeInput.default, _Tooltip.default, _Toast.default, _TreeList.default, _TreeListItem.default, _TokenField.default, _WidthHeightSizer.default, _TrackBar.default, _TrackBarInput.default, _Icons.SpinnerIco, _VerticalTreeDiagram.VerticalTreeDiagramNode, _VerticalTreeDiagram.default];
/***
 *
 * @param {Dom} core
 */

exports.publicCreators = publicCreators;

function install(core) {
  core.install(publicCreators);
  core.install('checkboxbutton', _CheckBoxInput.default);
  core.install('selectbox', _MultiSelectMenu.default);
}

var _default = install;
exports.default = _default;
return module.exports;
};

moduleFactories["lite.js"] = function(module, exports, require, __dir__, __file_name__){
/*** module: lite.js ***/
"use strict";

require("absol/src/Color/Color");

var datetime = _interopRequireWildcard(require("absol/src/Time/datetime"));

var _Dom = _interopRequireDefault(require("absol/src/HTML5/Dom"));

var _Svg = _interopRequireDefault(require("absol/src/HTML5/Svg"));

var _install = _interopRequireDefault(require("absol-acomp/js/dom/install"));




window.absol = {
  require: require,
  datetime: datetime,
  Dom: _Dom.default,
  Svg: _Svg.default,
  coreDom: _Dom.default.ShareInstance,
  coreSvg: _Svg.default.ShareInstance
};
(0, _install.default)(_Dom.default.ShareInstance);
absol.require = require;
return module.exports;
};


module_require(null,"lite.js");

})(Function('return this')());
